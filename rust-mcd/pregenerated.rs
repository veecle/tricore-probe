/* automatically generated by rust-bindgen 0.69.4 */

pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const REVISION_STRING: &[u8; 12] = b"$Rev: 156 $\0";
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 0;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const _MAX_ITOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ITOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_LTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_LTOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_ULTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ULTOSTR_BASE10_COUNT: u32 = 11;
pub const _MAX_ULTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ULTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_I64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_I64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_I64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_I64TOSTR_BASE2_COUNT: u32 = 65;
pub const _MAX_U64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_U64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_U64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_U64TOSTR_BASE2_COUNT: u32 = 65;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const MB_LEN_MAX: u32 = 5;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MIN: i32 = -2147483648;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const EXIT_SUCCESS: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const _WRITE_ABORT_MSG: u32 = 1;
pub const _CALL_REPORTFAULT: u32 = 2;
pub const _OUT_TO_DEFAULT: u32 = 0;
pub const _OUT_TO_STDERR: u32 = 1;
pub const _OUT_TO_MSGBOX: u32 = 2;
pub const _REPORT_ERRMODE: u32 = 3;
pub const RAND_MAX: u32 = 32767;
pub const _CVTBUFSIZE: u32 = 349;
pub const _MAX_PATH: u32 = 260;
pub const _MAX_DRIVE: u32 = 3;
pub const _MAX_DIR: u32 = 256;
pub const _MAX_FNAME: u32 = 256;
pub const _MAX_EXT: u32 = 256;
pub const _MAX_ENV: u32 = 32767;
pub const MCD_API_VER_MAJOR: u32 = 1;
pub const MCD_API_VER_MINOR: u32 = 1;
pub const MCD_API_VER_AUTHOR: &[u8; 15] = b"SPRINT Release\0";
pub const MCD_HOSTNAME_LEN: u32 = 64;
pub const MCD_REG_NAME_LEN: u32 = 32;
pub const MCD_MEM_SPACE_NAME_LEN: u32 = 32;
pub const MCD_MEM_BLOCK_NAME_LEN: u32 = 32;
pub const MCD_MEM_BLOCK_NOPARENT: u32 = 0;
pub const MCD_MEM_AUSIZE_NUM: u32 = 8;
pub const MCD_INFO_STR_LEN: u32 = 256;
pub const MCD_KEY_LEN: u32 = 64;
pub const MCD_UNIQUE_NAME_LEN: u32 = 64;
pub const MCD_MAX_TRIGS: u32 = 32;
pub const MCD_API_IMP_VENDOR_LEN: u32 = 32;
pub const MCD_CHL_NUM_MAX: u32 = 32;
pub const MCD_CHL_LOWEST_PRIORITY: u32 = 15;
pub const MCD_TX_NUM_MAX: u32 = 64;
pub const MCD_GUARANTEED_MIN_PAYLOAD: u32 = 16384;
pub const MCD_CORE_MODE_NAME_LEN: u32 = 32;
pub type va_list = *mut ::std::os::raw::c_char;
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type mcd_char_t = ::std::os::raw::c_char;
pub type mcd_bool_t = u32;
pub type __crt_bool = bool;
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___crt_locale_data_public() {
    const UNINIT: ::std::mem::MaybeUninit<__crt_locale_data_public> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_data_public>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_data_public>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_pctype) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(__crt_locale_data_public),
        "::",
        stringify!(_locale_pctype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_mb_cur_max) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(__crt_locale_data_public),
        "::",
        stringify!(_locale_mb_cur_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_lc_codepage) as usize - ptr as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(__crt_locale_data_public),
        "::",
        stringify!(_locale_lc_codepage)
        )
    );
}
impl Default for __crt_locale_data_public {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
#[test]
fn bindgen_test_layout___crt_locale_pointers() {
    const UNINIT: ::std::mem::MaybeUninit<__crt_locale_pointers> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_pointers>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_pointers>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).locinfo) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(__crt_locale_pointers),
        "::",
        stringify!(locinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mbcinfo) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(__crt_locale_pointers),
        "::",
        stringify!(mbcinfo)
        )
    );
}
impl Default for __crt_locale_pointers {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__Mbstatet() {
    const UNINIT: ::std::mem::MaybeUninit<_Mbstatet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Mbstatet>(),
        8usize,
        concat!("Size of: ", stringify!(_Mbstatet))
    );
    assert_eq!(
        ::std::mem::align_of::<_Mbstatet>(),
        4usize,
        concat!("Alignment of ", stringify!(_Mbstatet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Wchar) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_Mbstatet),
        "::",
        stringify!(_Wchar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Byte) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(_Mbstatet),
        "::",
        stringify!(_Byte)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._State) as usize - ptr as usize },
        6usize,
        concat!(
        "Offset of field: ",
        stringify!(_Mbstatet),
        "::",
        stringify!(_State)
        )
    );
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
pub type _onexit_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
pub type _purecall_handler = ::std::option::Option<unsafe extern "C" fn()>;
pub type _invalid_parameter_handler = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const wchar_t,
        arg2: *const wchar_t,
        arg3: *const wchar_t,
        arg4: ::std::os::raw::c_uint,
        arg5: usize,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__div_t() {
    const UNINIT: ::std::mem::MaybeUninit<_div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_div_t>(),
        8usize,
        concat!("Size of: ", stringify!(_div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_div_t),
        "::",
        stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(_div_t),
        "::",
        stringify!(rem)
        )
    );
}
pub type div_t = _div_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ldiv_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_ldiv_t),
        "::",
        stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(_ldiv_t),
        "::",
        stringify!(rem)
        )
    );
}
pub type ldiv_t = _ldiv_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout__lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<_lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(_lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_lldiv_t),
        "::",
        stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(_lldiv_t),
        "::",
        stringify!(rem)
        )
    );
}
pub type lldiv_t = _lldiv_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LDOUBLE {
    pub ld: [::std::os::raw::c_uchar; 10usize],
}
#[test]
fn bindgen_test_layout__LDOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_LDOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDOUBLE>(),
        10usize,
        concat!("Size of: ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDOUBLE>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ld) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_LDOUBLE),
        "::",
        stringify!(ld)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CRT_DOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__CRT_DOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_CRT_DOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_CRT_DOUBLE),
        "::",
        stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CRT_FLOAT {
    pub f: f32,
}
#[test]
fn bindgen_test_layout__CRT_FLOAT() {
    const UNINIT: ::std::mem::MaybeUninit<_CRT_FLOAT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Size of: ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Alignment of ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_CRT_FLOAT),
        "::",
        stringify!(f)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LONGDOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__LONGDOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_LONGDOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_LONGDOUBLE),
        "::",
        stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LDBL12 {
    pub ld12: [::std::os::raw::c_uchar; 12usize],
}
#[test]
fn bindgen_test_layout__LDBL12() {
    const UNINIT: ::std::mem::MaybeUninit<_LDBL12> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDBL12>(),
        12usize,
        concat!("Size of: ", stringify!(_LDBL12))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDBL12>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDBL12))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ld12) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_LDBL12),
        "::",
        stringify!(ld12)
        )
    );
}
/// \brief Enumeration type defining the action a calling function has to take after an MCD API function call.
///
///The calling function has to evaluate the return value of an MCD API function call
///in order to check its success. If the function returned with an error an appropriate
///action has to be taken as defined by the return value.
///All MCD API functions return a value of type \ref mcd_return_et. The calling function
///has to decide the further proceeding based on it.
///
///A few return codes have been reserved for future API use and must not be used. Any
///further value can be used for customized actions. All of these user defined actions
///need to have values between \c MCD_RET_ACT_CUSTOM_LO and \c MCD_RET_ACT_CUSTOM_HI.
pub type mcd_return_et = u32;
///< No special action required.
pub const MCD_RET_ACT_NONE: _bindgen_ty_1 = 0;
///< Try to call the function again.
pub const MCD_RET_ACT_AGAIN: _bindgen_ty_1 = 1;
///< Handle the event or events.
pub const MCD_RET_ACT_HANDLE_EVENT: _bindgen_ty_1 = 2;
///< Handle the error.
pub const MCD_RET_ACT_HANDLE_ERROR: _bindgen_ty_1 = 3;
///< Begin Range: Action reserved for future API use.
pub const MCD_RET_ACT_RESERVED_LO: _bindgen_ty_1 = 4;
///< End   Range: Action reserved for future API use.
pub const MCD_RET_ACT_RESERVED_HI: _bindgen_ty_1 = 32768;
///< Begin Range: For user defined actions.
pub const MCD_RET_ACT_CUSTOM_LO: _bindgen_ty_1 = 65536;
///< End   Range: For user defined actions.
pub const MCD_RET_ACT_CUSTOM_HI: _bindgen_ty_1 = 1073741824;
pub type _bindgen_ty_1 = ::std::os::raw::c_int;
/// \brief Enumeration type defining the detailed error codes that can be returned by an MCD API function call.
///
///The calling function has to evaluate the return value of an MCD API function call
///in order to check its success. If the function returned with an error an appropriate
///action has to be taken as defined by the return value.
///All MCD API functions return a value of type \ref mcd_return_et. If the returned value
///indicates an error, the user has to retrieve the detailed information on the occurred
///error by calling \ref mcd_qry_error_info_f(). The following enumeration is part of this
///information and describes the detailed error codes.
///
///The enumeration's values can be subdivided into the following categories:
///- GENERAL       (0x0000-0x0FFF)         : These errors can be returned by any MCD API function call.
///- API_SPECIFIC  (0x1000-0x10000000)     : These errors are specific to certain MCD API function calls.
///Some of them may be valid for multiple MCD API function calls.
///- CUSTOM        (0x10000000-0x7FFFFFFF) : These error codes can be defined by the user and carry user
///defined semantics.
pub type mcd_error_code_et = u32;
///< No error.
pub const MCD_ERR_NONE: _bindgen_ty_2 = 0;
///< Called function is not implemented.
pub const MCD_ERR_FN_UNIMPLEMENTED: _bindgen_ty_2 = 256;
///< MCD API not correctly used.
pub const MCD_ERR_USAGE: _bindgen_ty_2 = 257;
///< Passed invalid parameter.
pub const MCD_ERR_PARAM: _bindgen_ty_2 = 258;
///< Server connection error.
pub const MCD_ERR_CONNECTION: _bindgen_ty_2 = 512;
///< Function call timed out.
pub const MCD_ERR_TIMED_OUT: _bindgen_ty_2 = 513;
///< General error.
pub const MCD_ERR_GENERAL: _bindgen_ty_2 = 3840;
///< String to return is longer than the provided character array.
pub const MCD_ERR_RESULT_TOO_LONG: _bindgen_ty_2 = 4096;
///< Could not start server.
pub const MCD_ERR_COULD_NOT_START_SERVER: _bindgen_ty_2 = 4352;
///< Server is locked.
pub const MCD_ERR_SERVER_LOCKED: _bindgen_ty_2 = 4353;
///< No memory spaces defined.
pub const MCD_ERR_NO_MEM_SPACES: _bindgen_ty_2 = 5121;
///< No memory blocks defined for the requested memory space.
pub const MCD_ERR_NO_MEM_BLOCKS: _bindgen_ty_2 = 5122;
///< No memory space with requested ID exists.
pub const MCD_ERR_MEM_SPACE_ID: _bindgen_ty_2 = 5136;
///< No register groups defined.
pub const MCD_ERR_NO_REG_GROUPS: _bindgen_ty_2 = 5184;
///< No register group with requested ID exists.
pub const MCD_ERR_REG_GROUP_ID: _bindgen_ty_2 = 5185;
///< Register is not a compound register.
pub const MCD_ERR_REG_NOT_COMPOUND: _bindgen_ty_2 = 5186;
///< Error retrieving overlay information.
pub const MCD_ERR_OVERLAYS: _bindgen_ty_2 = 5376;
///< Cannot access device (power-down, reset active, etc.).
pub const MCD_ERR_DEVICE_ACCESS: _bindgen_ty_2 = 6400;
///< Device is locked.
pub const MCD_ERR_DEVICE_LOCKED: _bindgen_ty_2 = 6401;
///< Read transaction of transaction list has failed.
pub const MCD_ERR_TXLIST_READ: _bindgen_ty_2 = 8448;
///< Write transaction of transaction list has failed.
pub const MCD_ERR_TXLIST_WRITE: _bindgen_ty_2 = 8449;
///< Other error (no R/W failure) for a transaction of the
///transaction list.
pub const MCD_ERR_TXLIST_TX: _bindgen_ty_2 = 8450;
///< Requested channel type is not supported by the implementation.
pub const MCD_ERR_CHL_TYPE_NOT_SUPPORTED: _bindgen_ty_2 = 12544;
///< Addressed target does not support communication channels.
pub const MCD_ERR_CHL_TARGET_NOT_SUPPORTED: _bindgen_ty_2 = 12545;
///< Channel setup is invalid or contains unsupported attributes.
pub const MCD_ERR_CHL_SETUP: _bindgen_ty_2 = 12546;
///< Sending or receiving of the last message has failed.
pub const MCD_ERR_CHL_MESSAGE_FAILED: _bindgen_ty_2 = 12608;
///< Trigger could not be created.
pub const MCD_ERR_TRIG_CREATE: _bindgen_ty_2 = 12800;
///< Error during trigger information access.
pub const MCD_ERR_TRIG_ACCESS: _bindgen_ty_2 = 12801;
///< Begin Range: For user defined errors.
pub const MCD_ERR_CUSTOM_LO: _bindgen_ty_2 = 268435456;
///< End   Range: For user defined errors.
pub const MCD_ERR_CUSTOM_HI: _bindgen_ty_2 = 2147483647;
pub type _bindgen_ty_2 = ::std::os::raw::c_int;
/// \brief Enumeration type defining the error events that can be returned by an MCD API function call.
///
///The calling function has to evaluate the return value of an MCD API function call
///in order to check its success. If the function returned with an error an appropriate
///action has to be taken as defined by the return value.
///All MCD API functions return a value of type mcd_return_et. If the returned value
///indicates an event, the user has to retrieve the detailed information on the occurred
///error by calling \ref mcd_qry_error_info_f(). The following enumeration is part of this
///information and describes the detailed event codes.
///
///Event codes are bitwise exclusive. This allows 32 different event codes. User defined
///event codes need to have values between \c MCD_ERR_EVT_CUSTOM_LO and \c MCD_ERR_EVT_CUSTOM_HI.
///Reserved error event codes must not be used.
pub type mcd_error_event_et = u32;
///< No action required due to an event.
pub const MCD_ERR_EVT_NONE: _bindgen_ty_3 = 0;
///< Target has been reset.
pub const MCD_ERR_EVT_RESET: _bindgen_ty_3 = 1;
///< Target has been a powered down.
pub const MCD_ERR_EVT_PWRDN: _bindgen_ty_3 = 2;
///< There has been a target hardware failure.
pub const MCD_ERR_EVT_HWFAILURE: _bindgen_ty_3 = 4;
///< Begin Range: Events reserved for future API use.
pub const MCD_ERR_EVT_RESERVED_LO: _bindgen_ty_3 = 8;
///< End   Range: Events reserved for future API use.
pub const MCD_ERR_EVT_RESERVED_HI: _bindgen_ty_3 = 32768;
///< Begin Range: User defined events.
pub const MCD_ERR_EVT_CUSTOM_LO: _bindgen_ty_3 = 65536;
///< End   Range: User defined events.
pub const MCD_ERR_EVT_CUSTOM_HI: _bindgen_ty_3 = 1073741824;
pub type _bindgen_ty_3 = ::std::os::raw::c_int;
/// \brief Enumeration type defining the type of an address space ID.
///
///The type of the address space ID defines the interpretation of an address space ID.
///This type refers to the \c addr_space_id member of \c mcd_addr_st which is used to
///further extend the address information.
pub type mcd_addr_space_type_et = u32;
///< Address space ID is not used.
pub const MCD_NOTUSED_ID: _bindgen_ty_4 = 0;
///< Address space ID represents the memory overlay the address is valid in.
pub const MCD_OVERLAY_ID: _bindgen_ty_4 = 1;
///< Address space ID represents the memory bank the address is valid in.
pub const MCD_MEMBANK_ID: _bindgen_ty_4 = 2;
///< Address space ID represents the process the address is valid in.
pub const MCD_PROCESS_ID: _bindgen_ty_4 = 3;
///< Address space ID represents the hardware thread the address is valid in.
pub const MCD_HW_THREAD_ID: _bindgen_ty_4 = 4;
pub type _bindgen_ty_4 = ::std::os::raw::c_int;
/// \brief Enumeration type defining the type of a memory space.
///
///Different types of memory spaces are possible. This enumeration type describes
///them. The type values \c MCD_MEM_SPACE_IS_REGISTERS, \c MCD_MEM_SPACE_IS_PROGRAM,
///\c MCD_MEM_SPACE_IS_VIRTUAL and \c MCD_MEM_SPACE_IS_CACHE are bitwise mutually exclusive.
///\c MCD_MEM_SPACE_IS_PHYSICAL or \c MCD_MEM_SPACE_IS_LOGICAL should be set when the target contains a
///memory memagement unit (MMU) that translates memory addresses between core and memory.
///E.g. use (MCD_MEM_SPACE_IS_PROGRAM|MCD_MEM_SPACE_IS_LOGICAL) to identify an logical addresses of the program memory.
///User defined memory space types need to have values between \c MCD_MEMSPACE_CUSTOM_HI and \c MCD_MEMSPACE_CUSTOM_HI.
///Reserved memory space types must not be used.
pub type mcd_mem_type_et = u32;
///< The memory space is of none of the types below.
pub const MCD_MEM_SPACE_DEFAULT: _bindgen_ty_5 = 0;
///< The memory space contains only registers.
pub const MCD_MEM_SPACE_IS_REGISTERS: _bindgen_ty_5 = 1;
///< The memory space is a program memory.
pub const MCD_MEM_SPACE_IS_PROGRAM: _bindgen_ty_5 = 2;
///< The memory space is virtual (resource not existing in target).
pub const MCD_MEM_SPACE_IS_VIRTUAL: _bindgen_ty_5 = 4;
///< The memory space is a cache.
pub const MCD_MEM_SPACE_IS_CACHE: _bindgen_ty_5 = 8;
///< The memory space is physical memory (not translated by MMU)
pub const MCD_MEM_SPACE_IS_PHYSICAL: _bindgen_ty_5 = 16;
///< The memory space is logical memory (translated by MMU)
pub const MCD_MEM_SPACE_IS_LOGICAL: _bindgen_ty_5 = 32;
///< Begin Range: Reserved for future API use.
pub const MCD_MEM_SPACE_RESERVED_LO: _bindgen_ty_5 = 64;
///< End   Range: Reserved for future API use.
pub const MCD_MEM_SPACE_RESERVED_HI: _bindgen_ty_5 = 32768;
///< Begin Range: User defined memory types.
pub const MCD_MEM_SPACE_CUSTOM_LO: _bindgen_ty_5 = 65536;
///< End   Range: User defined memory types.
pub const MCD_MEM_SPACE_CUSTOM_HI: _bindgen_ty_5 = 1073741824;
pub type _bindgen_ty_5 = ::std::os::raw::c_int;
/// \brief Enumeration type defining the endianness of a memory space or a memory block.
///
///The endianness of a memory can be either Little Endian or Big Endian. This enumeration
///type describes the two possible values of endianness and is used to set the corresponding
///property of a memory space and a memory block description. If memory blocks are
///supported, the value of a memory block overrides the one for the memory space it is
///part of.
pub type mcd_endian_et = u32;
///< Endianness as defined by the target architecture
///or parent module (if available).
pub const MCD_ENDIAN_DEFAULT: _bindgen_ty_6 = 0;
///< Little Endian data representation.
pub const MCD_ENDIAN_LITTLE: _bindgen_ty_6 = 1;
///< Big Endian data representation.
pub const MCD_ENDIAN_BIG: _bindgen_ty_6 = 2;
pub type _bindgen_ty_6 = ::std::os::raw::c_int;
/// \brief Enumeration type defining the allowed register types.
///
///A register can be a simple register, a compound register or a partial register.
///This enumeration type describes the three register types.
pub type mcd_reg_type_et = u32;
///< Simple register.
pub const MCD_REG_TYPE_SIMPLE: _bindgen_ty_7 = 0;
///< Compound register composed more than one simple register.
pub const MCD_REG_TYPE_COMPOUND: _bindgen_ty_7 = 1;
///< Register that is part of a simple register.
pub const MCD_REG_TYPE_PARTIAL: _bindgen_ty_7 = 2;
pub type _bindgen_ty_7 = ::std::os::raw::c_int;
/// \brief Enumeration type defining the type of a trigger.
///
///This enumeration type describes the possible types of triggers for the
///target. The type values are bitwise mutually exclusive and a member of
///type \ref mcd_trig_type_et may be a combination of several of them.
///The type \c MCD_TRIG_TYPE_CUSTOM refers to a custom trigger (not a custom trigger
///type) using the standard format as defined by \ref mcd_trig_custom_st. User defined
///trigger types need to have values between \c MCD_TRIG_TYPE_CUSTOM_LO and
///\c MCD_TRIG_TYPE_CUSTOM_HI.
pub type mcd_trig_type_et = u32;
///< Undefined trigger type.
pub const MCD_TRIG_TYPE_UNDEFINED: _bindgen_ty_8 = 0;
///< Trigger on a changing instruction pointer.
pub const MCD_TRIG_TYPE_IP: _bindgen_ty_8 = 1;
///< Trigger on a read data access to a specific address or address range.
pub const MCD_TRIG_TYPE_READ: _bindgen_ty_8 = 2;
///< Trigger on a write data access to a specific address or address range.
pub const MCD_TRIG_TYPE_WRITE: _bindgen_ty_8 = 4;
///< Trigger on a read or a write data access to a specific address or
///address range.
pub const MCD_TRIG_TYPE_RW: _bindgen_ty_8 = 8;
///< Trigger on core information other than an IP or data compare trigger.
pub const MCD_TRIG_TYPE_NOCYCLE: _bindgen_ty_8 = 16;
///< Trigger on a trigger bus combination.
pub const MCD_TRIG_TYPE_TRIG_BUS: _bindgen_ty_8 = 32;
///< Trigger on an elapsed trigger counter.
pub const MCD_TRIG_TYPE_COUNTER: _bindgen_ty_8 = 64;
///< Custom trigger using standard format as defined by \ref mcd_trig_custom_st.
pub const MCD_TRIG_TYPE_CUSTOM: _bindgen_ty_8 = 128;
///< Begin Range: User defined trigger types.
pub const MCD_TRIG_TYPE_CUSTOM_LO: _bindgen_ty_8 = 65536;
///< End   Range: User defined trigger types.
pub const MCD_TRIG_TYPE_CUSTOM_HI: _bindgen_ty_8 = 1073741824;
pub type _bindgen_ty_8 = ::std::os::raw::c_int;
/// \brief Enumeration type defining additional options for a trigger.
///
///This enumeration type describes the additionally possible options for
///triggers in a target. The type values are bitwise mutually exclusive
///and a member of type \ref mcd_trig_opt_et may be a combination of several
///of them. User defined trigger options need to have values between
///\c MCD_TRIG_OPT_CUSTOM_LO and \c MCD_TRIG_OPT_CUSTOM_HI.
pub type mcd_trig_opt_et = u32;
///< Default trigger options, e.g. chosen by the platform.
pub const MCD_TRIG_OPT_DEFAULT: _bindgen_ty_9 = 0;
///< The trigger shall be implemented by hardware.
pub const MCD_TRIG_OPT_IMPL_HARDWARE: _bindgen_ty_9 = 1;
///< The trigger shall be implemented by software (code substitution).
pub const MCD_TRIG_OPT_IMPL_SOFTWARE: _bindgen_ty_9 = 2;
///< The trigger is activated when a data access is performed outside
///the specified range.
pub const MCD_TRIG_OPT_OUT_OF_RANGE: _bindgen_ty_9 = 4;
///< The value of a data access is part of the trigger condition.
pub const MCD_TRIG_OPT_DATA_IS_CONDITION: _bindgen_ty_9 = 8;
///< The size of a data access is part of the trigger condition.
pub const MCD_TRIG_OPT_DATASIZE_IS_CONDITION: _bindgen_ty_9 = 16;
///< The data comparison done in a trigger condition is negated.
pub const MCD_TRIG_OPT_NOT_DATA: _bindgen_ty_9 = 32;
///< The data values are considered as signed for the trigger
///condition. This usually requires the setting of
///\c MCD_TRIG_OPT_DATASIZE_IS_CONDITION.
pub const MCD_TRIG_OPT_SIGNED_DATA: _bindgen_ty_9 = 64;
///< The hardware thread ID is part of the trigger condition.
pub const MCD_TRIG_OPT_HW_THREAD_IS_CONDITION: _bindgen_ty_9 = 128;
///< The comparison of the hardware thread ID is negated.
pub const MCD_TRIG_OPT_NOT_HW_THREAD: _bindgen_ty_9 = 256;
///< The software thread ID is part of the trigger condition.
pub const MCD_TRIG_OPT_SW_THREAD_IS_CONDITION: _bindgen_ty_9 = 512;
///< The comparison of the software thread ID is negated.
pub const MCD_TRIG_OPT_NOT_SW_THREAD: _bindgen_ty_9 = 1024;
///< The data value of the cycle must change the value of the target location.
///This applies only to triggers on write cycles.
///The \c data_mask field defines which bits are considered for the comparison.
pub const MCD_TRIG_OPT_DATA_MUST_CHANGE: _bindgen_ty_9 = 2048;
///< The core mode as defined by the member \c core_mode_mask of a
///\ref mcd_trig_complex_core_st is part of the trigger condition.
///Each set bit prevents the related core mode from activating
///the trigger.
pub const MCD_TRIG_OPT_CORE_MODE_IS_CONDITION: _bindgen_ty_9 = 131072;
///< The state of the trigger set's state machine is part of the trigger
///condition.
pub const MCD_TRIG_OPT_STATE_IS_CONDITION: _bindgen_ty_9 = 262144;
///< The trigger condition is negated, i.e. action is taken if the
///whole trigger condition is NOT met. This should not be mixed up with
///\c MCD_TRIG_OPT_OUT_OF_RANGE which inverts just the address range.
pub const MCD_TRIG_OPT_NOT: _bindgen_ty_9 = 524288;
///< Begin Range: User defined trigger options.
pub const MCD_TRIG_OPT_CUSTOM_LO: _bindgen_ty_9 = 1048576;
///< End   Range: User defined trigger options.
pub const MCD_TRIG_OPT_CUSTOM_HI: _bindgen_ty_9 = 1073741824;
pub type _bindgen_ty_9 = ::std::os::raw::c_int;
/// \brief Enumeration type defining the trigger action types.
///
///This enumeration type describes the possible actions for triggers
///in a target. The type values are bitwise mutually exclusive and
///a member of type \c mcd_trig_action_et may be a combination of
///several of them. User defined trigger actions need to have values
///between \c MCD_TRIG_ACTION_CUSTOM_LO and \c MCD_TRIG_ACTION_CUSTOM_HI.
pub type mcd_trig_action_et = u32;
///< No action has to be taken except from setting the
///trigger to be captured.
pub const MCD_TRIG_ACTION_DEFAULT: _bindgen_ty_10 = 0;
///< Stop this core and bring it into debug mode.
pub const MCD_TRIG_ACTION_DBG_DEBUG: _bindgen_ty_10 = 1;
///< Stop all cores and bring them into debug mode.
pub const MCD_TRIG_ACTION_DBG_GLOBAL: _bindgen_ty_10 = 2;
///< Issue an exception (monitor interrupt) on this core
///in order to execute the monitor code.
pub const MCD_TRIG_ACTION_DBG_MONITOR: _bindgen_ty_10 = 4;
///< Signal the according event on the trigger bus (for
///the duration of one core cycle). The corresponding
///bitmask is specified by the member \c action_param
///of the used trigger data structure.
pub const MCD_TRIG_ACTION_TRIG_BUS_EVENT: _bindgen_ty_10 = 16;
///< Set bits on the trigger bus. The corresponding bitmask
///is specified by the member \c action_param of the used
///trigger data structure.
pub const MCD_TRIG_ACTION_TRIG_BUS_SET: _bindgen_ty_10 = 32;
///< Clear bits on the trigger bus. The corresponding bitmask
///is specified by the member \c action_param of the used
///trigger data structure.
pub const MCD_TRIG_ACTION_TRIG_BUS_CLEAR: _bindgen_ty_10 = 64;
///< Trace this cycle.
pub const MCD_TRIG_ACTION_TRACE_QUALIFY: _bindgen_ty_10 = 256;
///< Trace this cycle, affects program trace only.
pub const MCD_TRIG_ACTION_TRACE_QUALIFY_PROGRAM: _bindgen_ty_10 = 512;
///< Trace this cycle, affects data trace only.
pub const MCD_TRIG_ACTION_TRACE_QUALIFY_DATA: _bindgen_ty_10 = 1024;
///< Start tracing.
pub const MCD_TRIG_ACTION_TRACE_START: _bindgen_ty_10 = 2048;
///< Stop tracing.
pub const MCD_TRIG_ACTION_TRACE_STOP: _bindgen_ty_10 = 4096;
///< Trigger trace unit.
pub const MCD_TRIG_ACTION_TRACE_TRIGGER: _bindgen_ty_10 = 8192;
///< Start performance analysis or profiling.
pub const MCD_TRIG_ACTION_ANA_START_PERFM: _bindgen_ty_10 = 65536;
///< Stop performance analysis or profiling.
pub const MCD_TRIG_ACTION_ANA_STOP_PERFM: _bindgen_ty_10 = 131072;
///< Set the trigger set's state machine to a new state. The
///corresponding state is specified by the member
///\c action_param of the used trigger data structure.
pub const MCD_TRIG_ACTION_STATE_CHANGE: _bindgen_ty_10 = 262144;
///< Increment the counter specified by the member
///\c action_param of the used trigger data structure.
pub const MCD_TRIG_ACTION_COUNT_QUALIFY: _bindgen_ty_10 = 524288;
///< Start the counter specified by the member \c action_param
///of the used trigger data structure.
pub const MCD_TRIG_ACTION_COUNT_START: _bindgen_ty_10 = 1048576;
///< Stop the counter specified by the member \c action_param
///of the used trigger data structure.
pub const MCD_TRIG_ACTION_COUNT_STOP: _bindgen_ty_10 = 2097152;
///< Restart the counter specified by the member \c action_param
///of the used trigger data structure.
pub const MCD_TRIG_ACTION_COUNT_RESTART: _bindgen_ty_10 = 4194304;
///< Begin Range: User defined trigger actions.
pub const MCD_TRIG_ACTION_CUSTOM_LO: _bindgen_ty_10 = 16777216;
///< End   Range: User defined trigger actions.
pub const MCD_TRIG_ACTION_CUSTOM_HI: _bindgen_ty_10 = 1073741824;
pub type _bindgen_ty_10 = ::std::os::raw::c_int;
/// \brief Enumeration type defining access types for transactions of transaction lists.
///
///This enumeration type describes the four possible access types for transactions
///of a transaction list.
pub type mcd_tx_access_type_et = u32;
///< Read access transaction.
pub const MCD_TX_AT_R: _bindgen_ty_11 = 1;
///< Write access transaction.
pub const MCD_TX_AT_W: _bindgen_ty_11 = 2;
///< Read then write access transaction (atomic swap).
pub const MCD_TX_AT_RW: _bindgen_ty_11 = 3;
///< Write then read access transaction (write and verify).
pub const MCD_TX_AT_WR: _bindgen_ty_11 = 4;
pub type _bindgen_ty_11 = ::std::os::raw::c_int;
/// \brief Enumeration type defining access options for transactions of transaction lists.
///
///This enumeration type describes the possible access options for transactions of a
///transaction list. The type values are bitwise mutually exclusive and a member of
///type \c mcd_tx_access_opt_et may be a combination of several of them. User defined
///access options need to have values between \c MCD_TX_OPT_CUSTOM_LO and
///\c MCD_TX_OPT_CUSTOM_HI. Reserved access options must not be used.
///
///Marking the last transaction of a transaction list with \c MCD_TX_OPT_ATOMIC_WITH_NEXT
///causes it to be atomic with the first transaction of the next list to be executed
///for this core connection.
pub type mcd_tx_access_opt_et = u32;
///< MCD implementation decides on applied access options.
pub const MCD_TX_OPT_DEFAULT: _bindgen_ty_12 = 0;
///< Trigger side effects for the access.
pub const MCD_TX_OPT_SIDE_EFFECTS: _bindgen_ty_12 = 1;
///< Omit side effects for the access.
pub const MCD_TX_OPT_NO_SIDE_EFFECTS: _bindgen_ty_12 = 2;
///< Perform burst accesses if possible.
pub const MCD_TX_OPT_BURST_ACCESSES: _bindgen_ty_12 = 4;
///< Avoid burst accesses if possible.
pub const MCD_TX_OPT_NO_BURST_ACCESSES: _bindgen_ty_12 = 8;
///< Dual port or DAP memory access.
pub const MCD_TX_OPT_ALTERNATE_PATH: _bindgen_ty_12 = 16;
///< High priority access.
pub const MCD_TX_OPT_PRIORITY_ACCESS: _bindgen_ty_12 = 32;
///< Force D-cache and unified caches to be write-through.
pub const MCD_TX_OPT_DCACHE_WRITE_THRU: _bindgen_ty_12 = 64;
///< Bypass caches and read/write directly to the memory.
pub const MCD_TX_OPT_CACHE_BYPASS: _bindgen_ty_12 = 128;
///< Do not increment address after each cycle. Useful for
///reading or writing to FIFOs.
pub const MCD_TX_OPT_NOINCREMENT: _bindgen_ty_12 = 256;
///< Transaction is executed atomic with the next one.
pub const MCD_TX_OPT_ATOMIC_WITH_NEXT: _bindgen_ty_12 = 512;
///< Memory is accessed in user mode (instead of
///supervisor mode) Only set this bit in mcd_memblock_st
///or mcd_memspace_st, if the memory can be accessed in
///both supervisor and user mode.
pub const MCD_TX_OPT_USERMODE: _bindgen_ty_12 = 1024;
///< Begin Range: Reserved for future API use.
pub const MCD_TX_OPT_RESERVED_LO: _bindgen_ty_12 = 2048;
///< End   Range: Reserved for future API use.
pub const MCD_TX_OPT_RESERVED_HI: _bindgen_ty_12 = 32768;
///< Begin Range: User defined access options.
pub const MCD_TX_OPT_CUSTOM_LO: _bindgen_ty_12 = 65536;
///< End   Range: User defined access options.
pub const MCD_TX_OPT_CUSTOM_HI: _bindgen_ty_12 = 1073741824;
pub type _bindgen_ty_12 = ::std::os::raw::c_int;
/// \brief Enumeration type defining step types for a target core.
///
///This enumeration type describes the possible step types for a target core. The
///step type depends on the core type. A programmable core can be for example
///stepped in terms of cycles or instructions.
///User defined step types need to have values between \c MCD_CORE_STEP_TYPE_CUSTOM_LO
///and \c MCD_CORE_STEP_TYPE_CUSTOM_HI. They for example can be based on specifications
///provided by the IP developer of a core.
///The step type values \c MCD_CORE_STEP_TYPE_RESERVED_LO to \c MCD_CORE_STEP_TYPE_RESERVED_HI
///are reserved for future API extensions and must not be used.
pub type mcd_core_step_type_et = u32;
///< Step the core for core specific cycles.
pub const MCD_CORE_STEP_TYPE_CYCLES: _bindgen_ty_13 = 1;
///< Step the core for core specific instructions.
pub const MCD_CORE_STEP_TYPE_INSTR: _bindgen_ty_13 = 2;
///< Begin Range: Reserved for future API use.
pub const MCD_CORE_STEP_TYPE_RESERVED_LO: _bindgen_ty_13 = 4;
///< End   Range: Reserved for future API use.
pub const MCD_CORE_STEP_TYPE_RESERVED_HI: _bindgen_ty_13 = 255;
///< Begin Range: User defined step types.
pub const MCD_CORE_STEP_TYPE_CUSTOM_LO: _bindgen_ty_13 = 256;
///< End   Range: User defined step types.
pub const MCD_CORE_STEP_TYPE_CUSTOM_HI: _bindgen_ty_13 = 3840;
///< Maximum number of supported step types.
pub const MCD_CORE_STEP_TYPE_MAX_TYPES: _bindgen_ty_13 = 2147483647;
pub type _bindgen_ty_13 = ::std::os::raw::c_int;
/// \brief Enumeration type defining the execution states of a target core.
///
///This enumeration type describes the possible execution states of a target core from
///a debugger perspective. The HALTED state is defined to differ from the DEBUG state
///by the fact that a core in debug mode is under debugger control. In contrast to this
///a core in HALTED state is not under the execution control of the debugger but in a
///state from which the debugger can only push it to DEBUG state. The same applies to
///the RUNNING state.
///User defined core states need to have values between \c MCD_CORE_STATE_CUSTOM_LO
///and \c MCD_CORE_STATE_CUSTOM_HI.
pub type mcd_core_state_et = u32;
///< Target core state is unknown.
pub const MCD_CORE_STATE_UNKNOWN: _bindgen_ty_14 = 0;
///< Target core is running.
pub const MCD_CORE_STATE_RUNNING: _bindgen_ty_14 = 1;
///< Target core is halted.
pub const MCD_CORE_STATE_HALTED: _bindgen_ty_14 = 2;
///< Target core is in debug mode.
pub const MCD_CORE_STATE_DEBUG: _bindgen_ty_14 = 3;
///< Begin Range: User defined core states.
pub const MCD_CORE_STATE_CUSTOM_LO: _bindgen_ty_14 = 256;
///< End   Range: User defined core states.
pub const MCD_CORE_STATE_CUSTOM_HI: _bindgen_ty_14 = 2048;
///< Maximum number of supported core states.
pub const MCD_CORE_STATE_MAX_STATES: _bindgen_ty_14 = 2147483647;
pub type _bindgen_ty_14 = ::std::os::raw::c_int;
/// \brief Enumeration type defining the possible events for a target core.
///
///This enumeration type describes the possible core events for a target core
///from a debugger perspective. These allow to optimize the polling of specific
///target information and to support multiple clients connected to one target
///core. Some core events may be reported just once.
///User defined core events need to have values between \c MCD_CORE_EVENT_CUSTOM_LO
///and \c MCD_CORE_EVENT_CUSTOM_HI.
pub type mcd_core_event_et = u32;
///< No since the last poll.
pub const MCD_CORE_EVENT_NONE: _bindgen_ty_15 = 0;
///< Memory content has changed.
pub const MCD_CORE_EVENT_MEMORY_CHANGE: _bindgen_ty_15 = 1;
///< Register contents have changed.
pub const MCD_CORE_EVENT_REGISTER_CHANGE: _bindgen_ty_15 = 2;
///< Trace contents or states have changed.
pub const MCD_CORE_EVENT_TRACE_CHANGE: _bindgen_ty_15 = 4;
///< Triggers or trigger states have changed.
pub const MCD_CORE_EVENT_TRIGGER_CHANGE: _bindgen_ty_15 = 8;
///< Target was stopped at least once since the last poll,
///it may already be running again.
pub const MCD_CORE_EVENT_STOPPED: _bindgen_ty_15 = 16;
///< A target communication channel request from the target
///is pending.
pub const MCD_CORE_EVENT_CHL_PENDING: _bindgen_ty_15 = 32;
///< Begin Range: User defined core events.
pub const MCD_CORE_EVENT_CUSTOM_LO: _bindgen_ty_15 = 65536;
///< End   Range: User defined core events.
pub const MCD_CORE_EVENT_CUSTOM_HI: _bindgen_ty_15 = 1073741824;
pub type _bindgen_ty_15 = ::std::os::raw::c_int;
/// \brief Enumeration type defining the communication channel types.
///
///There can be different types of communication channels between a host side
///tool and the target. This enumeration desribes these possible types of
///communication channels. User defined communication channel types need to
///have values between \c MCD_CHL_TYPE_CUSTOM_LO and \c MCD_CHL_TYPE_CUSTOM_HI.
pub type mcd_chl_type_et = u32;
///<Common communication channel to the target.
pub const MCD_CHL_TYPE_COMMON: _bindgen_ty_16 = 1;
///<Communication channel for configuration purposes,
///e.g. to configure the analysis setup.
pub const MCD_CHL_TYPE_CONFIG: _bindgen_ty_16 = 2;
///<Communication channel to an application running
///on the target, e.g. for semi-hosting purposes.
pub const MCD_CHL_TYPE_APPLI: _bindgen_ty_16 = 3;
///<Begin Range: User defined communication channel types.
pub const MCD_CHL_TYPE_CUSTOM_LO: _bindgen_ty_16 = 256;
///<End   Range: User defined communication channel types.
pub const MCD_CHL_TYPE_CUSTOM_HI: _bindgen_ty_16 = 3840;
pub type _bindgen_ty_16 = ::std::os::raw::c_int;
/// \brief Enumeration type defining communication channel attributes.
///
///A communication channel can be defined with several attributes concerning
///the channel's direction, accessibility and priority. This enumeration
///type describes them. The type values are bitwise mutually exclusive and
///a member of type \ref mcd_chl_attributes_et may be a combination of several
///of them.
pub type mcd_chl_attributes_et = u32;
///< Receive channel.
pub const MCD_CHL_AT_RCV: _bindgen_ty_17 = 1;
///< Send channel.
pub const MCD_CHL_AT_SND: _bindgen_ty_17 = 2;
///< Channel is memory mapped.
pub const MCD_CHL_AT_MEM_MAPPED: _bindgen_ty_17 = 64;
///< Channel has a defined priority.
pub const MCD_CHL_AT_HAS_PRIO: _bindgen_ty_17 = 2048;
pub type _bindgen_ty_17 = ::std::os::raw::c_int;
/// \brief Enumeration type defining basic trace types.
///
///This enumeration type describes the type of a trace source. The
///type values are bitwise mutually exclusive. User defined trace
///types need to have values between \c MCD_TRACE_TYPE_CUSTOM_LO
///and \c MCD_TRACE_TYPE_CUSTOM_HI.
pub type mcd_trace_type_et = u32;
///< Unknown trace source.
pub const MCD_TRACE_TYPE_UNKNOWN: _bindgen_ty_18 = 0;
///< Traces the instruction and (optional)
///data trace stream as seen from the core.
pub const MCD_TRACE_TYPE_CORE: _bindgen_ty_18 = 1;
///< Traces a bus that is not related to the
///program flow.
pub const MCD_TRACE_TYPE_BUS: _bindgen_ty_18 = 2;
///< Traces logical signals (can include buses)
///that have an asynchronous nature.
pub const MCD_TRACE_TYPE_EVENT: _bindgen_ty_18 = 4;
///< Traces statistical or profiling information.
pub const MCD_TRACE_TYPE_STAT: _bindgen_ty_18 = 8;
///< Begin Range: User defined trace types.
pub const MCD_TRACE_TYPE_CUSTOM_LO: _bindgen_ty_18 = 256;
///< End   Range: User defined trace types.
pub const MCD_TRACE_TYPE_CUSTOM_HI: _bindgen_ty_18 = 1073741824;
pub type _bindgen_ty_18 = ::std::os::raw::c_int;
/// \brief Enumeration type defining trace data formats.
///
///This enumeration type describes the format of the trace data. Each
///trace source can deliver data in exactly one format, only. Standard
///formats should be used whenever possible. User defined trace types
///need to have values between \c MCD_TRACE_FORMAT_CUSTOM_LO and
///\c MCD_TRACE_FORMAT_CUSTOM_HI.
pub type mcd_trace_format_et = u32;
///< Trace data format not readable via API.
pub const MCD_TRACE_FORMAT_UNKNOWN: _bindgen_ty_19 = 0;
///< Execution trace extracted from bus fetch cycles
///(use struct \ref mcd_trace_data_core_st for this format).
pub const MCD_TRACE_FORMAT_CORE_FETCH: _bindgen_ty_19 = 1;
///< Execution trace
///(use struct \ref mcd_trace_data_core_st for this format).
pub const MCD_TRACE_FORMAT_CORE_EXECUTE: _bindgen_ty_19 = 2;
///< Flowtrace data format similar to NEXUS traces, instruction count
///(use struct \ref mcd_trace_data_core_st for this format).
pub const MCD_TRACE_FORMAT_CORE_FLOW_ICOUNT: _bindgen_ty_19 = 3;
///< Flowtrace data format similar to NEXUS traces, bytes count
///(use struct \ref mcd_trace_data_core_st for this format).
pub const MCD_TRACE_FORMAT_CORE_FLOW_BCOUNT: _bindgen_ty_19 = 4;
///< Flowtrace data format with predicates and instruction count
///(use struct \ref mcd_trace_data_core_st for this format).
pub const MCD_TRACE_FORMAT_CORE_FLOW_IPREDICATE: _bindgen_ty_19 = 5;
///< Logic and system event trace
///(use struct \ref mcd_trace_data_event_st for this format).
pub const MCD_TRACE_FORMAT_EVENT: _bindgen_ty_19 = 16;
///< Statistics trace
///(use struct \ref mcd_trace_data_stat_st for this format).
pub const MCD_TRACE_FORMAT_STAT: _bindgen_ty_19 = 32;
///< Begin Range: User defined trace data formats.
pub const MCD_TRACE_FORMAT_CUSTOM_LO: _bindgen_ty_19 = 256;
///< End   Range: User defined trace data formats.
pub const MCD_TRACE_FORMAT_CUSTOM_HI: _bindgen_ty_19 = 2147483647;
pub type _bindgen_ty_19 = ::std::os::raw::c_int;
/// \brief Enumeration type defining operation modes of a trace buffer.
///
///This enumeration type describes the possible operation modes of a
///trace buffer. The type values are bitwise mutually exclusive. User
///defined operation modes need to have values between
///\c MCD_TRACE_MODE_CUSTOM_LO and \c MCD_TRACE_MODE_CUSTOM_HI.
pub type mcd_trace_mode_et = u32;
///< Do not change trace buffer mode.
pub const MCD_TRACE_MODE_NOCHANGE: _bindgen_ty_20 = 0;
///< Circular trace buffer.
pub const MCD_TRACE_MODE_FIFO: _bindgen_ty_20 = 1;
///< Trace stops when buffer is full.
pub const MCD_TRACE_MODE_STACK: _bindgen_ty_20 = 2;
///< Target is stopped (brought into debug state)
///when buffer is almost full.
pub const MCD_TRACE_MODE_LEACH: _bindgen_ty_20 = 4;
///< Trace data are continuously streamed through
///API, buffer is a FIFO for temporary storage.
pub const MCD_TRACE_MODE_PIPE: _bindgen_ty_20 = 8;
///< Begin Range: User defined operation modes.
pub const MCD_TRACE_MODE_CUSTOM_LO: _bindgen_ty_20 = 256;
///< End   Range: User defined operation modes.
pub const MCD_TRACE_MODE_CUSTOM_HI: _bindgen_ty_20 = 1073741824;
pub type _bindgen_ty_20 = ::std::os::raw::c_int;
/// \brief Enumeration type defining trace states.
///
///This enumeration type describes the possible states of a trace.
///User defined trace states need to have values between
///\c MCD_TRACE_STATE_CUSTOM_LO and \c MCD_TRACE_STATE_CUSTOM_HI.
pub type mcd_trace_state_et = u32;
///< Do not change state (only for \ref mcd_set_trace_state_f()).
pub const MCD_TRACE_STATE_NOCHANGE: _bindgen_ty_21 = 0;
///< Trace is disabled and no resources are allocated.
pub const MCD_TRACE_STATE_DISABLE: _bindgen_ty_21 = 1;
///< Trace is off and does not trace data, but is ready for tracing.
pub const MCD_TRACE_STATE_OFF: _bindgen_ty_21 = 2;
///< Trace is armed.
pub const MCD_TRACE_STATE_ARM: _bindgen_ty_21 = 3;
///< Trace is triggered and waits for the post trigger delay.
pub const MCD_TRACE_STATE_TRIGGER: _bindgen_ty_21 = 4;
///< Trace has stopped (after trigger and post trigger delay have elapsed).
pub const MCD_TRACE_STATE_STOP: _bindgen_ty_21 = 5;
///< Clears trace buffer and goes into OFF state (only for \ref mcd_set_trace_state_f()).
pub const MCD_TRACE_STATE_INIT: _bindgen_ty_21 = 16;
///< Begin Range: User defined trace states.
pub const MCD_TRACE_STATE_CUSTOM_LO: _bindgen_ty_21 = 256;
///< End   Range: User defined trace states.
pub const MCD_TRACE_STATE_CUSTOM_HI: _bindgen_ty_21 = 2147483647;
pub type _bindgen_ty_21 = ::std::os::raw::c_int;
/// \brief Enumeration type defining trace markers.
///
///This enumeration type describes markers associated with a single
///trace frame. The type values are bitwise mutually exclusive and
///a member of type \ref mcd_trace_marker_et may be a combination of
///several of them. User defined trace markers need to have values
///between \c MCD_TRACE_MARKER_CUSTOM_LO and \c MCD_TRACE_MARKER_CUSTOM_HI.
pub type mcd_trace_marker_et = u32;
///< No marker set.
pub const MCD_TRACE_MARKER_NONE: _bindgen_ty_22 = 0;
///< Core has started execution in this trace frame (first cycle).
pub const MCD_TRACE_MARKER_RUN: _bindgen_ty_22 = 1;
///< Core has stopped execution in this trace frame (last cycle).
pub const MCD_TRACE_MARKER_DEBUG: _bindgen_ty_22 = 2;
///< Tracing has started in this trace frame (controlled by trigger).
pub const MCD_TRACE_MARKER_START: _bindgen_ty_22 = 4;
///< Tracing has stopped in this trace frame (controlled by trigger).
pub const MCD_TRACE_MARKER_STOP: _bindgen_ty_22 = 8;
///< Error marker (hardware failure or program flow reconstruction error).
pub const MCD_TRACE_MARKER_ERROR: _bindgen_ty_22 = 16;
///< Gap in trace (caused by bandwidth limitation on trace port).
pub const MCD_TRACE_MARKER_GAP: _bindgen_ty_22 = 32;
///< Begin Range: User defined trace markers.
pub const MCD_TRACE_MARKER_CUSTOM_LO: _bindgen_ty_22 = 256;
///< End   Range: User defined trace markers.
pub const MCD_TRACE_MARKER_CUSTOM_HI: _bindgen_ty_22 = 1073741824;
pub type _bindgen_ty_22 = ::std::os::raw::c_int;
/// \brief Enumeration type defining basic trace cycles.
///
///This enumeration type describes the basic trace cycle types for bus
///and core traces. User defined trace cycle types need to have values
///between \c MCD_TRACE_CYCLE_CUSTOM_LO and \c MCD_TRACE_CYCLE_CUSTOM_HI.
pub type mcd_trace_cycle_et = u32;
///< Trave cycle contains no valid data for this core.
pub const MCD_TRACE_CYCLE_UNKNOWN: _bindgen_ty_23 = 0;
///< No trace cycle, control information (marker, timestamp) is valid.
pub const MCD_TRACE_CYCLE_NONE: _bindgen_ty_23 = 1;
///< Program execution cycle, marks the execution of one instruction.
///For a program flow trace this marks the execution of a block
///which is ended with a taken branch.
pub const MCD_TRACE_CYCLE_EXECUTE: _bindgen_ty_23 = 2;
///< Program execution cycle, marks the execution of one conditional
///instruction with a "failing" condition code. For a program flow
///trace this marks the execution of a block which is ended without
///a branch.
pub const MCD_TRACE_CYCLE_NOTEXECUTE: _bindgen_ty_23 = 3;
///< Program fetch cycle, the instruction related to the cycle may
///just be prefetched.
pub const MCD_TRACE_CYCLE_FETCH: _bindgen_ty_23 = 4;
///< Data read cycle.
pub const MCD_TRACE_CYCLE_READ: _bindgen_ty_23 = 5;
///< Data write cycle.
pub const MCD_TRACE_CYCLE_WRITE: _bindgen_ty_23 = 6;
///< Ownership change cycle, usually indicates a change of the executed
///software thread.
pub const MCD_TRACE_CYCLE_OWNERSHIP: _bindgen_ty_23 = 7;
///< Begin Range: User defined trace cycles.
pub const MCD_TRACE_CYCLE_CUSTOM_LO: _bindgen_ty_23 = 256;
///< End   Range: User defined trace cycles.
pub const MCD_TRACE_CYCLE_CUSTOM_HI: _bindgen_ty_23 = 2147483647;
pub type _bindgen_ty_23 = ::std::os::raw::c_int;
/// \brief Structure type containing the MCD API version information of the tool.
///
///This structure type contains version information about the MCD API implementation
///of the tool.
///Reference version at end of SPRINT project is:
///-  v_api_major = 1
///-  v_api_minor = 0
///-  author = "SPRINT Release"
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcd_api_version_st {
    ///< API major version.
    pub v_api_major: u16,
    ///< API minor version.
    pub v_api_minor: u16,
    ///< API name of the author of this MCD API version
    pub author: [mcd_char_t; 32usize],
}
#[test]
fn bindgen_test_layout_mcd_api_version_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_api_version_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_api_version_st>(),
        36usize,
        concat!("Size of: ", stringify!(mcd_api_version_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_api_version_st>(),
        2usize,
        concat!("Alignment of ", stringify!(mcd_api_version_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_api_major) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_api_version_st),
        "::",
        stringify!(v_api_major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_api_minor) as usize - ptr as usize },
        2usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_api_version_st),
        "::",
        stringify!(v_api_minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).author) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_api_version_st),
        "::",
        stringify!(author)
        )
    );
}
/// \brief Structure type containing the MCD API implementation information.
///
///This structure type contains important information about the particular implementation
///of the MCD API.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcd_impl_version_info_st {
    ///< Implemented API version.
    pub v_api: mcd_api_version_st,
    ///< Major version number of this implementation.
    pub v_imp_major: u16,
    ///< Minor version number of this implementation.
    pub v_imp_minor: u16,
    ///< Build number of this implementation.
    pub v_imp_build: u16,
    ///< Name of vendor of the implementation.
    pub vendor: [mcd_char_t; 32usize],
    ///< String from __DATE__ macro at compile time.
    pub date: [mcd_char_t; 16usize],
}
#[test]
fn bindgen_test_layout_mcd_impl_version_info_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_impl_version_info_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_impl_version_info_st>(),
        90usize,
        concat!("Size of: ", stringify!(mcd_impl_version_info_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_impl_version_info_st>(),
        2usize,
        concat!("Alignment of ", stringify!(mcd_impl_version_info_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_api) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_impl_version_info_st),
        "::",
        stringify!(v_api)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_imp_major) as usize - ptr as usize },
        36usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_impl_version_info_st),
        "::",
        stringify!(v_imp_major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_imp_minor) as usize - ptr as usize },
        38usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_impl_version_info_st),
        "::",
        stringify!(v_imp_minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_imp_build) as usize - ptr as usize },
        40usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_impl_version_info_st),
        "::",
        stringify!(v_imp_build)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vendor) as usize - ptr as usize },
        42usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_impl_version_info_st),
        "::",
        stringify!(vendor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).date) as usize - ptr as usize },
        74usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_impl_version_info_st),
        "::",
        stringify!(date)
        )
    );
}
/// \brief Structure type containing the error status and error event notification.
///
///All API functions return a value of type \c mcd_return_et. If this value indicates an error or an
///error event that has happened during the last API call, the calling function has to handle it
///appropriately. This can be achieved by asking for more information about the occurred error or error
///event. This structure type contains all the required details about the error and/or the error event
///as reported by the target.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcd_error_info_st {
    ///< Return status from the last API call.
    pub return_status: mcd_return_et,
    ///< Detailed error code from the last API call.
    pub error_code: mcd_error_code_et,
    ///< Detailed event code from the last API call.
    pub error_events: mcd_error_event_et,
    ///< Detailed error text string from the last API call.
    pub error_str: [mcd_char_t; 256usize],
}
#[test]
fn bindgen_test_layout_mcd_error_info_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_error_info_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_error_info_st>(),
        268usize,
        concat!("Size of: ", stringify!(mcd_error_info_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_error_info_st>(),
        4usize,
        concat!("Alignment of ", stringify!(mcd_error_info_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).return_status) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_error_info_st),
        "::",
        stringify!(return_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_error_info_st),
        "::",
        stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_events) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_error_info_st),
        "::",
        stringify!(error_events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_str) as usize - ptr as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_error_info_st),
        "::",
        stringify!(error_str)
        )
    );
}
impl Default for mcd_error_info_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/// \brief Structure type containing the server information.
///
///This structure type contains the information about a running or an installed server.
///
///\c server contains a string with the server name. For a running simulation server, \c system_instance has
///the same value as \c system_instance in \ref mcd_core_con_info_st, and \c acc_hw contains an empty string.
///For a real hardware server it is the other way around.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcd_server_info_st {
    ///< String containing the server name.
    pub server: [mcd_char_t; 64usize],
    ///< String containing the unique system instance identifier.
    pub system_instance: [mcd_char_t; 64usize],
    ///< String containing the unique device access hardware name.
    pub acc_hw: [mcd_char_t; 64usize],
}
#[test]
fn bindgen_test_layout_mcd_server_info_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_server_info_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_server_info_st>(),
        192usize,
        concat!("Size of: ", stringify!(mcd_server_info_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_server_info_st>(),
        1usize,
        concat!("Alignment of ", stringify!(mcd_server_info_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).server) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_server_info_st),
        "::",
        stringify!(server)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).system_instance) as usize - ptr as usize },
        64usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_server_info_st),
        "::",
        stringify!(system_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acc_hw) as usize - ptr as usize },
        128usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_server_info_st),
        "::",
        stringify!(acc_hw)
        )
    );
}
impl Default for mcd_server_info_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/// \brief Structure type containing the server connection instance.
///
///This structure type contains a server connection instance.
///
///For the MCD API a server provides the capability to connect to a system, its devices and/or cores.
///A server can arrange connections to several systems. A system again consists of devices and cores,
///where devices may subsume several cores, e.g. a SoC on a real hardware board. Consequently, a
///multi-core simulation is a system with several processor cores.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcd_server_st {
    ///< Server connection instance of an implementation at lower level.
    pub instance: *mut ::std::os::raw::c_void,
    ///< String containing the host name.
    pub host: *const mcd_char_t,
    ///< Server configuration information.
    pub config_string: *const mcd_char_t,
}
#[test]
fn bindgen_test_layout_mcd_server_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_server_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_server_st>(),
        24usize,
        concat!("Size of: ", stringify!(mcd_server_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_server_st>(),
        8usize,
        concat!("Alignment of ", stringify!(mcd_server_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instance) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_server_st),
        "::",
        stringify!(instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_server_st),
        "::",
        stringify!(host)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).config_string) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_server_st),
        "::",
        stringify!(config_string)
        )
    );
}
impl Default for mcd_server_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/// \brief Structure type containing the core connection information.
///
///The MCD hierarchy's top-level is a system. The next level are devices and followed by cores at the
///lowest level are cores. The MCD API is core centric, i.e. connections are established to specific
///cores and not to a device or a system. The core connection information is used to open this connection
///with \ref mcd_open_core_f().
///In order to establish a core connection, the core connection information does not have to complete
///but it has to be unambiguous. A set of hierarchical query functions, starting at system level, allows
///to parse each system top down.
///It is recommended to exclude unnecessary and redundant hierarchy information from \c core and \c device.
///\c device needs to be readable and unambigious within a \c system. \c core again has to be readable and
///unambigious within its superior \c device instance.
///
///This structure type contains all information required to establish a core connection.
///
///A detailed description for a few member fields of \ref mcd_core_con_info_st is provided below:
///- \c system          : String containing the system name. Predefined value is "Real HW" for physical
///devices. Note that in case of "Real HW" the \c acc_hw always needs to be defined.
///- \c system_instance : Allows to differentiate between several system instances with the same name. A
///typical use case is a simulator where different instances can be distinguished
///by their process ID. (For example \c system_instance could be: "Process ID: 1234".
///- \c device          : String containing the system unique device instance name. For Real HW this is
///usually the sales name of the device. If the access hardware operates a multi device
///target system (e.g. over IEEE1149.7), this device string can contain an index to
///differentiate between several devices of the same type.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcd_core_con_info_st {
    ///< String containing the IP host name.
    pub host: [mcd_char_t; 64usize],
    ///< Port number of the server.
    pub server_port: u32,
    ///< String containing the server key as provided by \ref mcd_open_server_f().
    pub server_key: [mcd_char_t; 64usize],
    ///< String containing the system key as provided by \ref mcd_open_server_f().
    pub system_key: [mcd_char_t; 64usize],
    ///< String containing the device key, optional for \ref mcd_open_core_f().
    pub device_key: [mcd_char_t; 64usize],
    ///< String containing the system name.
    pub system: [mcd_char_t; 64usize],
    ///< String containing the unique system instance identifier.
    pub system_instance: [mcd_char_t; 64usize],
    ///< String containing the unique device access hardware name.
    pub acc_hw: [mcd_char_t; 64usize],
    ///< Device type identifier (IEEE 1149.1 device ID).
    pub device_type: u32,
    ///< String containing the system unique device instance name.
    pub device: [mcd_char_t; 64usize],
    ///< Unique device ID.
    pub device_id: u32,
    ///< String containing the device unique core name.
    pub core: [mcd_char_t; 64usize],
    ///< Core type identifier (taken from ELF predefined architecture).
    pub core_type: u32,
    ///< Unique core ID representing the core version.
    pub core_id: u32,
}
#[test]
fn bindgen_test_layout_mcd_core_con_info_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_core_con_info_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_core_con_info_st>(),
        596usize,
        concat!("Size of: ", stringify!(mcd_core_con_info_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_core_con_info_st>(),
        4usize,
        concat!("Alignment of ", stringify!(mcd_core_con_info_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_core_con_info_st),
        "::",
        stringify!(host)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).server_port) as usize - ptr as usize },
        64usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_core_con_info_st),
        "::",
        stringify!(server_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).server_key) as usize - ptr as usize },
        68usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_core_con_info_st),
        "::",
        stringify!(server_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).system_key) as usize - ptr as usize },
        132usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_core_con_info_st),
        "::",
        stringify!(system_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_key) as usize - ptr as usize },
        196usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_core_con_info_st),
        "::",
        stringify!(device_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).system) as usize - ptr as usize },
        260usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_core_con_info_st),
        "::",
        stringify!(system)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).system_instance) as usize - ptr as usize },
        324usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_core_con_info_st),
        "::",
        stringify!(system_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acc_hw) as usize - ptr as usize },
        388usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_core_con_info_st),
        "::",
        stringify!(acc_hw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_type) as usize - ptr as usize },
        452usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_core_con_info_st),
        "::",
        stringify!(device_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device) as usize - ptr as usize },
        456usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_core_con_info_st),
        "::",
        stringify!(device)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_id) as usize - ptr as usize },
        520usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_core_con_info_st),
        "::",
        stringify!(device_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).core) as usize - ptr as usize },
        524usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_core_con_info_st),
        "::",
        stringify!(core)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).core_type) as usize - ptr as usize },
        588usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_core_con_info_st),
        "::",
        stringify!(core_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).core_id) as usize - ptr as usize },
        592usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_core_con_info_st),
        "::",
        stringify!(core_id)
        )
    );
}
impl Default for mcd_core_con_info_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/// \brief Structure type containing the core connection instance.
///
///This structure type contains a core connection instance.
///
///A detailed description for a few member fields of \ref mcd_core_st is provided below:
///- \c instance : The core connection instance of an implementation at a lower level.
///This void pointer must not be null except from function calls
///concerning communication channels. For these calls, null pointers
///are allowed in order to address hierarchical levels higher than core
///level.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcd_core_st {
    ///< Core connection instance of an implementation at lower level.
    pub instance: *mut ::std::os::raw::c_void,
    ///< Core connection information of the core instance.
    pub core_con_info: *const mcd_core_con_info_st,
}
#[test]
fn bindgen_test_layout_mcd_core_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_core_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_core_st>(),
        16usize,
        concat!("Size of: ", stringify!(mcd_core_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_core_st>(),
        8usize,
        concat!("Alignment of ", stringify!(mcd_core_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instance) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_core_st),
        "::",
        stringify!(instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).core_con_info) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_core_st),
        "::",
        stringify!(core_con_info)
        )
    );
}
impl Default for mcd_core_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/// \brief Structure type containing information about a core mode.
///
///This structure type contains information about a specific core mode. Most cores have for example "supervisor"
///or "user" operation modes. \c core_mode can be a value within the range of 1 to 32. Some API structures
///contain bitmasks of which each bit corresponds to \c core_mode of exactly one core mode (bit 0 corresponds
///to core mode 1).
///Core mode 0 is used to define a default core mode - usually the most permissive core mode.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcd_core_mode_info_st {
    ///< Contains one of the 32 possible core modes,
    ///values can be 1 to 32.
    pub core_mode: u8,
    ///< The name of this core mode.
    pub name: [mcd_char_t; 32usize],
}
#[test]
fn bindgen_test_layout_mcd_core_mode_info_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_core_mode_info_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_core_mode_info_st>(),
        33usize,
        concat!("Size of: ", stringify!(mcd_core_mode_info_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_core_mode_info_st>(),
        1usize,
        concat!("Alignment of ", stringify!(mcd_core_mode_info_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).core_mode) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_core_mode_info_st),
        "::",
        stringify!(core_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        1usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_core_mode_info_st),
        "::",
        stringify!(name)
        )
    );
}
/// \brief Structure type containing a completely resolved logical or physical memory address.
///
///This structure type contains a completely resolved logical or physical memory address. The \c address
///is always expressed in bytes, even if the minimum access unit (MAU) size is larger than a byte. The
///\c addr_space_id can be used for different purposes as defined by \c addr_space_type.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcd_addr_st {
    ///< Address value within a memory space, expressed in bytes.
    pub address: u64,
    ///< ID of the memory space associated with this address,
    ///e.g. a program memory, a data memory or registers .
    pub mem_space_id: u32,
    ///< ID of the address space in which this address is valid.
    pub addr_space_id: u32,
    ///< Type of the address space in which this address is valid.
    pub addr_space_type: mcd_addr_space_type_et,
}
#[test]
fn bindgen_test_layout_mcd_addr_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_addr_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_addr_st>(),
        24usize,
        concat!("Size of: ", stringify!(mcd_addr_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_addr_st>(),
        8usize,
        concat!("Alignment of ", stringify!(mcd_addr_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_addr_st),
        "::",
        stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_space_id) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_addr_st),
        "::",
        stringify!(mem_space_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr_space_id) as usize - ptr as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_addr_st),
        "::",
        stringify!(addr_space_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr_space_type) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_addr_st),
        "::",
        stringify!(addr_space_type)
        )
    );
}
/// \brief Structure type containing information about a memory space.
///
///This structure type contains information about a memory space. of a target core. A memory space defines
///a region of memory used in different processor architectures, e.g. "program" and "data" memory of a
///Harvard architecture or "P"/"X"/"Y"/"Z" of a DSP architecture.
///
///Users must note that the sematics used in order to access a cache memory are the same as for accessing
///regular memory. On the target side, each cache memory implementation must be provided as a different
///memory space with a unique memory space ID. All accesses to such a memory space must be understood by
///the target as debug access to the cache.
///
///A detailed description for a few member fields of \ref mcd_memspace_st is provided below:
///- \c bits_per_mau    : The minimum addressable unit of a memory is defined as the size in bits of its
///basic block that may have a unique address. For example for a byte addressable
///memory this value would be set to '8' according to the 8 bits of a byte block.
///- \c invariance      : The total number of bytes in a memory word, which is \c bits_per_mau divided
///by 8, consists of groups of "invariant" bytes. These groups can be arranged in
///Big Endian or Little Endian order. For example an \c invariance of '2' and '64'
///\c bits_per_mau, a Little Endian word are represented as b0 b1 b2 b3 b4 b5 b6 b7.
///In contrast to this, a Big Endian word is represented as b6 b7 b4 b5 b2 b3 b0 b1.
///- \c num_mem_blocks  : Each memory space may have a certain number of memory blocks. Memory blocks contain
///additional information pertaining to the intended purpose of the memory. This
///information may be used as a hint for memory data representation within a tool's
///memory view. This field specifies the number of memory blocks present in this
///memory space.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcd_memspace_st {
    ///< ID of this memory space, ID 0 is reserved.
    pub mem_space_id: u32,
    ///< Unique name of the memory space.
    pub mem_space_name: [mcd_char_t; 32usize],
    ///< Type of the memory space.
    pub mem_type: mcd_mem_type_et,
    ///< Bits per minimum addressable unit (MAU).
    pub bits_per_mau: u32,
    ///< Number of invariant bytes.
    pub invariance: u8,
    ///< Endianness of this memory space. Can be overriden by \c endian
    ///of a \ref mcd_memblock_st.
    pub endian: mcd_endian_et,
    ///< Minimum address of this memory space.
    pub min_addr: u64,
    ///< Maximum address of this memory space.
    pub max_addr: u64,
    ///< Number of memory blocks in this memory space.
    pub num_mem_blocks: u32,
    ///< Supported memory access options (OR'ed bitmask). Can be overriden
    ///by \c supported_access_options of a \c mcd_memblock_st.
    pub supported_access_options: mcd_tx_access_opt_et,
    ///< Mask of core modes for which read accesses are impossible.
    ///A set bit indicates that read accesses are denied in this mode.
    ///Bit 0 represents core mode '1', bit 31 represents core mode '32'.
    ///Can be overriden by \c core_mode_mask_read of a \ref mcd_memblock_st.
    pub core_mode_mask_read: u32,
    ///< Mask of core modes for which write accesses are impossible;
    ///a set bit indicates that write accesses are denied in this mode.
    ///Bit 0 represents core mode '1', bit 31 represents core mode '32'.
    ///Can be overriden by \c core_mode_mask_write of a \ref mcd_memblock_st.
    pub core_mode_mask_write: u32,
}
#[test]
fn bindgen_test_layout_mcd_memspace_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_memspace_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_memspace_st>(),
        88usize,
        concat!("Size of: ", stringify!(mcd_memspace_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_memspace_st>(),
        8usize,
        concat!("Alignment of ", stringify!(mcd_memspace_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_space_id) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_memspace_st),
        "::",
        stringify!(mem_space_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_space_name) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_memspace_st),
        "::",
        stringify!(mem_space_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_type) as usize - ptr as usize },
        36usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_memspace_st),
        "::",
        stringify!(mem_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits_per_mau) as usize - ptr as usize },
        40usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_memspace_st),
        "::",
        stringify!(bits_per_mau)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).invariance) as usize - ptr as usize },
        44usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_memspace_st),
        "::",
        stringify!(invariance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endian) as usize - ptr as usize },
        48usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_memspace_st),
        "::",
        stringify!(endian)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_addr) as usize - ptr as usize },
        56usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_memspace_st),
        "::",
        stringify!(min_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_addr) as usize - ptr as usize },
        64usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_memspace_st),
        "::",
        stringify!(max_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_mem_blocks) as usize - ptr as usize },
        72usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_memspace_st),
        "::",
        stringify!(num_mem_blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supported_access_options) as usize - ptr as usize },
        76usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_memspace_st),
        "::",
        stringify!(supported_access_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).core_mode_mask_read) as usize - ptr as usize },
        80usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_memspace_st),
        "::",
        stringify!(core_mode_mask_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).core_mode_mask_write) as usize - ptr as usize },
        84usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_memspace_st),
        "::",
        stringify!(core_mode_mask_write)
        )
    );
}
/// \brief Structure type containing information about a memory block.
///
///This structure type contains information about a memory block. A memory block is defined as
///a continuous range of memory addresses with same properties. A memory block is owned by a
///memory space.
///
///Detailed description for a few member fields of \ref mcd_memblock_st is provided below:
///- \c parent_id          : Memory blocks by definition can be hierarchical. This field describes
///the ID of the parent memory block. In case this memory block is at
///root level (and therefore has no parent) the \c parent_id field has
///to be set to \c MCD_MEM_BLOCK_NOPARENT.
///- \c supported_au_sizes : This array has a maximum of \c MCD_MEM_AUSIZE_NUM entries. Each entry
///different from '0' indicates the permissible size of an addressable
///memory unit in bits. All entries represent an allowed multiple of the
///\c bits_per_mau field in the corresponding \c mcd_memspace_st data
///structure. For example, the supported addressable unit sizes for a
///memory block in a memory space with '32' \c bits_per_mau would be
///{32, 64, 96, 128}. This array field would then contain the values
///{1, 2, 3, 4}.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcd_memblock_st {
    ///< ID of this memory block, ID 0 is reserved.
    pub mem_block_id: u32,
    ///< Memory block name.
    pub mem_block_name: [mcd_char_t; 32usize],
    ///< Indicating that this block has children.
    pub has_children: mcd_bool_t,
    ///< ID of this block's parent (\c MCD_MEM_BLOCK_NOPARENT
    ///if no parent exists).
    pub parent_id: u32,
    ///< Start address of this block.
    pub start_addr: u64,
    ///< End address of this block.
    pub end_addr: u64,
    ///< Endianness of this memory block. Overrides \c endian of the
    ///corresponding \ref mcd_memspace_st.
    pub endian: mcd_endian_et,
    ///< Array of supported addressable unit sizes
    pub supported_au_sizes: [u32; 8usize],
    ///< Supported memory access options (OR'ed bitmask).
    ///Overrides \c supported_access_options of the
    ///corresponding \ref mcd_memspace_st.
    pub supported_access_options: mcd_tx_access_opt_et,
    ///< Mask of core modes for which read accesses are impossible.
    ///A set bit indicates that read accesses are denied in this
    ///mode. Bit 0 represents core mode '1', bit 31 represents
    ///core mode '32'. Overrides \c core_mode_mask_read of the
    ///corresponding \ref mcd_memspace_st.
    pub core_mode_mask_read: u32,
    ///< Mask of core modes for which write accesses are impossible.
    ///A set bit indicates that write accesses are denied in this
    ///mode. Bit 0 represents core mode '1', bit 31 represents
    ///core mode '32'. Overrides \c core_mode_mask_write of the
    ///corresponding \ref mcd_memspace_st.
    pub core_mode_mask_write: u32,
}
#[test]
fn bindgen_test_layout_mcd_memblock_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_memblock_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_memblock_st>(),
        112usize,
        concat!("Size of: ", stringify!(mcd_memblock_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_memblock_st>(),
        8usize,
        concat!("Alignment of ", stringify!(mcd_memblock_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_block_id) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_memblock_st),
        "::",
        stringify!(mem_block_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_block_name) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_memblock_st),
        "::",
        stringify!(mem_block_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_children) as usize - ptr as usize },
        36usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_memblock_st),
        "::",
        stringify!(has_children)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_id) as usize - ptr as usize },
        40usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_memblock_st),
        "::",
        stringify!(parent_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_addr) as usize - ptr as usize },
        48usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_memblock_st),
        "::",
        stringify!(start_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_addr) as usize - ptr as usize },
        56usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_memblock_st),
        "::",
        stringify!(end_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endian) as usize - ptr as usize },
        64usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_memblock_st),
        "::",
        stringify!(endian)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supported_au_sizes) as usize - ptr as usize },
        68usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_memblock_st),
        "::",
        stringify!(supported_au_sizes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supported_access_options) as usize - ptr as usize },
        100usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_memblock_st),
        "::",
        stringify!(supported_access_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).core_mode_mask_read) as usize - ptr as usize },
        104usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_memblock_st),
        "::",
        stringify!(core_mode_mask_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).core_mode_mask_write) as usize - ptr as usize },
        108usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_memblock_st),
        "::",
        stringify!(core_mode_mask_write)
        )
    );
}
/// \brief Structure type containing register group information.
///
///This structure type contains the properties of a register group of a target core.
///
///Detailed description for a few member fields of \ref mcd_register_group_st is provided below:
///- \c reg_group_id   : Contains the ID of this register group. A register group ID must be
///unique within the scope of a target core. ID '0' is reserved.
///- \c reg_group_name : The name of a register group. A register group name cannot be longer
///than \c MCD_REGNAME_LEN characters (use representative names).
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcd_register_group_st {
    ///< ID of the register group, ID 0 is reserved.
    pub reg_group_id: u32,
    ///< Register group name.
    pub reg_group_name: [mcd_char_t; 32usize],
    ///< Number of registers part of this group.
    pub n_registers: u32,
}
#[test]
fn bindgen_test_layout_mcd_register_group_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_register_group_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_register_group_st>(),
        40usize,
        concat!("Size of: ", stringify!(mcd_register_group_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_register_group_st>(),
        4usize,
        concat!("Alignment of ", stringify!(mcd_register_group_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_group_id) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_register_group_st),
        "::",
        stringify!(reg_group_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_group_name) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_register_group_st),
        "::",
        stringify!(reg_group_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_registers) as usize - ptr as usize },
        36usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_register_group_st),
        "::",
        stringify!(n_registers)
        )
    );
}
/// \brief Structure type containing register information for a single register.
///
///This structure contains the properties of a single register of a target core.
///
///Detailed description for a few member fields of \ref mcd_register_group_st is provided below:
///- \c addr         : Address of the register, not memory mapped registers are handled like memory mapped
///into a "register" memory space (with \c mem_type of the corresponding \ref mcd_memspace_st
///set to \c MCD_MEM_SPACE_IS_REGISTERS).
///- \c regname      : The name of a register. A register name cannot be longer than \c MCD_REGNAME_LEN
///characters (use representative names).
///- \c hw_thread_id : The hardware thread ID the register belongs to. The ID must be set to '0'
///if the register is not assigned to a hardware thread.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcd_register_info_st {
    ///< Either the address of a memory mapped register or the register
    ///address in a dedicated "register memory space".
    pub addr: mcd_addr_st,
    ///< ID of the group this register belongs to.
    pub reg_group_id: u32,
    ///< Register name.
    pub regname: [mcd_char_t; 32usize],
    ///< Register size in bits.
    pub regsize: u32,
    ///< Mask of core modes for which read accesses are impossible.
    ///A set bit indicates that read accesses are denied in this mode.
    ///Bit 0 represents core mode '1', bit 31 represents core mode 32.
    ///Overrides \c core_mode_mask_read of the corresponding \ref mcd_memspace_st.
    pub core_mode_mask_read: u32,
    ///< Mask of core modes for which write accesses are impossible.
    ///A set bit indicates that write accesses are denied in this mode.
    ///Bit 0 represents core mode '1', bit 31 represents core mode '32'.
    ///Overrides \c core_mode_mask_write of the corresponding \ref mcd_memspace_st.
    pub core_mode_mask_write: u32,
    ///< Reading this register can trigger side effects.
    pub has_side_effects_read: mcd_bool_t,
    ///< Writing this register can trigger side effects.
    pub has_side_effects_write: mcd_bool_t,
    ///< Register type (simple, compound or partial).
    pub reg_type: mcd_reg_type_et,
    ///< Hardware thread ID this register belongs to.
    pub hw_thread_id: u32,
}
#[test]
fn bindgen_test_layout_mcd_register_info_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_register_info_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_register_info_st>(),
        88usize,
        concat!("Size of: ", stringify!(mcd_register_info_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_register_info_st>(),
        8usize,
        concat!("Alignment of ", stringify!(mcd_register_info_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_register_info_st),
        "::",
        stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_group_id) as usize - ptr as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_register_info_st),
        "::",
        stringify!(reg_group_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regname) as usize - ptr as usize },
        28usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_register_info_st),
        "::",
        stringify!(regname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regsize) as usize - ptr as usize },
        60usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_register_info_st),
        "::",
        stringify!(regsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).core_mode_mask_read) as usize - ptr as usize },
        64usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_register_info_st),
        "::",
        stringify!(core_mode_mask_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).core_mode_mask_write) as usize - ptr as usize },
        68usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_register_info_st),
        "::",
        stringify!(core_mode_mask_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_side_effects_read) as usize - ptr as usize },
        72usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_register_info_st),
        "::",
        stringify!(has_side_effects_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_side_effects_write) as usize - ptr as usize },
        76usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_register_info_st),
        "::",
        stringify!(has_side_effects_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_type) as usize - ptr as usize },
        80usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_register_info_st),
        "::",
        stringify!(reg_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hw_thread_id) as usize - ptr as usize },
        84usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_register_info_st),
        "::",
        stringify!(hw_thread_id)
        )
    );
}
/// \brief Structure type containing information about trigger capabilities.
///
///This structure type contains information about the trigger capabilities of a target.
///
///Note: \c trig_number, \c state_number and \c counter_number should NOT be used to determine
///if the appropriate trigger resource is available. It can just provide hints about the
///maximum number. The availability should be checked evaluating \c action.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcd_trig_info_st {
    ///< Supported trigger types (OR'ed bitmask).
    pub type_: mcd_trig_type_et,
    ///< Supported trigger options (OR'ed bitmask).
    pub option: mcd_trig_opt_et,
    ///< Supported trigger actions (OR'ed bitmask).
    pub action: mcd_trig_action_et,
    ///< Number of usable triggers (or 0 if number not known).
    pub trig_number: u32,
    ///< Number of states of the trigger set's state machine (or 0 if not known).
    pub state_number: u32,
    ///< Number of usable counters (or 0 if not known).
    pub counter_number: u32,
    ///< True if software breakpoints via code patch are available.
    pub sw_breakpoints: mcd_bool_t,
}
#[test]
fn bindgen_test_layout_mcd_trig_info_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_trig_info_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_trig_info_st>(),
        28usize,
        concat!("Size of: ", stringify!(mcd_trig_info_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_trig_info_st>(),
        4usize,
        concat!("Alignment of ", stringify!(mcd_trig_info_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_info_st),
        "::",
        stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).option) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_info_st),
        "::",
        stringify!(option)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_info_st),
        "::",
        stringify!(action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trig_number) as usize - ptr as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_info_st),
        "::",
        stringify!(trig_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state_number) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_info_st),
        "::",
        stringify!(state_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counter_number) as usize - ptr as usize },
        20usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_info_st),
        "::",
        stringify!(counter_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sw_breakpoints) as usize - ptr as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_info_st),
        "::",
        stringify!(sw_breakpoints)
        )
    );
}
/// \brief Structure type containing information about a custom trigger.
///
///This structure type contains information about a custom trigger. These custom triggers can be used
///via the \ref mcd_trig_custom_st structure type.
///
///Note: This is NOT related to custom trigger formats - they use a format not defined by the MCD API.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcd_ctrig_info_st {
    ///< Custom trigger ID, ID 0 is reserved.
    pub ctrig_id: u32,
    ///< Description of the custom trigger.
    pub info_str: [mcd_char_t; 256usize],
}
#[test]
fn bindgen_test_layout_mcd_ctrig_info_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_ctrig_info_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_ctrig_info_st>(),
        260usize,
        concat!("Size of: ", stringify!(mcd_ctrig_info_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_ctrig_info_st>(),
        4usize,
        concat!("Alignment of ", stringify!(mcd_ctrig_info_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctrig_id) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_ctrig_info_st),
        "::",
        stringify!(ctrig_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info_str) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_ctrig_info_st),
        "::",
        stringify!(info_str)
        )
    );
}
impl Default for mcd_ctrig_info_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/// \brief Structure type containing information about a complex core trigger condition.
///
///This structure type contains information about a complex core based trigger of the target system.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcd_trig_complex_core_st {
    ///< Size of this structure in bytes.
    pub struct_size: u32,
    ///< Trigger type, for this structure type it must be one of:
    ///- \c MCD_TRIG_TYPE_IP
    ///- \c MCD_TRIG_TYPE_READ
    ///- \c MCD_TRIG_TYPE_WRITE
    ///- \c MCD_TRIG_TYPE_RW
    ///- \c MCD_TRIG_TYPE_NOCYCLE
    pub type_: mcd_trig_type_et,
    ///< Adds further qualifiers to the trigger or overrides the behaviour
    ///(multiple options possible).
    pub option: mcd_trig_opt_et,
    ///< Action to be taken on trigger. Only one per trigger allowed.
    pub action: mcd_trig_action_et,
    ///< Parameter for action - depends on the selected action.
    pub action_param: u32,
    ///< Set to "TRUE" on return of \ref mcd_create_trig_f() if trigger was
    ///modified by implementation, untouched otherwise.
    pub modified: mcd_bool_t,
    ///< Set bits indicate that this trigger is inactive when reaching the
    ///corresponding state of the state machine. Bit 0 represents state '1'
    ///of the state machine. Only to be considered if
    ///\c MCD_TRIG_OPT_STATE_IS_CONDITION is set in \c option.
    pub state_mask: u32,
    ///< Start address for the address range the trigger shall be activated for.
    pub addr_start: mcd_addr_st,
    ///< Size of the address range for the trigger (in bytes).
    ///If it is set to '0', the trigger is activated by an access to a single
    ///address.
    ///If it is set to '1', the range of addresses is two (\c addr_start + 1).
    ///The address range can be "inverted" if \c MCD_TRIG_OPT_OUT_OF_RANGE is
    ///set in \c option.
    pub addr_range: u64,
    ///< Data comparison value of the trigger. Only considered if
    ///\c MCD_TRIG_OPT_DATA_IS_CONDITION is set in \c option.
    ///Setting option \c MCD_TRIG_OPT_NOT_DATA activates the trigger
    ///on a data mismatch.
    pub data_start: u64,
    ///< Size of the data value range for the trigger.
    ///If it is set to '0', the trigger is activated on a match with a single
    ///value.
    ///If it is set to '1', the range of values is two (\c data_range + 1).
    ///Option \c MCD_TRIG_OPT_SIGNED_DATA may be set in \c option if the data
    ///shall be interpreted as signed. This usually also requires the option
    ///\c MCD_TRIG_OPT_DATASIZE_IS_CONDITION to be set in \c option.
    pub data_range: u64,
    ///< Only value bits are considered for which the mask is set to '0'.
    pub data_mask: u64,
    ///< Size of the access in bytes. If set to '0' the size shall not be
    ///considered.
    ///Shall be only considered if \c MCD_TRIG_OPT_DATASIZE_IS_CONDITION
    ///is set in \c option.
    pub data_size: u32,
    ///< ID of the hardware thread this trigger is associated with.
    pub hw_thread_id: u32,
    ///< ID of the software thread this trigger is associated with.
    pub sw_thread_id: u64,
    ///< Mask of core modes for which the trigger shall not be activated.
    ///A set bit disables the trigger for the corresponding mode.
    ///Bit 0 represents core mode '1', bit 31 represents core mode '32'.
    pub core_mode_mask: u32,
}
#[test]
fn bindgen_test_layout_mcd_trig_complex_core_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_trig_complex_core_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_trig_complex_core_st>(),
        112usize,
        concat!("Size of: ", stringify!(mcd_trig_complex_core_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_trig_complex_core_st>(),
        8usize,
        concat!("Alignment of ", stringify!(mcd_trig_complex_core_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).struct_size) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_complex_core_st),
        "::",
        stringify!(struct_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_complex_core_st),
        "::",
        stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).option) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_complex_core_st),
        "::",
        stringify!(option)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action) as usize - ptr as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_complex_core_st),
        "::",
        stringify!(action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action_param) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_complex_core_st),
        "::",
        stringify!(action_param)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modified) as usize - ptr as usize },
        20usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_complex_core_st),
        "::",
        stringify!(modified)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state_mask) as usize - ptr as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_complex_core_st),
        "::",
        stringify!(state_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr_start) as usize - ptr as usize },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_complex_core_st),
        "::",
        stringify!(addr_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr_range) as usize - ptr as usize },
        56usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_complex_core_st),
        "::",
        stringify!(addr_range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_start) as usize - ptr as usize },
        64usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_complex_core_st),
        "::",
        stringify!(data_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_range) as usize - ptr as usize },
        72usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_complex_core_st),
        "::",
        stringify!(data_range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_mask) as usize - ptr as usize },
        80usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_complex_core_st),
        "::",
        stringify!(data_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_size) as usize - ptr as usize },
        88usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_complex_core_st),
        "::",
        stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hw_thread_id) as usize - ptr as usize },
        92usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_complex_core_st),
        "::",
        stringify!(hw_thread_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sw_thread_id) as usize - ptr as usize },
        96usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_complex_core_st),
        "::",
        stringify!(sw_thread_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).core_mode_mask) as usize - ptr as usize },
        104usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_complex_core_st),
        "::",
        stringify!(core_mode_mask)
        )
    );
}
/// \brief Structure type containing information about a simple core trigger condition.
///
///This structure type contains information about a simple core based trigger of the target system.
///It is a subset of \ref mcd_trig_complex_core_st.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcd_trig_simple_core_st {
    ///< Size of this structure in bytes.
    pub struct_size: u32,
    ///< Trigger type, for this structure type it must be one of:
    ///- \c MCD_TRIG_TYPE_IP
    ///- \c MCD_TRIG_TYPE_READ
    ///- \c MCD_TRIG_TYPE_WRITE
    ///- \c MCD_TRIG_TYPE_RW
    ///- \c MCD_TRIG_TYPE_NOCYCLE
    pub type_: mcd_trig_type_et,
    ///< Adds further qualifiers to the trigger or overrides the behaviour
    ///(multiple options possible).
    pub option: mcd_trig_opt_et,
    ///< Action to be taken on trigger. Only one per trigger allowed.
    pub action: mcd_trig_action_et,
    ///< Parameter for action - depends on the selected action.
    pub action_param: u32,
    ///< Set to "TRUE" on return of \ref mcd_create_trig_f() if trigger was
    ///modified by implementation, untouched otherwise.
    pub modified: mcd_bool_t,
    ///< Set bits indicate that this trigger is inactive when reaching the
    ///corresponding state of the state machine. Bit 0 represents state '1'
    ///of the state machine. Only to be considered if
    ///\c MCD_TRIG_OPT_STATE_IS_CONDITION is set in \c option.
    pub state_mask: u32,
    ///< Start address for the address range the trigger shall be activated for.
    pub addr_start: mcd_addr_st,
    ///< Size of the address range for the trigger (in bytes).
    ///If it is set to '0', the trigger is activated by an access to a single
    ///address.
    ///If it is set to '1', the range of addresses is two (\c addr_start + 1).
    ///The address range can be "inverted" if \c MCD_TRIG_OPT_OUT_OF_RANGE is
    ///set in \c option.
    pub addr_range: u64,
}
#[test]
fn bindgen_test_layout_mcd_trig_simple_core_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_trig_simple_core_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_trig_simple_core_st>(),
        64usize,
        concat!("Size of: ", stringify!(mcd_trig_simple_core_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_trig_simple_core_st>(),
        8usize,
        concat!("Alignment of ", stringify!(mcd_trig_simple_core_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).struct_size) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_simple_core_st),
        "::",
        stringify!(struct_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_simple_core_st),
        "::",
        stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).option) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_simple_core_st),
        "::",
        stringify!(option)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action) as usize - ptr as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_simple_core_st),
        "::",
        stringify!(action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action_param) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_simple_core_st),
        "::",
        stringify!(action_param)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modified) as usize - ptr as usize },
        20usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_simple_core_st),
        "::",
        stringify!(modified)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state_mask) as usize - ptr as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_simple_core_st),
        "::",
        stringify!(state_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr_start) as usize - ptr as usize },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_simple_core_st),
        "::",
        stringify!(addr_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr_range) as usize - ptr as usize },
        56usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_simple_core_st),
        "::",
        stringify!(addr_range)
        )
    );
}
/// \brief Structure type containing information about a trigger bus based trigger condition.
///
///Trigger buses exist that can be optionally activated. This structure type contains information
///about a trigger on the target system based on such a trigger bus.
///
///A trigger bus is split into a core local trigger (bits 0 to 15) and a global trigger (bits 16 to 31).
///On real silicon some bits of the trigger bus may also be available on device pins.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcd_trig_trig_bus_st {
    ///< Size of this structure in bytes.
    pub struct_size: u32,
    ///< Trigger type, for this structure type it must be:
    ///- \c MCD_TRIG_TYPE_TRIG_BUS
    pub type_: mcd_trig_type_et,
    ///< Trigger options, for this structure the following are allowed:
    ///- \c MCD_TRIG_OPT_NOT
    ///- \c MCD_TRIG_OPT_STATE_IS_CONDITION
    pub option: mcd_trig_opt_et,
    ///< Action to be taken on trigger. Only one per trigger allowed.
    pub action: mcd_trig_action_et,
    ///< Parameter for action - depends on the selected action.
    pub action_param: u32,
    ///< Set to "TRUE" on return of \ref mcd_create_trig_f() if trigger was
    ///modified by implementation, untouched otherwise.
    pub modified: mcd_bool_t,
    ///< Set bits indicate that this trigger is inactive when reaching the
    ///corresponding state of the state machine. Bit 0 represents state '1'
    ///of the state machine. Only to be considered if
    ///\c MCD_TRIG_OPT_STATE_IS_CONDITION is set in \c option.
    pub state_mask: u32,
    ///< Trigger bus value.
    pub trig_bus_value: u32,
    ///< Only value bits are considered for which the bitmask is set to '0'.
    pub trig_bus_mask: u32,
}
#[test]
fn bindgen_test_layout_mcd_trig_trig_bus_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_trig_trig_bus_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_trig_trig_bus_st>(),
        36usize,
        concat!("Size of: ", stringify!(mcd_trig_trig_bus_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_trig_trig_bus_st>(),
        4usize,
        concat!("Alignment of ", stringify!(mcd_trig_trig_bus_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).struct_size) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_trig_bus_st),
        "::",
        stringify!(struct_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_trig_bus_st),
        "::",
        stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).option) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_trig_bus_st),
        "::",
        stringify!(option)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action) as usize - ptr as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_trig_bus_st),
        "::",
        stringify!(action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action_param) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_trig_bus_st),
        "::",
        stringify!(action_param)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modified) as usize - ptr as usize },
        20usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_trig_bus_st),
        "::",
        stringify!(modified)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state_mask) as usize - ptr as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_trig_bus_st),
        "::",
        stringify!(state_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trig_bus_value) as usize - ptr as usize },
        28usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_trig_bus_st),
        "::",
        stringify!(trig_bus_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trig_bus_mask) as usize - ptr as usize },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_trig_bus_st),
        "::",
        stringify!(trig_bus_mask)
        )
    );
}
/// \brief Structure type containing information about a trigger counter on the target.
///
///This structure type contains information about a trigger counter on the target system.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcd_trig_counter_st {
    ///< Size of this structure in bytes.
    pub struct_size: u32,
    ///< Trigger type, for this structure type it must be:
    ///- \c MCD_TRIG_TYPE_TRIG_COUNTER
    pub type_: mcd_trig_type_et,
    ///< Trigger options, for this structure the following are allowed:
    ///- \c MCD_TRIG_OPT_NOT
    ///- \c MCD_TRIG_OPT_STATE_IS_CONDITION
    pub option: mcd_trig_opt_et,
    ///< Action to be taken on trigger. Only one per trigger allowed.
    pub action: mcd_trig_action_et,
    ///< Parameter for action - depends on the selected action.
    pub action_param: u32,
    ///< Set to "TRUE" on return of \ref mcd_create_trig_f() if trigger was
    ///modified by implementation, untouched otherwise.
    pub modified: mcd_bool_t,
    ///< Set bits indicate that this trigger is inactive when reaching the
    ///corresponding state of the state machine. Bit 0 represents state '1'
    ///of the state machine. Only to be considered if
    ///\c MCD_TRIG_OPT_STATE_IS_CONDITION is set in \c option.
    pub state_mask: u32,
    ///< Current value of counter.
    pub count_value: u64,
    ///< Reload value of counter.
    pub reload_value: u64,
}
#[test]
fn bindgen_test_layout_mcd_trig_counter_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_trig_counter_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_trig_counter_st>(),
        48usize,
        concat!("Size of: ", stringify!(mcd_trig_counter_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_trig_counter_st>(),
        8usize,
        concat!("Alignment of ", stringify!(mcd_trig_counter_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).struct_size) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_counter_st),
        "::",
        stringify!(struct_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_counter_st),
        "::",
        stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).option) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_counter_st),
        "::",
        stringify!(option)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action) as usize - ptr as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_counter_st),
        "::",
        stringify!(action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action_param) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_counter_st),
        "::",
        stringify!(action_param)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modified) as usize - ptr as usize },
        20usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_counter_st),
        "::",
        stringify!(modified)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state_mask) as usize - ptr as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_counter_st),
        "::",
        stringify!(state_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count_value) as usize - ptr as usize },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_counter_st),
        "::",
        stringify!(count_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reload_value) as usize - ptr as usize },
        40usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_counter_st),
        "::",
        stringify!(reload_value)
        )
    );
}
/// \brief Structure type containing information about a custom trigger on the target.
///
///This structure type contains information about a custom trigger on the target system.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcd_trig_custom_st {
    ///< Size of this structure in bytes.
    pub struct_size: u32,
    ///< Trigger type, for this structure type it must be:
    ///- \c MCD_TRIG_TYPE_CUSTOM
    pub type_: mcd_trig_type_et,
    ///< Trigger options, for this structure the following are allowed:
    ///- \c MCD_TRIG_OPT_NOT
    ///- \c MCD_TRIG_OPT_STATE_IS_CONDITION
    pub option: mcd_trig_opt_et,
    ///< Action to be taken on trigger. Only one per trigger allowed.
    pub action: mcd_trig_action_et,
    ///< Parameter for action - depends on the selected action.
    pub action_param: u32,
    ///< Set to "TRUE" on return of \ref mcd_create_trig_f() if trigger was
    ///modified by implementation, untouched otherwise.
    pub modified: mcd_bool_t,
    ///< Set bits indicate that this trigger is inactive when reaching the
    ///corresponding state of the state machine. Bit 0 represents state '1'
    ///of the state machine. Only to be considered if
    ///\c MCD_TRIG_OPT_STATE_IS_CONDITION is set in \c option.
    pub state_mask: u32,
    ///< Custom trigger ID.
    pub ctrig_id: u32,
    ///< Custom trigger arguments.
    pub ctrig_args: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_mcd_trig_custom_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_trig_custom_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_trig_custom_st>(),
        48usize,
        concat!("Size of: ", stringify!(mcd_trig_custom_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_trig_custom_st>(),
        4usize,
        concat!("Alignment of ", stringify!(mcd_trig_custom_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).struct_size) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_custom_st),
        "::",
        stringify!(struct_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_custom_st),
        "::",
        stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).option) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_custom_st),
        "::",
        stringify!(option)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action) as usize - ptr as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_custom_st),
        "::",
        stringify!(action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action_param) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_custom_st),
        "::",
        stringify!(action_param)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modified) as usize - ptr as usize },
        20usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_custom_st),
        "::",
        stringify!(modified)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state_mask) as usize - ptr as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_custom_st),
        "::",
        stringify!(state_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctrig_id) as usize - ptr as usize },
        28usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_custom_st),
        "::",
        stringify!(ctrig_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctrig_args) as usize - ptr as usize },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_custom_st),
        "::",
        stringify!(ctrig_args)
        )
    );
}
/// \brief Structure type containing a trigger state.
///
///This structure type contains the state of a single trigger on the target system.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcd_trig_state_st {
    ///< Was active at the point of time the trigger set was uploaded.
    pub active: mcd_bool_t,
    ///< Activated at least once after trigger got downloaded to the target.
    pub captured: mcd_bool_t,
    ///< The information in \c captured is valid.
    pub captured_valid: mcd_bool_t,
    ///< Current value of the counter (for counter triggers).
    pub count_value: u64,
    ///< The information in \c count_value is valid.
    pub count_valid: mcd_bool_t,
}
#[test]
fn bindgen_test_layout_mcd_trig_state_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_trig_state_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_trig_state_st>(),
        32usize,
        concat!("Size of: ", stringify!(mcd_trig_state_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_trig_state_st>(),
        8usize,
        concat!("Alignment of ", stringify!(mcd_trig_state_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).active) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_state_st),
        "::",
        stringify!(active)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).captured) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_state_st),
        "::",
        stringify!(captured)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).captured_valid) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_state_st),
        "::",
        stringify!(captured_valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count_value) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_state_st),
        "::",
        stringify!(count_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count_valid) as usize - ptr as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_state_st),
        "::",
        stringify!(count_valid)
        )
    );
}
/// \brief Structure type containing a trigger set state.
///
///This structure type contains the state of the trigger set of the target system.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcd_trig_set_state_st {
    ///< Set if the trigger set is currently active.
    pub active: mcd_bool_t,
    ///< Current state of the trigger set's state machine.
    pub state: u32,
    ///< Current state is valid.
    pub state_valid: mcd_bool_t,
    ///< Current state of trigger bus.
    pub trig_bus: u32,
    ///< Current state of trig_bus is valid.
    pub trig_bus_valid: mcd_bool_t,
    ///< Current state of trace start/stop.
    pub trace: mcd_bool_t,
    ///< Current state is valid.
    pub trace_valid: mcd_bool_t,
    ///< Current state of performance analysis start/stop.
    pub analysis: mcd_bool_t,
    ///< Current state is valid.
    pub analysis_valid: mcd_bool_t,
}
#[test]
fn bindgen_test_layout_mcd_trig_set_state_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_trig_set_state_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_trig_set_state_st>(),
        36usize,
        concat!("Size of: ", stringify!(mcd_trig_set_state_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_trig_set_state_st>(),
        4usize,
        concat!("Alignment of ", stringify!(mcd_trig_set_state_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).active) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_set_state_st),
        "::",
        stringify!(active)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_set_state_st),
        "::",
        stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state_valid) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_set_state_st),
        "::",
        stringify!(state_valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trig_bus) as usize - ptr as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_set_state_st),
        "::",
        stringify!(trig_bus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trig_bus_valid) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_set_state_st),
        "::",
        stringify!(trig_bus_valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trace) as usize - ptr as usize },
        20usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_set_state_st),
        "::",
        stringify!(trace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trace_valid) as usize - ptr as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_set_state_st),
        "::",
        stringify!(trace_valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).analysis) as usize - ptr as usize },
        28usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_set_state_st),
        "::",
        stringify!(analysis)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).analysis_valid) as usize - ptr as usize },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trig_set_state_st),
        "::",
        stringify!(analysis_valid)
        )
    );
}
/// \brief Structure type containing information about a single transaction.
///
///This structure type contains all information required for a single transaction. The
///transaction itself can be a memory read/write operation or a register read/write operation.
///
///For memory access transactions, the data is stored to the buffer in the target's endianess format.
///For register access transaction, the data is stored to the buffer in Little Endian format. Targets
///need to read/fill the buffer, accordingly.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcd_tx_st {
    ///< The address of the first memory cell/register.
    pub addr: mcd_addr_st,
    ///< Type of access: Read/Write/Read+Write/Write+Verify.
    pub access_type: mcd_tx_access_type_et,
    ///< Access options: burst, side-effects, alternate path, cache, etc.
    pub options: mcd_tx_access_opt_et,
    ///< Access size in bytes (or 0 if access size does not matter).
    pub access_width: u8,
    ///< The core mode in which the access should be performed (or 0 for
    ///most permissive mode).
    pub core_mode: u8,
    ///< Byte array of size \c num_bytes storing the access data.
    pub data: *mut u8,
    ///< Size of the memory/register access. The buffer \c data needs to
    ///be of this size.
    pub num_bytes: u32,
    ///< Number of successfully received/sent bytes.
    pub num_bytes_ok: u32,
}
#[test]
fn bindgen_test_layout_mcd_tx_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_tx_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_tx_st>(),
        56usize,
        concat!("Size of: ", stringify!(mcd_tx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_tx_st>(),
        8usize,
        concat!("Alignment of ", stringify!(mcd_tx_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_tx_st),
        "::",
        stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access_type) as usize - ptr as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_tx_st),
        "::",
        stringify!(access_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
        28usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_tx_st),
        "::",
        stringify!(options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access_width) as usize - ptr as usize },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_tx_st),
        "::",
        stringify!(access_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).core_mode) as usize - ptr as usize },
        33usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_tx_st),
        "::",
        stringify!(core_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        40usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_tx_st),
        "::",
        stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_bytes) as usize - ptr as usize },
        48usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_tx_st),
        "::",
        stringify!(num_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_bytes_ok) as usize - ptr as usize },
        52usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_tx_st),
        "::",
        stringify!(num_bytes_ok)
        )
    );
}
impl Default for mcd_tx_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/// \brief Structure type containing a transaction list.
///
///This structure type contains a transaction list.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcd_txlist_st {
    ///< Array of size \c num_tx storing the transactions.
    pub tx: *mut mcd_tx_st,
    ///< Number of transactions.
    pub num_tx: u32,
    ///< Number of transactions which succeeded without any errors.
    pub num_tx_ok: u32,
}
#[test]
fn bindgen_test_layout_mcd_txlist_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_txlist_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_txlist_st>(),
        16usize,
        concat!("Size of: ", stringify!(mcd_txlist_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_txlist_st>(),
        8usize,
        concat!("Alignment of ", stringify!(mcd_txlist_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_txlist_st),
        "::",
        stringify!(tx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_tx) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_txlist_st),
        "::",
        stringify!(num_tx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_tx_ok) as usize - ptr as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_txlist_st),
        "::",
        stringify!(num_tx_ok)
        )
    );
}
impl Default for mcd_txlist_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/// \brief Structure type containing the state of a core.
///
///This structure type contains information about the state of a core.
///
///Note that the additional information provided in \c info_str is not a repetition of the
///general core state provided by \c state.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcd_core_state_st {
    ///< Core state.
    pub state: mcd_core_state_et,
    ///< Core events (OR'ed bitmask)
    pub event: mcd_core_event_et,
    ///< ID of the hardware thread that caused the core to stop.
    pub hw_thread_id: u32,
    ///< ID of the trigger that caused the core to stop.
    pub trig_id: u32,
    ///< Detailed description of a special stop reason.
    pub stop_str: [mcd_char_t; 256usize],
    ///< Detailed description of the core state.
    pub info_str: [mcd_char_t; 256usize],
}
#[test]
fn bindgen_test_layout_mcd_core_state_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_core_state_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_core_state_st>(),
        528usize,
        concat!("Size of: ", stringify!(mcd_core_state_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_core_state_st>(),
        4usize,
        concat!("Alignment of ", stringify!(mcd_core_state_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_core_state_st),
        "::",
        stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_core_state_st),
        "::",
        stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hw_thread_id) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_core_state_st),
        "::",
        stringify!(hw_thread_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trig_id) as usize - ptr as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_core_state_st),
        "::",
        stringify!(trig_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop_str) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_core_state_st),
        "::",
        stringify!(stop_str)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info_str) as usize - ptr as usize },
        272usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_core_state_st),
        "::",
        stringify!(info_str)
        )
    );
}
impl Default for mcd_core_state_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/// \brief Structure type containing information about a particular reset class.
///
///This structure type contains information about a particular reset class. Only a single bit of the
///32 bit field \c class_vector can be '1'. It represents the reset class for this particular reset.
///At target system level, there cannot be two objects of type \ref mcd_rst_info_st bound to the same
///reset class.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcd_rst_info_st {
    ///< Reset class vector which issues this
    ///reset. Exactly one bit may be set.
    pub class_vector: u32,
    ///< Description of the reset class.
    pub info_str: [mcd_char_t; 256usize],
}
#[test]
fn bindgen_test_layout_mcd_rst_info_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_rst_info_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_rst_info_st>(),
        260usize,
        concat!("Size of: ", stringify!(mcd_rst_info_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_rst_info_st>(),
        4usize,
        concat!("Alignment of ", stringify!(mcd_rst_info_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_vector) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_rst_info_st),
        "::",
        stringify!(class_vector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info_str) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_rst_info_st),
        "::",
        stringify!(info_str)
        )
    );
}
impl Default for mcd_rst_info_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/// \brief Structure type containing information about communication channels.
///
///This structure type contains information about the setup of a communication channel
///and about its properties.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcd_chl_st {
    ///< Channel ID.
    pub chl_id: u32,
    ///< Type of the requested channel.
    pub type_: mcd_chl_type_et,
    ///< Attributes the requested channel has to provide.
    pub attributes: mcd_chl_attributes_et,
    ///< Maximum message length (e.g. size of the message buffer
    ///as specified by \c msg_buffer_addr)
    pub max_msg_len: u32,
    ///< Address of the message buffer for memory mapped channels.
    pub msg_buffer_addr: mcd_addr_st,
    ///< Channel priority for a prioritized channel.
    ///Range is from 0 (highest priority) to MCD_CHL_LOWEST_PRIO.
    pub prio: u8,
}
#[test]
fn bindgen_test_layout_mcd_chl_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_chl_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_chl_st>(),
        48usize,
        concat!("Size of: ", stringify!(mcd_chl_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_chl_st>(),
        8usize,
        concat!("Alignment of ", stringify!(mcd_chl_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chl_id) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_chl_st),
        "::",
        stringify!(chl_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_chl_st),
        "::",
        stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attributes) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_chl_st),
        "::",
        stringify!(attributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_msg_len) as usize - ptr as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_chl_st),
        "::",
        stringify!(max_msg_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_buffer_addr) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_chl_st),
        "::",
        stringify!(msg_buffer_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prio) as usize - ptr as usize },
        40usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_chl_st),
        "::",
        stringify!(prio)
        )
    );
}
/// \brief Structure type containing information about a trace.
///
///This structure type contains information about a trace.
///
///A detailed description for a few member fields of \ref mcd_trace_info_st is provided below:
///- \c trace_id            : This ID is used to identify the trace by all trace related functions.
///- \c trace_no_timestamps : Is set if the target has no global "time" concept. It may still provide
///clock cycle information.
///- \c trace_shared        : Is set if the trace buffer used by this trace is shared with other traces.
///- \c trace_size_is_bytes : Is set when the tracebuffer size (in \ref mcd_trace_state_st) is defined in
///bytes instead of frames.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcd_trace_info_st {
    ///< ID of this trace source, ID 0 is reserved.
    pub trace_id: u32,
    ///< Trace source name.
    pub trace_name: [mcd_char_t; 256usize],
    ///< Type of this trace.
    pub trace_type: mcd_trace_type_et,
    ///< Used trace data format.
    pub trace_format: mcd_trace_format_et,
    ///< Possible modes of this trace (OR'ed bitmask).
    pub trace_modes: mcd_trace_mode_et,
    ///< Target has no real timestamping.
    pub trace_no_timestamps: mcd_bool_t,
    ///< Trace buffer is shared between cores.
    pub trace_shared: mcd_bool_t,
    ///< Trace size is defined in bytes instead of frames.
    pub trace_size_is_bytes: mcd_bool_t,
}
#[test]
fn bindgen_test_layout_mcd_trace_info_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_trace_info_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_trace_info_st>(),
        284usize,
        concat!("Size of: ", stringify!(mcd_trace_info_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_trace_info_st>(),
        4usize,
        concat!("Alignment of ", stringify!(mcd_trace_info_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trace_id) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_info_st),
        "::",
        stringify!(trace_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trace_name) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_info_st),
        "::",
        stringify!(trace_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trace_type) as usize - ptr as usize },
        260usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_info_st),
        "::",
        stringify!(trace_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trace_format) as usize - ptr as usize },
        264usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_info_st),
        "::",
        stringify!(trace_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trace_modes) as usize - ptr as usize },
        268usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_info_st),
        "::",
        stringify!(trace_modes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trace_no_timestamps) as usize - ptr as usize },
        272usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_info_st),
        "::",
        stringify!(trace_no_timestamps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trace_shared) as usize - ptr as usize },
        276usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_info_st),
        "::",
        stringify!(trace_shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trace_size_is_bytes) as usize - ptr as usize },
        280usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_info_st),
        "::",
        stringify!(trace_size_is_bytes)
        )
    );
}
impl Default for mcd_trace_info_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/// \brief Structure type containing the trace state.
///
///This structure type contains information about the trace state.
///
///Note that the additional information provided by \c info_str is no repitition of the
///general trace state provided by \c state.
///
///A detailed description for a few member fields of \ref mcd_trace_state_st is provided below:
///- \c wraparound          : Set if the frame counter has wrapped around (in FIFO mode) or overflowed
///(in PIPE mode).
///- \c count               : Counts frames, but is not reset due to a wraparound if running in FIFO
///mode (serves as progress indicator).
///- \c size                : Maximum size of trace, either in frames or in bytes.
///- \c trigger_delay       : Trigger delay. Input has the same unit as \c size (frames or bytes).
///Output is the actually elapsed number of frames.
///- \c timestamp_accuracy  : Accuracy of timestamping in percent (0 to 100). Higher values indicate
///more accurate timestamps.
///- \c timestamp_is_time   : Set when timestamp is a time value (in picoseconds). Otherwise it
///represents clock cycles.
///- \c modified            : Set on return from \ref mcd_set_trace_state_f when implementation could not
///exactly match requests.
///- \c info_str            : Additional information about the trace (only special state information).
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcd_trace_state_st {
    ///< Trace state.
    pub state: mcd_trace_state_et,
    ///< Trace buffer mode.
    pub mode: mcd_trace_mode_et,
    ///< Trace's ARM/OFF state follows core run state.
    pub autoarm: mcd_bool_t,
    ///< Set if trace buffer has wrapped around.
    pub wraparound: mcd_bool_t,
    ///< Number of valid trace frames in the buffer.
    pub frames: u64,
    ///< Number of valid trace frames, continues after
    ///wraparound.
    pub count: u64,
    ///< Maximum size of trace (frames or bytes).
    pub size: u64,
    ///< Trigger delay.
    pub trigger_delay: u64,
    ///< Accuracy of timestamping in percent (0 to 100).
    pub timestamp_accuracy: u8,
    ///< Timestamp is in picoseconds.
    pub timestamp_is_time: mcd_bool_t,
    ///< Implementation specific options.
    pub options: u32,
    ///< Settings have been modified by implementation.
    pub modified: mcd_bool_t,
    ///< Optional description of the trace state.
    pub info_str: [mcd_char_t; 256usize],
}
#[test]
fn bindgen_test_layout_mcd_trace_state_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_trace_state_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_trace_state_st>(),
        320usize,
        concat!("Size of: ", stringify!(mcd_trace_state_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_trace_state_st>(),
        8usize,
        concat!("Alignment of ", stringify!(mcd_trace_state_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_state_st),
        "::",
        stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_state_st),
        "::",
        stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).autoarm) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_state_st),
        "::",
        stringify!(autoarm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wraparound) as usize - ptr as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_state_st),
        "::",
        stringify!(wraparound)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frames) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_state_st),
        "::",
        stringify!(frames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_state_st),
        "::",
        stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_state_st),
        "::",
        stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trigger_delay) as usize - ptr as usize },
        40usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_state_st),
        "::",
        stringify!(trigger_delay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp_accuracy) as usize - ptr as usize },
        48usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_state_st),
        "::",
        stringify!(timestamp_accuracy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp_is_time) as usize - ptr as usize },
        52usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_state_st),
        "::",
        stringify!(timestamp_is_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
        56usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_state_st),
        "::",
        stringify!(options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modified) as usize - ptr as usize },
        60usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_state_st),
        "::",
        stringify!(modified)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info_str) as usize - ptr as usize },
        64usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_state_st),
        "::",
        stringify!(info_str)
        )
    );
}
impl Default for mcd_trace_state_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/// \brief Structure type containing simple core trace data.
///
///This structure type contains simple trace data of cores and buses.
///
///A detailed description for a few member fields of \ref mcd_trace_data_core_st is provided below:
///- \c data_width            : Data width (in bytes), zero if \c data_mask is used.
///- \c data_mask             : Data bitmask, set bits indicate that the related byte in "data" is valid.
///Zero if \c data_width is used.
///- \c source                : Additional source information (hardware thread ID, bus initiator, etc.).
///- \c aux_info              : Auxiliary information, e.g. endianess, burst information or core execution mode.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcd_trace_data_core_st {
    ///< Timestamp of this cycle (picoseconds or clock cycles).
    pub timestamp: u64,
    ///< Markers for this cycle.
    pub marker: mcd_trace_marker_et,
    ///< Basic cycle type.
    pub cycle: mcd_trace_cycle_et,
    ///< Address.
    pub addr: mcd_addr_st,
    ///< Data (code length for program flow).
    pub data: u64,
    ///< Width of data (in bytes).
    pub data_width: u8,
    ///< Bitmask for valid bytes in \c data.
    pub data_mask: u8,
    ///< Additional source information.
    pub source: u16,
    ///< Auxiliary information.
    pub aux_info: u32,
}
#[test]
fn bindgen_test_layout_mcd_trace_data_core_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_trace_data_core_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_trace_data_core_st>(),
        56usize,
        concat!("Size of: ", stringify!(mcd_trace_data_core_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_trace_data_core_st>(),
        8usize,
        concat!("Alignment of ", stringify!(mcd_trace_data_core_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_data_core_st),
        "::",
        stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).marker) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_data_core_st),
        "::",
        stringify!(marker)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cycle) as usize - ptr as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_data_core_st),
        "::",
        stringify!(cycle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_data_core_st),
        "::",
        stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        40usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_data_core_st),
        "::",
        stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_width) as usize - ptr as usize },
        48usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_data_core_st),
        "::",
        stringify!(data_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_mask) as usize - ptr as usize },
        49usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_data_core_st),
        "::",
        stringify!(data_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        50usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_data_core_st),
        "::",
        stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aux_info) as usize - ptr as usize },
        52usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_data_core_st),
        "::",
        stringify!(aux_info)
        )
    );
}
/// \brief Structure type containing logic analyzer trace data.
///
///This structure type contains "logic analyzer"-like trace data (256 channels).
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcd_trace_data_event_st {
    ///< Timestamp of this cycle (either picoseconds or clock cycles).
    pub timestamp: u64,
    ///< Markers for this cycle.
    pub marker: mcd_trace_marker_et,
    ///< User data, array of 256 bits. LSB of data[0] represents channel 0.
    pub data: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_mcd_trace_data_event_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_trace_data_event_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_trace_data_event_st>(),
        48usize,
        concat!("Size of: ", stringify!(mcd_trace_data_event_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_trace_data_event_st>(),
        8usize,
        concat!("Alignment of ", stringify!(mcd_trace_data_event_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_data_event_st),
        "::",
        stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).marker) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_data_event_st),
        "::",
        stringify!(marker)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_data_event_st),
        "::",
        stringify!(data)
        )
    );
}
/// \brief Structure type containing statistic counter data.
///
///This structure type contains "logic analyzer"-like trace data (8 channels).
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcd_trace_data_stat_st {
    ///< Timestamp of this cycle (either picoseconds or clock cycles).
    pub timestamp: u64,
    ///< Markers for this cycle.
    pub marker: mcd_trace_marker_et,
    ///< Array of 8 statistic counters ('-1' represents an invalid value).
    pub count: [u64; 8usize],
}
#[test]
fn bindgen_test_layout_mcd_trace_data_stat_st() {
    const UNINIT: ::std::mem::MaybeUninit<mcd_trace_data_stat_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcd_trace_data_stat_st>(),
        80usize,
        concat!("Size of: ", stringify!(mcd_trace_data_stat_st))
    );
    assert_eq!(
        ::std::mem::align_of::<mcd_trace_data_stat_st>(),
        8usize,
        concat!("Alignment of ", stringify!(mcd_trace_data_stat_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_data_stat_st),
        "::",
        stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).marker) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_data_stat_st),
        "::",
        stringify!(marker)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(mcd_trace_data_stat_st),
        "::",
        stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
extern crate libloading;
pub struct DynamicMCDxDAS {
    __library: ::libloading::Library,
    pub __va_start: Result<
        unsafe extern "C" fn(arg1: *mut *mut ::std::os::raw::c_char, ...),
        ::libloading::Error,
    >,
    pub __security_init_cookie: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub __security_check_cookie:
    Result<unsafe extern "C" fn(_StackCookie: usize), ::libloading::Error>,
    pub __report_gsfailure:
    Result<unsafe extern "C" fn(_StackCookie: usize) -> !, ::libloading::Error>,
    pub _invalid_parameter_noinfo: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub _invalid_parameter_noinfo_noreturn:
    Result<unsafe extern "C" fn() -> !, ::libloading::Error>,
    pub _invoke_watson: Result<
        unsafe extern "C" fn(
            arg1: *const wchar_t,
            arg2: *const wchar_t,
            arg3: *const wchar_t,
            arg4: ::std::os::raw::c_uint,
            arg5: usize,
        ) -> !,
        ::libloading::Error,
    >,
    pub _calloc_base: Result<
        unsafe extern "C" fn(_Count: usize, _Size: usize) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub calloc: Result<
        unsafe extern "C" fn(
            _Count: ::std::os::raw::c_ulonglong,
            _Size: ::std::os::raw::c_ulonglong,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub _callnewh:
    Result<unsafe extern "C" fn(_Size: usize) -> ::std::os::raw::c_int, ::libloading::Error>,
    pub _expand: Result<
        unsafe extern "C" fn(
            _Block: *mut ::std::os::raw::c_void,
            _Size: usize,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub _free_base:
    Result<unsafe extern "C" fn(_Block: *mut ::std::os::raw::c_void), ::libloading::Error>,
    pub free:
    Result<unsafe extern "C" fn(_Block: *mut ::std::os::raw::c_void), ::libloading::Error>,
    pub _malloc_base: Result<
        unsafe extern "C" fn(_Size: usize) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub malloc: Result<
        unsafe extern "C" fn(_Size: ::std::os::raw::c_ulonglong) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub _msize: Result<
        unsafe extern "C" fn(_Block: *mut ::std::os::raw::c_void) -> usize,
        ::libloading::Error,
    >,
    pub _realloc_base: Result<
        unsafe extern "C" fn(
            _Block: *mut ::std::os::raw::c_void,
            _Size: usize,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub realloc: Result<
        unsafe extern "C" fn(
            _Block: *mut ::std::os::raw::c_void,
            _Size: ::std::os::raw::c_ulonglong,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub _recalloc: Result<
        unsafe extern "C" fn(
            _Block: *mut ::std::os::raw::c_void,
            _Count: usize,
            _Size: usize,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub _aligned_free:
    Result<unsafe extern "C" fn(_Block: *mut ::std::os::raw::c_void), ::libloading::Error>,
    pub _aligned_malloc: Result<
        unsafe extern "C" fn(_Size: usize, _Alignment: usize) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub _aligned_offset_malloc: Result<
        unsafe extern "C" fn(
            _Size: usize,
            _Alignment: usize,
            _Offset: usize,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub _aligned_msize: Result<
        unsafe extern "C" fn(
            _Block: *mut ::std::os::raw::c_void,
            _Alignment: usize,
            _Offset: usize,
        ) -> usize,
        ::libloading::Error,
    >,
    pub _aligned_offset_realloc: Result<
        unsafe extern "C" fn(
            _Block: *mut ::std::os::raw::c_void,
            _Size: usize,
            _Alignment: usize,
            _Offset: usize,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub _aligned_offset_recalloc: Result<
        unsafe extern "C" fn(
            _Block: *mut ::std::os::raw::c_void,
            _Count: usize,
            _Size: usize,
            _Alignment: usize,
            _Offset: usize,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub _aligned_realloc: Result<
        unsafe extern "C" fn(
            _Block: *mut ::std::os::raw::c_void,
            _Size: usize,
            _Alignment: usize,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub _aligned_recalloc: Result<
        unsafe extern "C" fn(
            _Block: *mut ::std::os::raw::c_void,
            _Count: usize,
            _Size: usize,
            _Alignment: usize,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub _errno: Result<unsafe extern "C" fn() -> *mut ::std::os::raw::c_int, ::libloading::Error>,
    pub _set_errno:
    Result<unsafe extern "C" fn(_Value: ::std::os::raw::c_int) -> errno_t, ::libloading::Error>,
    pub _get_errno: Result<
        unsafe extern "C" fn(_Value: *mut ::std::os::raw::c_int) -> errno_t,
        ::libloading::Error,
    >,
    pub __threadid: Result<unsafe extern "C" fn() -> ::std::os::raw::c_ulong, ::libloading::Error>,
    pub __threadhandle: Result<unsafe extern "C" fn() -> usize, ::libloading::Error>,
    pub bsearch_s: Result<
        unsafe extern "C" fn(
            _Key: *const ::std::os::raw::c_void,
            _Base: *const ::std::os::raw::c_void,
            _NumOfElements: rsize_t,
            _SizeOfElements: rsize_t,
            _PtFuncCompare: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: *const ::std::os::raw::c_void,
                    arg3: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
            _Context: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub qsort_s: Result<
        unsafe extern "C" fn(
            _Base: *mut ::std::os::raw::c_void,
            _NumOfElements: rsize_t,
            _SizeOfElements: rsize_t,
            _PtFuncCompare: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: *const ::std::os::raw::c_void,
                    arg3: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
            _Context: *mut ::std::os::raw::c_void,
        ),
        ::libloading::Error,
    >,
    pub bsearch: Result<
        unsafe extern "C" fn(
            _Key: *const ::std::os::raw::c_void,
            _Base: *const ::std::os::raw::c_void,
            _NumOfElements: usize,
            _SizeOfElements: usize,
            _PtFuncCompare: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *const ::std::os::raw::c_void,
                    arg2: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub qsort: Result<
        unsafe extern "C" fn(
            _Base: *mut ::std::os::raw::c_void,
            _NumOfElements: usize,
            _SizeOfElements: usize,
            _PtFuncCompare: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *const ::std::os::raw::c_void,
                    arg2: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
        ),
        ::libloading::Error,
    >,
    pub _lfind_s: Result<
        unsafe extern "C" fn(
            _Key: *const ::std::os::raw::c_void,
            _Base: *const ::std::os::raw::c_void,
            _NumOfElements: *mut ::std::os::raw::c_uint,
            _SizeOfElements: usize,
            _PtFuncCompare: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: *const ::std::os::raw::c_void,
                    arg3: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
            _Context: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub _lfind: Result<
        unsafe extern "C" fn(
            _Key: *const ::std::os::raw::c_void,
            _Base: *const ::std::os::raw::c_void,
            _NumOfElements: *mut ::std::os::raw::c_uint,
            _SizeOfElements: ::std::os::raw::c_uint,
            _PtFuncCompare: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *const ::std::os::raw::c_void,
                    arg2: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub _lsearch_s: Result<
        unsafe extern "C" fn(
            _Key: *const ::std::os::raw::c_void,
            _Base: *mut ::std::os::raw::c_void,
            _NumOfElements: *mut ::std::os::raw::c_uint,
            _SizeOfElements: usize,
            _PtFuncCompare: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: *const ::std::os::raw::c_void,
                    arg3: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
            _Context: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub _lsearch: Result<
        unsafe extern "C" fn(
            _Key: *const ::std::os::raw::c_void,
            _Base: *mut ::std::os::raw::c_void,
            _NumOfElements: *mut ::std::os::raw::c_uint,
            _SizeOfElements: ::std::os::raw::c_uint,
            _PtFuncCompare: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *const ::std::os::raw::c_void,
                    arg2: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub lfind: Result<
        unsafe extern "C" fn(
            _Key: *const ::std::os::raw::c_void,
            _Base: *const ::std::os::raw::c_void,
            _NumOfElements: *mut ::std::os::raw::c_uint,
            _SizeOfElements: ::std::os::raw::c_uint,
            _PtFuncCompare: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *const ::std::os::raw::c_void,
                    arg2: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub lsearch: Result<
        unsafe extern "C" fn(
            _Key: *const ::std::os::raw::c_void,
            _Base: *mut ::std::os::raw::c_void,
            _NumOfElements: *mut ::std::os::raw::c_uint,
            _SizeOfElements: ::std::os::raw::c_uint,
            _PtFuncCompare: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *const ::std::os::raw::c_void,
                    arg2: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub _itow_s: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_int,
            _Buffer: *mut wchar_t,
            _BufferCount: usize,
            _Radix: ::std::os::raw::c_int,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub _itow: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_int,
            _Buffer: *mut wchar_t,
            _Radix: ::std::os::raw::c_int,
        ) -> *mut wchar_t,
        ::libloading::Error,
    >,
    pub _ltow_s: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_long,
            _Buffer: *mut wchar_t,
            _BufferCount: usize,
            _Radix: ::std::os::raw::c_int,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub _ltow: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_long,
            _Buffer: *mut wchar_t,
            _Radix: ::std::os::raw::c_int,
        ) -> *mut wchar_t,
        ::libloading::Error,
    >,
    pub _ultow_s: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_ulong,
            _Buffer: *mut wchar_t,
            _BufferCount: usize,
            _Radix: ::std::os::raw::c_int,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub _ultow: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_ulong,
            _Buffer: *mut wchar_t,
            _Radix: ::std::os::raw::c_int,
        ) -> *mut wchar_t,
        ::libloading::Error,
    >,
    pub wcstod: Result<
        unsafe extern "C" fn(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64,
        ::libloading::Error,
    >,
    pub _wcstod_l: Result<
        unsafe extern "C" fn(
            _String: *const wchar_t,
            _EndPtr: *mut *mut wchar_t,
            _Locale: _locale_t,
        ) -> f64,
        ::libloading::Error,
    >,
    pub wcstol: Result<
        unsafe extern "C" fn(
            _String: *const wchar_t,
            _EndPtr: *mut *mut wchar_t,
            _Radix: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_long,
        ::libloading::Error,
    >,
    pub _wcstol_l: Result<
        unsafe extern "C" fn(
            _String: *const wchar_t,
            _EndPtr: *mut *mut wchar_t,
            _Radix: ::std::os::raw::c_int,
            _Locale: _locale_t,
        ) -> ::std::os::raw::c_long,
        ::libloading::Error,
    >,
    pub wcstoll: Result<
        unsafe extern "C" fn(
            _String: *const wchar_t,
            _EndPtr: *mut *mut wchar_t,
            _Radix: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_longlong,
        ::libloading::Error,
    >,
    pub _wcstoll_l: Result<
        unsafe extern "C" fn(
            _String: *const wchar_t,
            _EndPtr: *mut *mut wchar_t,
            _Radix: ::std::os::raw::c_int,
            _Locale: _locale_t,
        ) -> ::std::os::raw::c_longlong,
        ::libloading::Error,
    >,
    pub wcstoul: Result<
        unsafe extern "C" fn(
            _String: *const wchar_t,
            _EndPtr: *mut *mut wchar_t,
            _Radix: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulong,
        ::libloading::Error,
    >,
    pub _wcstoul_l: Result<
        unsafe extern "C" fn(
            _String: *const wchar_t,
            _EndPtr: *mut *mut wchar_t,
            _Radix: ::std::os::raw::c_int,
            _Locale: _locale_t,
        ) -> ::std::os::raw::c_ulong,
        ::libloading::Error,
    >,
    pub wcstoull: Result<
        unsafe extern "C" fn(
            _String: *const wchar_t,
            _EndPtr: *mut *mut wchar_t,
            _Radix: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulonglong,
        ::libloading::Error,
    >,
    pub _wcstoull_l: Result<
        unsafe extern "C" fn(
            _String: *const wchar_t,
            _EndPtr: *mut *mut wchar_t,
            _Radix: ::std::os::raw::c_int,
            _Locale: _locale_t,
        ) -> ::std::os::raw::c_ulonglong,
        ::libloading::Error,
    >,
    pub wcstold: Result<
        unsafe extern "C" fn(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64,
        ::libloading::Error,
    >,
    pub _wcstold_l: Result<
        unsafe extern "C" fn(
            _String: *const wchar_t,
            _EndPtr: *mut *mut wchar_t,
            _Locale: _locale_t,
        ) -> f64,
        ::libloading::Error,
    >,
    pub wcstof: Result<
        unsafe extern "C" fn(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f32,
        ::libloading::Error,
    >,
    pub _wcstof_l: Result<
        unsafe extern "C" fn(
            _String: *const wchar_t,
            _EndPtr: *mut *mut wchar_t,
            _Locale: _locale_t,
        ) -> f32,
        ::libloading::Error,
    >,
    pub _wtof: Result<unsafe extern "C" fn(_String: *const wchar_t) -> f64, ::libloading::Error>,
    pub _wtof_l: Result<
        unsafe extern "C" fn(_String: *const wchar_t, _Locale: _locale_t) -> f64,
        ::libloading::Error,
    >,
    pub _wtoi: Result<
        unsafe extern "C" fn(_String: *const wchar_t) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub _wtoi_l: Result<
        unsafe extern "C" fn(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub _wtol: Result<
        unsafe extern "C" fn(_String: *const wchar_t) -> ::std::os::raw::c_long,
        ::libloading::Error,
    >,
    pub _wtol_l: Result<
        unsafe extern "C" fn(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_long,
        ::libloading::Error,
    >,
    pub _wtoll: Result<
        unsafe extern "C" fn(_String: *const wchar_t) -> ::std::os::raw::c_longlong,
        ::libloading::Error,
    >,
    pub _wtoll_l: Result<
        unsafe extern "C" fn(
            _String: *const wchar_t,
            _Locale: _locale_t,
        ) -> ::std::os::raw::c_longlong,
        ::libloading::Error,
    >,
    pub _i64tow_s: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_longlong,
            _Buffer: *mut wchar_t,
            _BufferCount: usize,
            _Radix: ::std::os::raw::c_int,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub _i64tow: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_longlong,
            _Buffer: *mut wchar_t,
            _Radix: ::std::os::raw::c_int,
        ) -> *mut wchar_t,
        ::libloading::Error,
    >,
    pub _ui64tow_s: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_ulonglong,
            _Buffer: *mut wchar_t,
            _BufferCount: usize,
            _Radix: ::std::os::raw::c_int,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub _ui64tow: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_ulonglong,
            _Buffer: *mut wchar_t,
            _Radix: ::std::os::raw::c_int,
        ) -> *mut wchar_t,
        ::libloading::Error,
    >,
    pub _wtoi64: Result<
        unsafe extern "C" fn(_String: *const wchar_t) -> ::std::os::raw::c_longlong,
        ::libloading::Error,
    >,
    pub _wtoi64_l: Result<
        unsafe extern "C" fn(
            _String: *const wchar_t,
            _Locale: _locale_t,
        ) -> ::std::os::raw::c_longlong,
        ::libloading::Error,
    >,
    pub _wcstoi64: Result<
        unsafe extern "C" fn(
            _String: *const wchar_t,
            _EndPtr: *mut *mut wchar_t,
            _Radix: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_longlong,
        ::libloading::Error,
    >,
    pub _wcstoi64_l: Result<
        unsafe extern "C" fn(
            _String: *const wchar_t,
            _EndPtr: *mut *mut wchar_t,
            _Radix: ::std::os::raw::c_int,
            _Locale: _locale_t,
        ) -> ::std::os::raw::c_longlong,
        ::libloading::Error,
    >,
    pub _wcstoui64: Result<
        unsafe extern "C" fn(
            _String: *const wchar_t,
            _EndPtr: *mut *mut wchar_t,
            _Radix: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulonglong,
        ::libloading::Error,
    >,
    pub _wcstoui64_l: Result<
        unsafe extern "C" fn(
            _String: *const wchar_t,
            _EndPtr: *mut *mut wchar_t,
            _Radix: ::std::os::raw::c_int,
            _Locale: _locale_t,
        ) -> ::std::os::raw::c_ulonglong,
        ::libloading::Error,
    >,
    pub _wfullpath: Result<
        unsafe extern "C" fn(
            _Buffer: *mut wchar_t,
            _Path: *const wchar_t,
            _BufferCount: usize,
        ) -> *mut wchar_t,
        ::libloading::Error,
    >,
    pub _wmakepath_s: Result<
        unsafe extern "C" fn(
            _Buffer: *mut wchar_t,
            _BufferCount: usize,
            _Drive: *const wchar_t,
            _Dir: *const wchar_t,
            _Filename: *const wchar_t,
            _Ext: *const wchar_t,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub _wmakepath: Result<
        unsafe extern "C" fn(
            _Buffer: *mut wchar_t,
            _Drive: *const wchar_t,
            _Dir: *const wchar_t,
            _Filename: *const wchar_t,
            _Ext: *const wchar_t,
        ),
        ::libloading::Error,
    >,
    pub _wperror: Result<unsafe extern "C" fn(_ErrMsg: *const wchar_t), ::libloading::Error>,
    pub _wsplitpath: Result<
        unsafe extern "C" fn(
            _FullPath: *const wchar_t,
            _Drive: *mut wchar_t,
            _Dir: *mut wchar_t,
            _Filename: *mut wchar_t,
            _Ext: *mut wchar_t,
        ),
        ::libloading::Error,
    >,
    pub _wsplitpath_s: Result<
        unsafe extern "C" fn(
            _FullPath: *const wchar_t,
            _Drive: *mut wchar_t,
            _DriveCount: usize,
            _Dir: *mut wchar_t,
            _DirCount: usize,
            _Filename: *mut wchar_t,
            _FilenameCount: usize,
            _Ext: *mut wchar_t,
            _ExtCount: usize,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub _wdupenv_s: Result<
        unsafe extern "C" fn(
            _Buffer: *mut *mut wchar_t,
            _BufferCount: *mut usize,
            _VarName: *const wchar_t,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub _wgetenv:
    Result<unsafe extern "C" fn(_VarName: *const wchar_t) -> *mut wchar_t, ::libloading::Error>,
    pub _wgetenv_s: Result<
        unsafe extern "C" fn(
            _RequiredCount: *mut usize,
            _Buffer: *mut wchar_t,
            _BufferCount: usize,
            _VarName: *const wchar_t,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub _wputenv: Result<
        unsafe extern "C" fn(_EnvString: *const wchar_t) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub _wputenv_s: Result<
        unsafe extern "C" fn(_Name: *const wchar_t, _Value: *const wchar_t) -> errno_t,
        ::libloading::Error,
    >,
    pub _wsearchenv_s: Result<
        unsafe extern "C" fn(
            _Filename: *const wchar_t,
            _VarName: *const wchar_t,
            _Buffer: *mut wchar_t,
            _BufferCount: usize,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub _wsearchenv: Result<
        unsafe extern "C" fn(
            _Filename: *const wchar_t,
            _VarName: *const wchar_t,
            _ResultPath: *mut wchar_t,
        ),
        ::libloading::Error,
    >,
    pub _wsystem: Result<
        unsafe extern "C" fn(_Command: *const wchar_t) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub _swab: Result<
        unsafe extern "C" fn(
            _Buf1: *mut ::std::os::raw::c_char,
            _Buf2: *mut ::std::os::raw::c_char,
            _SizeInBytes: ::std::os::raw::c_int,
        ),
        ::libloading::Error,
    >,
    pub exit: Result<unsafe extern "C" fn(_Code: ::std::os::raw::c_int) -> !, ::libloading::Error>,
    pub _exit: Result<unsafe extern "C" fn(_Code: ::std::os::raw::c_int) -> !, ::libloading::Error>,
    pub _Exit: Result<unsafe extern "C" fn(_Code: ::std::os::raw::c_int) -> !, ::libloading::Error>,
    pub quick_exit:
    Result<unsafe extern "C" fn(_Code: ::std::os::raw::c_int) -> !, ::libloading::Error>,
    pub abort: Result<unsafe extern "C" fn() -> !, ::libloading::Error>,
    pub _set_abort_behavior: Result<
        unsafe extern "C" fn(
            _Flags: ::std::os::raw::c_uint,
            _Mask: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub atexit: Result<
        unsafe extern "C" fn(
            arg1: ::std::option::Option<unsafe extern "C" fn()>,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub _onexit: Result<unsafe extern "C" fn(_Func: _onexit_t) -> _onexit_t, ::libloading::Error>,
    pub at_quick_exit: Result<
        unsafe extern "C" fn(
            arg1: ::std::option::Option<unsafe extern "C" fn()>,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub _set_purecall_handler: Result<
        unsafe extern "C" fn(_Handler: _purecall_handler) -> _purecall_handler,
        ::libloading::Error,
    >,
    pub _get_purecall_handler:
    Result<unsafe extern "C" fn() -> _purecall_handler, ::libloading::Error>,
    pub _set_invalid_parameter_handler: Result<
        unsafe extern "C" fn(_Handler: _invalid_parameter_handler) -> _invalid_parameter_handler,
        ::libloading::Error,
    >,
    pub _get_invalid_parameter_handler:
    Result<unsafe extern "C" fn() -> _invalid_parameter_handler, ::libloading::Error>,
    pub _set_thread_local_invalid_parameter_handler: Result<
        unsafe extern "C" fn(_Handler: _invalid_parameter_handler) -> _invalid_parameter_handler,
        ::libloading::Error,
    >,
    pub _get_thread_local_invalid_parameter_handler:
    Result<unsafe extern "C" fn() -> _invalid_parameter_handler, ::libloading::Error>,
    pub _set_error_mode: Result<
        unsafe extern "C" fn(_Mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub __doserrno:
    Result<unsafe extern "C" fn() -> *mut ::std::os::raw::c_ulong, ::libloading::Error>,
    pub _set_doserrno: Result<
        unsafe extern "C" fn(_Value: ::std::os::raw::c_ulong) -> errno_t,
        ::libloading::Error,
    >,
    pub _get_doserrno: Result<
        unsafe extern "C" fn(_Value: *mut ::std::os::raw::c_ulong) -> errno_t,
        ::libloading::Error,
    >,
    pub __sys_errlist:
    Result<unsafe extern "C" fn() -> *mut *mut ::std::os::raw::c_char, ::libloading::Error>,
    pub __sys_nerr:
    Result<unsafe extern "C" fn() -> *mut ::std::os::raw::c_int, ::libloading::Error>,
    pub perror:
    Result<unsafe extern "C" fn(_ErrMsg: *const ::std::os::raw::c_char), ::libloading::Error>,
    pub __p__pgmptr:
    Result<unsafe extern "C" fn() -> *mut *mut ::std::os::raw::c_char, ::libloading::Error>,
    pub __p__wpgmptr: Result<unsafe extern "C" fn() -> *mut *mut wchar_t, ::libloading::Error>,
    pub __p__fmode:
    Result<unsafe extern "C" fn() -> *mut ::std::os::raw::c_int, ::libloading::Error>,
    pub _get_pgmptr: Result<
        unsafe extern "C" fn(_Value: *mut *mut ::std::os::raw::c_char) -> errno_t,
        ::libloading::Error,
    >,
    pub _get_wpgmptr:
    Result<unsafe extern "C" fn(_Value: *mut *mut wchar_t) -> errno_t, ::libloading::Error>,
    pub _set_fmode:
    Result<unsafe extern "C" fn(_Mode: ::std::os::raw::c_int) -> errno_t, ::libloading::Error>,
    pub _get_fmode: Result<
        unsafe extern "C" fn(_PMode: *mut ::std::os::raw::c_int) -> errno_t,
        ::libloading::Error,
    >,
    pub abs: Result<
        unsafe extern "C" fn(_Number: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub labs: Result<
        unsafe extern "C" fn(_Number: ::std::os::raw::c_long) -> ::std::os::raw::c_long,
        ::libloading::Error,
    >,
    pub llabs: Result<
        unsafe extern "C" fn(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong,
        ::libloading::Error,
    >,
    pub _abs64: Result<
        unsafe extern "C" fn(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong,
        ::libloading::Error,
    >,
    pub _byteswap_ushort: Result<
        unsafe extern "C" fn(_Number: ::std::os::raw::c_ushort) -> ::std::os::raw::c_ushort,
        ::libloading::Error,
    >,
    pub _byteswap_ulong: Result<
        unsafe extern "C" fn(_Number: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong,
        ::libloading::Error,
    >,
    pub _byteswap_uint64: Result<
        unsafe extern "C" fn(_Number: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_ulonglong,
        ::libloading::Error,
    >,
    pub div: Result<
        unsafe extern "C" fn(
            _Numerator: ::std::os::raw::c_int,
            _Denominator: ::std::os::raw::c_int,
        ) -> div_t,
        ::libloading::Error,
    >,
    pub ldiv: Result<
        unsafe extern "C" fn(
            _Numerator: ::std::os::raw::c_long,
            _Denominator: ::std::os::raw::c_long,
        ) -> ldiv_t,
        ::libloading::Error,
    >,
    pub lldiv: Result<
        unsafe extern "C" fn(
            _Numerator: ::std::os::raw::c_longlong,
            _Denominator: ::std::os::raw::c_longlong,
        ) -> lldiv_t,
        ::libloading::Error,
    >,
    pub _rotl: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_uint,
            _Shift: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub _lrotl: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_ulong,
            _Shift: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulong,
        ::libloading::Error,
    >,
    pub _rotl64: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_ulonglong,
            _Shift: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulonglong,
        ::libloading::Error,
    >,
    pub _rotr: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_uint,
            _Shift: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub _lrotr: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_ulong,
            _Shift: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulong,
        ::libloading::Error,
    >,
    pub _rotr64: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_ulonglong,
            _Shift: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulonglong,
        ::libloading::Error,
    >,
    pub srand: Result<unsafe extern "C" fn(_Seed: ::std::os::raw::c_uint), ::libloading::Error>,
    pub rand: Result<unsafe extern "C" fn() -> ::std::os::raw::c_int, ::libloading::Error>,
    pub atof: Result<
        unsafe extern "C" fn(_String: *const ::std::os::raw::c_char) -> f64,
        ::libloading::Error,
    >,
    pub atoi: Result<
        unsafe extern "C" fn(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub atol: Result<
        unsafe extern "C" fn(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long,
        ::libloading::Error,
    >,
    pub atoll: Result<
        unsafe extern "C" fn(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong,
        ::libloading::Error,
    >,
    pub _atoi64: Result<
        unsafe extern "C" fn(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong,
        ::libloading::Error,
    >,
    pub _atof_l: Result<
        unsafe extern "C" fn(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> f64,
        ::libloading::Error,
    >,
    pub _atoi_l: Result<
        unsafe extern "C" fn(
            _String: *const ::std::os::raw::c_char,
            _Locale: _locale_t,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub _atol_l: Result<
        unsafe extern "C" fn(
            _String: *const ::std::os::raw::c_char,
            _Locale: _locale_t,
        ) -> ::std::os::raw::c_long,
        ::libloading::Error,
    >,
    pub _atoll_l: Result<
        unsafe extern "C" fn(
            _String: *const ::std::os::raw::c_char,
            _Locale: _locale_t,
        ) -> ::std::os::raw::c_longlong,
        ::libloading::Error,
    >,
    pub _atoi64_l: Result<
        unsafe extern "C" fn(
            _String: *const ::std::os::raw::c_char,
            _Locale: _locale_t,
        ) -> ::std::os::raw::c_longlong,
        ::libloading::Error,
    >,
    pub _atoflt: Result<
        unsafe extern "C" fn(
            _Result: *mut _CRT_FLOAT,
            _String: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub _atodbl: Result<
        unsafe extern "C" fn(
            _Result: *mut _CRT_DOUBLE,
            _String: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub _atoldbl: Result<
        unsafe extern "C" fn(
            _Result: *mut _LDOUBLE,
            _String: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub _atoflt_l: Result<
        unsafe extern "C" fn(
            _Result: *mut _CRT_FLOAT,
            _String: *const ::std::os::raw::c_char,
            _Locale: _locale_t,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub _atodbl_l: Result<
        unsafe extern "C" fn(
            _Result: *mut _CRT_DOUBLE,
            _String: *mut ::std::os::raw::c_char,
            _Locale: _locale_t,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub _atoldbl_l: Result<
        unsafe extern "C" fn(
            _Result: *mut _LDOUBLE,
            _String: *mut ::std::os::raw::c_char,
            _Locale: _locale_t,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub strtof: Result<
        unsafe extern "C" fn(
            _String: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
        ) -> f32,
        ::libloading::Error,
    >,
    pub _strtof_l: Result<
        unsafe extern "C" fn(
            _String: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
            _Locale: _locale_t,
        ) -> f32,
        ::libloading::Error,
    >,
    pub strtod: Result<
        unsafe extern "C" fn(
            _String: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
        ) -> f64,
        ::libloading::Error,
    >,
    pub _strtod_l: Result<
        unsafe extern "C" fn(
            _String: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
            _Locale: _locale_t,
        ) -> f64,
        ::libloading::Error,
    >,
    pub strtold: Result<
        unsafe extern "C" fn(
            _String: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
        ) -> f64,
        ::libloading::Error,
    >,
    pub _strtold_l: Result<
        unsafe extern "C" fn(
            _String: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
            _Locale: _locale_t,
        ) -> f64,
        ::libloading::Error,
    >,
    pub strtol: Result<
        unsafe extern "C" fn(
            _String: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_long,
        ::libloading::Error,
    >,
    pub _strtol_l: Result<
        unsafe extern "C" fn(
            _String: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
            _Locale: _locale_t,
        ) -> ::std::os::raw::c_long,
        ::libloading::Error,
    >,
    pub strtoll: Result<
        unsafe extern "C" fn(
            _String: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_longlong,
        ::libloading::Error,
    >,
    pub _strtoll_l: Result<
        unsafe extern "C" fn(
            _String: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
            _Locale: _locale_t,
        ) -> ::std::os::raw::c_longlong,
        ::libloading::Error,
    >,
    pub strtoul: Result<
        unsafe extern "C" fn(
            _String: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulong,
        ::libloading::Error,
    >,
    pub _strtoul_l: Result<
        unsafe extern "C" fn(
            _String: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
            _Locale: _locale_t,
        ) -> ::std::os::raw::c_ulong,
        ::libloading::Error,
    >,
    pub strtoull: Result<
        unsafe extern "C" fn(
            _String: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulonglong,
        ::libloading::Error,
    >,
    pub _strtoull_l: Result<
        unsafe extern "C" fn(
            _String: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
            _Locale: _locale_t,
        ) -> ::std::os::raw::c_ulonglong,
        ::libloading::Error,
    >,
    pub _strtoi64: Result<
        unsafe extern "C" fn(
            _String: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_longlong,
        ::libloading::Error,
    >,
    pub _strtoi64_l: Result<
        unsafe extern "C" fn(
            _String: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
            _Locale: _locale_t,
        ) -> ::std::os::raw::c_longlong,
        ::libloading::Error,
    >,
    pub _strtoui64: Result<
        unsafe extern "C" fn(
            _String: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulonglong,
        ::libloading::Error,
    >,
    pub _strtoui64_l: Result<
        unsafe extern "C" fn(
            _String: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
            _Locale: _locale_t,
        ) -> ::std::os::raw::c_ulonglong,
        ::libloading::Error,
    >,
    pub _itoa_s: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_int,
            _Buffer: *mut ::std::os::raw::c_char,
            _BufferCount: usize,
            _Radix: ::std::os::raw::c_int,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub _itoa: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_int,
            _Buffer: *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub _ltoa_s: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_long,
            _Buffer: *mut ::std::os::raw::c_char,
            _BufferCount: usize,
            _Radix: ::std::os::raw::c_int,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub _ltoa: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_long,
            _Buffer: *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub _ultoa_s: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_ulong,
            _Buffer: *mut ::std::os::raw::c_char,
            _BufferCount: usize,
            _Radix: ::std::os::raw::c_int,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub _ultoa: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_ulong,
            _Buffer: *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub _i64toa_s: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_longlong,
            _Buffer: *mut ::std::os::raw::c_char,
            _BufferCount: usize,
            _Radix: ::std::os::raw::c_int,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub _i64toa: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_longlong,
            _Buffer: *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub _ui64toa_s: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_ulonglong,
            _Buffer: *mut ::std::os::raw::c_char,
            _BufferCount: usize,
            _Radix: ::std::os::raw::c_int,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub _ui64toa: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_ulonglong,
            _Buffer: *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub _ecvt_s: Result<
        unsafe extern "C" fn(
            _Buffer: *mut ::std::os::raw::c_char,
            _BufferCount: usize,
            _Value: f64,
            _DigitCount: ::std::os::raw::c_int,
            _PtDec: *mut ::std::os::raw::c_int,
            _PtSign: *mut ::std::os::raw::c_int,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub _ecvt: Result<
        unsafe extern "C" fn(
            _Value: f64,
            _DigitCount: ::std::os::raw::c_int,
            _PtDec: *mut ::std::os::raw::c_int,
            _PtSign: *mut ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub _fcvt_s: Result<
        unsafe extern "C" fn(
            _Buffer: *mut ::std::os::raw::c_char,
            _BufferCount: usize,
            _Value: f64,
            _FractionalDigitCount: ::std::os::raw::c_int,
            _PtDec: *mut ::std::os::raw::c_int,
            _PtSign: *mut ::std::os::raw::c_int,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub _fcvt: Result<
        unsafe extern "C" fn(
            _Value: f64,
            _FractionalDigitCount: ::std::os::raw::c_int,
            _PtDec: *mut ::std::os::raw::c_int,
            _PtSign: *mut ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub _gcvt_s: Result<
        unsafe extern "C" fn(
            _Buffer: *mut ::std::os::raw::c_char,
            _BufferCount: usize,
            _Value: f64,
            _DigitCount: ::std::os::raw::c_int,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub _gcvt: Result<
        unsafe extern "C" fn(
            _Value: f64,
            _DigitCount: ::std::os::raw::c_int,
            _Buffer: *mut ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub ___mb_cur_max_func:
    Result<unsafe extern "C" fn() -> ::std::os::raw::c_int, ::libloading::Error>,
    pub ___mb_cur_max_l_func:
    Result<unsafe extern "C" fn(arg1: _locale_t) -> ::std::os::raw::c_int, ::libloading::Error>,
    pub mblen: Result<
        unsafe extern "C" fn(
            _Ch: *const ::std::os::raw::c_char,
            _MaxCount: usize,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub _mblen_l: Result<
        unsafe extern "C" fn(
            _Ch: *const ::std::os::raw::c_char,
            _MaxCount: usize,
            _Locale: _locale_t,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub _mbstrlen: Result<
        unsafe extern "C" fn(_String: *const ::std::os::raw::c_char) -> usize,
        ::libloading::Error,
    >,
    pub _mbstrlen_l: Result<
        unsafe extern "C" fn(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> usize,
        ::libloading::Error,
    >,
    pub _mbstrnlen: Result<
        unsafe extern "C" fn(_String: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize,
        ::libloading::Error,
    >,
    pub _mbstrnlen_l: Result<
        unsafe extern "C" fn(
            _String: *const ::std::os::raw::c_char,
            _MaxCount: usize,
            _Locale: _locale_t,
        ) -> usize,
        ::libloading::Error,
    >,
    pub mbtowc: Result<
        unsafe extern "C" fn(
            _DstCh: *mut wchar_t,
            _SrcCh: *const ::std::os::raw::c_char,
            _SrcSizeInBytes: usize,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub _mbtowc_l: Result<
        unsafe extern "C" fn(
            _DstCh: *mut wchar_t,
            _SrcCh: *const ::std::os::raw::c_char,
            _SrcSizeInBytes: usize,
            _Locale: _locale_t,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub mbstowcs_s: Result<
        unsafe extern "C" fn(
            _PtNumOfCharConverted: *mut usize,
            _DstBuf: *mut wchar_t,
            _SizeInWords: usize,
            _SrcBuf: *const ::std::os::raw::c_char,
            _MaxCount: usize,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub mbstowcs: Result<
        unsafe extern "C" fn(
            _Dest: *mut wchar_t,
            _Source: *const ::std::os::raw::c_char,
            _MaxCount: usize,
        ) -> usize,
        ::libloading::Error,
    >,
    pub _mbstowcs_s_l: Result<
        unsafe extern "C" fn(
            _PtNumOfCharConverted: *mut usize,
            _DstBuf: *mut wchar_t,
            _SizeInWords: usize,
            _SrcBuf: *const ::std::os::raw::c_char,
            _MaxCount: usize,
            _Locale: _locale_t,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub _mbstowcs_l: Result<
        unsafe extern "C" fn(
            _Dest: *mut wchar_t,
            _Source: *const ::std::os::raw::c_char,
            _MaxCount: usize,
            _Locale: _locale_t,
        ) -> usize,
        ::libloading::Error,
    >,
    pub wctomb: Result<
        unsafe extern "C" fn(
            _MbCh: *mut ::std::os::raw::c_char,
            _WCh: wchar_t,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub _wctomb_l: Result<
        unsafe extern "C" fn(
            _MbCh: *mut ::std::os::raw::c_char,
            _WCh: wchar_t,
            _Locale: _locale_t,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub wctomb_s: Result<
        unsafe extern "C" fn(
            _SizeConverted: *mut ::std::os::raw::c_int,
            _MbCh: *mut ::std::os::raw::c_char,
            _SizeInBytes: rsize_t,
            _WCh: wchar_t,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub _wctomb_s_l: Result<
        unsafe extern "C" fn(
            _SizeConverted: *mut ::std::os::raw::c_int,
            _MbCh: *mut ::std::os::raw::c_char,
            _SizeInBytes: usize,
            _WCh: wchar_t,
            _Locale: _locale_t,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub wcstombs_s: Result<
        unsafe extern "C" fn(
            _PtNumOfCharConverted: *mut usize,
            _Dst: *mut ::std::os::raw::c_char,
            _DstSizeInBytes: usize,
            _Src: *const wchar_t,
            _MaxCountInBytes: usize,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub wcstombs: Result<
        unsafe extern "C" fn(
            _Dest: *mut ::std::os::raw::c_char,
            _Source: *const wchar_t,
            _MaxCount: usize,
        ) -> usize,
        ::libloading::Error,
    >,
    pub _wcstombs_s_l: Result<
        unsafe extern "C" fn(
            _PtNumOfCharConverted: *mut usize,
            _Dst: *mut ::std::os::raw::c_char,
            _DstSizeInBytes: usize,
            _Src: *const wchar_t,
            _MaxCountInBytes: usize,
            _Locale: _locale_t,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub _wcstombs_l: Result<
        unsafe extern "C" fn(
            _Dest: *mut ::std::os::raw::c_char,
            _Source: *const wchar_t,
            _MaxCount: usize,
            _Locale: _locale_t,
        ) -> usize,
        ::libloading::Error,
    >,
    pub _fullpath: Result<
        unsafe extern "C" fn(
            _Buffer: *mut ::std::os::raw::c_char,
            _Path: *const ::std::os::raw::c_char,
            _BufferCount: usize,
        ) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub _makepath_s: Result<
        unsafe extern "C" fn(
            _Buffer: *mut ::std::os::raw::c_char,
            _BufferCount: usize,
            _Drive: *const ::std::os::raw::c_char,
            _Dir: *const ::std::os::raw::c_char,
            _Filename: *const ::std::os::raw::c_char,
            _Ext: *const ::std::os::raw::c_char,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub _makepath: Result<
        unsafe extern "C" fn(
            _Buffer: *mut ::std::os::raw::c_char,
            _Drive: *const ::std::os::raw::c_char,
            _Dir: *const ::std::os::raw::c_char,
            _Filename: *const ::std::os::raw::c_char,
            _Ext: *const ::std::os::raw::c_char,
        ),
        ::libloading::Error,
    >,
    pub _splitpath: Result<
        unsafe extern "C" fn(
            _FullPath: *const ::std::os::raw::c_char,
            _Drive: *mut ::std::os::raw::c_char,
            _Dir: *mut ::std::os::raw::c_char,
            _Filename: *mut ::std::os::raw::c_char,
            _Ext: *mut ::std::os::raw::c_char,
        ),
        ::libloading::Error,
    >,
    pub _splitpath_s: Result<
        unsafe extern "C" fn(
            _FullPath: *const ::std::os::raw::c_char,
            _Drive: *mut ::std::os::raw::c_char,
            _DriveCount: usize,
            _Dir: *mut ::std::os::raw::c_char,
            _DirCount: usize,
            _Filename: *mut ::std::os::raw::c_char,
            _FilenameCount: usize,
            _Ext: *mut ::std::os::raw::c_char,
            _ExtCount: usize,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub getenv_s: Result<
        unsafe extern "C" fn(
            _RequiredCount: *mut usize,
            _Buffer: *mut ::std::os::raw::c_char,
            _BufferCount: rsize_t,
            _VarName: *const ::std::os::raw::c_char,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub __p___argc:
    Result<unsafe extern "C" fn() -> *mut ::std::os::raw::c_int, ::libloading::Error>,
    pub __p___argv: Result<
        unsafe extern "C" fn() -> *mut *mut *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub __p___wargv: Result<unsafe extern "C" fn() -> *mut *mut *mut wchar_t, ::libloading::Error>,
    pub __p__environ: Result<
        unsafe extern "C" fn() -> *mut *mut *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub __p__wenviron:
    Result<unsafe extern "C" fn() -> *mut *mut *mut wchar_t, ::libloading::Error>,
    pub getenv: Result<
        unsafe extern "C" fn(
            _VarName: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub _dupenv_s: Result<
        unsafe extern "C" fn(
            _Buffer: *mut *mut ::std::os::raw::c_char,
            _BufferCount: *mut usize,
            _VarName: *const ::std::os::raw::c_char,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub system: Result<
        unsafe extern "C" fn(_Command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub _putenv: Result<
        unsafe extern "C" fn(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub _putenv_s: Result<
        unsafe extern "C" fn(
            _Name: *const ::std::os::raw::c_char,
            _Value: *const ::std::os::raw::c_char,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub _searchenv_s: Result<
        unsafe extern "C" fn(
            _Filename: *const ::std::os::raw::c_char,
            _VarName: *const ::std::os::raw::c_char,
            _Buffer: *mut ::std::os::raw::c_char,
            _BufferCount: usize,
        ) -> errno_t,
        ::libloading::Error,
    >,
    pub _searchenv: Result<
        unsafe extern "C" fn(
            _Filename: *const ::std::os::raw::c_char,
            _VarName: *const ::std::os::raw::c_char,
            _Buffer: *mut ::std::os::raw::c_char,
        ),
        ::libloading::Error,
    >,
    pub _seterrormode:
    Result<unsafe extern "C" fn(_Mode: ::std::os::raw::c_int), ::libloading::Error>,
    pub _beep: Result<
        unsafe extern "C" fn(_Frequency: ::std::os::raw::c_uint, _Duration: ::std::os::raw::c_uint),
        ::libloading::Error,
    >,
    pub _sleep:
    Result<unsafe extern "C" fn(_Duration: ::std::os::raw::c_ulong), ::libloading::Error>,
    pub ecvt: Result<
        unsafe extern "C" fn(
            _Value: f64,
            _DigitCount: ::std::os::raw::c_int,
            _PtDec: *mut ::std::os::raw::c_int,
            _PtSign: *mut ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub fcvt: Result<
        unsafe extern "C" fn(
            _Value: f64,
            _FractionalDigitCount: ::std::os::raw::c_int,
            _PtDec: *mut ::std::os::raw::c_int,
            _PtSign: *mut ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub gcvt: Result<
        unsafe extern "C" fn(
            _Value: f64,
            _DigitCount: ::std::os::raw::c_int,
            _DstBuf: *mut ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub itoa: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_int,
            _Buffer: *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub ltoa: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_long,
            _Buffer: *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub swab: Result<
        unsafe extern "C" fn(
            _Buf1: *mut ::std::os::raw::c_char,
            _Buf2: *mut ::std::os::raw::c_char,
            _SizeInBytes: ::std::os::raw::c_int,
        ),
        ::libloading::Error,
    >,
    pub ultoa: Result<
        unsafe extern "C" fn(
            _Value: ::std::os::raw::c_ulong,
            _Buffer: *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub putenv: Result<
        unsafe extern "C" fn(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub onexit: Result<unsafe extern "C" fn(_Func: _onexit_t) -> _onexit_t, ::libloading::Error>,
    pub mcd_initialize_f: Result<
        unsafe extern "C" fn(
            version_req: *const mcd_api_version_st,
            impl_info: *mut mcd_impl_version_info_st,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_exit_f: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub mcd_qry_servers_f: Result<
        unsafe extern "C" fn(
            host: *const mcd_char_t,
            running: mcd_bool_t,
            start_index: u32,
            num_servers: *mut u32,
            server_info: *mut mcd_server_info_st,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_open_server_f: Result<
        unsafe extern "C" fn(
            system_key: *const mcd_char_t,
            config_string: *const mcd_char_t,
            server: *mut *mut mcd_server_st,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_close_server_f: Result<
        unsafe extern "C" fn(server: *const mcd_server_st) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_set_server_config_f: Result<
        unsafe extern "C" fn(
            server: *const mcd_server_st,
            config_string: *const mcd_char_t,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_qry_server_config_f: Result<
        unsafe extern "C" fn(
            server: *const mcd_server_st,
            max_len: *mut u32,
            config_string: *mut mcd_char_t,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_qry_systems_f: Result<
        unsafe extern "C" fn(
            start_index: u32,
            num_systems: *mut u32,
            system_con_info: *mut mcd_core_con_info_st,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_qry_devices_f: Result<
        unsafe extern "C" fn(
            system_con_info: *const mcd_core_con_info_st,
            start_index: u32,
            num_devices: *mut u32,
            device_con_info: *mut mcd_core_con_info_st,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_qry_cores_f: Result<
        unsafe extern "C" fn(
            connection_info: *const mcd_core_con_info_st,
            start_index: u32,
            num_cores: *mut u32,
            core_con_info: *mut mcd_core_con_info_st,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_qry_core_modes_f: Result<
        unsafe extern "C" fn(
            core: *const mcd_core_st,
            start_index: u32,
            num_modes: *mut u32,
            core_mode_info: *mut mcd_core_mode_info_st,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_open_core_f: Result<
        unsafe extern "C" fn(
            core_con_info: *const mcd_core_con_info_st,
            core: *mut *mut mcd_core_st,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_close_core_f: Result<
        unsafe extern "C" fn(core: *const mcd_core_st) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_qry_error_info_f: Result<
        unsafe extern "C" fn(core: *const mcd_core_st, error_info: *mut mcd_error_info_st),
        ::libloading::Error,
    >,
    pub mcd_qry_device_description_f: Result<
        unsafe extern "C" fn(
            core: *const mcd_core_st,
            url: *mut mcd_char_t,
            url_length: *mut u32,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_qry_max_payload_size_f: Result<
        unsafe extern "C" fn(core: *const mcd_core_st, max_payload: *mut u32) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_qry_input_handle_f: Result<
        unsafe extern "C" fn(core: *const mcd_core_st, input_handle: *mut u32) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_qry_mem_spaces_f: Result<
        unsafe extern "C" fn(
            core: *const mcd_core_st,
            start_index: u32,
            num_mem_spaces: *mut u32,
            mem_spaces: *mut mcd_memspace_st,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_qry_mem_blocks_f: Result<
        unsafe extern "C" fn(
            core: *const mcd_core_st,
            mem_space_id: u32,
            start_index: u32,
            num_mem_blocks: *mut u32,
            mem_blocks: *mut mcd_memblock_st,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_qry_active_overlays_f: Result<
        unsafe extern "C" fn(
            core: *const mcd_core_st,
            start_index: u32,
            num_active_overlays: *mut u32,
            active_overlays: *mut u32,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_qry_reg_groups_f: Result<
        unsafe extern "C" fn(
            core: *const mcd_core_st,
            start_index: u32,
            num_reg_groups: *mut u32,
            reg_groups: *mut mcd_register_group_st,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_qry_reg_map_f: Result<
        unsafe extern "C" fn(
            core: *const mcd_core_st,
            reg_group_id: u32,
            start_index: u32,
            num_regs: *mut u32,
            reg_info: *mut mcd_register_info_st,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_qry_reg_compound_f: Result<
        unsafe extern "C" fn(
            core: *const mcd_core_st,
            compound_reg_id: u32,
            start_index: u32,
            num_reg_ids: *mut u32,
            reg_id_array: *mut u32,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_qry_trig_info_f: Result<
        unsafe extern "C" fn(
            core: *const mcd_core_st,
            trig_info: *mut mcd_trig_info_st,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_qry_ctrigs_f: Result<
        unsafe extern "C" fn(
            core: *const mcd_core_st,
            start_index: u32,
            num_ctrigs: *mut u32,
            ctrig_info: *mut mcd_ctrig_info_st,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_create_trig_f: Result<
        unsafe extern "C" fn(
            core: *const mcd_core_st,
            trig: *mut ::std::os::raw::c_void,
            trig_id: *mut u32,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_qry_trig_f: Result<
        unsafe extern "C" fn(
            core: *const mcd_core_st,
            trig_id: u32,
            max_trig_size: u32,
            trig: *mut ::std::os::raw::c_void,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_remove_trig_f: Result<
        unsafe extern "C" fn(core: *const mcd_core_st, trig_id: u32) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_qry_trig_state_f: Result<
        unsafe extern "C" fn(
            core: *const mcd_core_st,
            trig_id: u32,
            trig_state: *mut mcd_trig_state_st,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_activate_trig_set_f: Result<
        unsafe extern "C" fn(core: *const mcd_core_st) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_remove_trig_set_f: Result<
        unsafe extern "C" fn(core: *const mcd_core_st) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_qry_trig_set_f: Result<
        unsafe extern "C" fn(
            core: *const mcd_core_st,
            start_index: u32,
            num_trigs: *mut u32,
            trig_ids: *mut u32,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_qry_trig_set_state_f: Result<
        unsafe extern "C" fn(
            core: *const mcd_core_st,
            trig_state: *mut mcd_trig_set_state_st,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_execute_txlist_f: Result<
        unsafe extern "C" fn(core: *const mcd_core_st, txlist: *mut mcd_txlist_st) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_run_f: Result<
        unsafe extern "C" fn(core: *const mcd_core_st, global: mcd_bool_t) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_stop_f: Result<
        unsafe extern "C" fn(core: *const mcd_core_st, global: mcd_bool_t) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_run_until_f: Result<
        unsafe extern "C" fn(
            core: *const mcd_core_st,
            global: mcd_bool_t,
            absolute_time: mcd_bool_t,
            run_until_time: u64,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_qry_current_time_f: Result<
        unsafe extern "C" fn(core: *const mcd_core_st, current_time: *mut u64) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_step_f: Result<
        unsafe extern "C" fn(
            core: *const mcd_core_st,
            global: mcd_bool_t,
            step_type: mcd_core_step_type_et,
            n_steps: u32,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_set_global_f: Result<
        unsafe extern "C" fn(core: *const mcd_core_st, enable: mcd_bool_t) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_qry_state_f: Result<
        unsafe extern "C" fn(
            core: *const mcd_core_st,
            state: *mut mcd_core_state_st,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_execute_command_f: Result<
        unsafe extern "C" fn(
            core: *const mcd_core_st,
            command_string: *const mcd_char_t,
            result_string_size: u32,
            result_string: *mut mcd_char_t,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_qry_rst_classes_f: Result<
        unsafe extern "C" fn(core: *const mcd_core_st, rst_class_vector: *mut u32) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_qry_rst_class_info_f: Result<
        unsafe extern "C" fn(
            core: *const mcd_core_st,
            rst_class: u8,
            rst_info: *mut mcd_rst_info_st,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_rst_f: Result<
        unsafe extern "C" fn(
            core: *const mcd_core_st,
            rst_class_vector: u32,
            rst_and_halt: mcd_bool_t,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_chl_open_f: Result<
        unsafe extern "C" fn(core: *const mcd_core_st, channel: *mut mcd_chl_st) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_send_msg_f: Result<
        unsafe extern "C" fn(
            core: *const mcd_core_st,
            channel: *const mcd_chl_st,
            msg_len: u32,
            msg: *const u8,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_receive_msg_f: Result<
        unsafe extern "C" fn(
            core: *const mcd_core_st,
            channel: *const mcd_chl_st,
            timeout: u32,
            msg_len: *mut u32,
            msg: *mut u8,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_chl_reset_f: Result<
        unsafe extern "C" fn(core: *const mcd_core_st, channel: *const mcd_chl_st) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_chl_close_f: Result<
        unsafe extern "C" fn(core: *const mcd_core_st, channel: *const mcd_chl_st) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_qry_traces_f: Result<
        unsafe extern "C" fn(
            core: *const mcd_core_st,
            start_index: u32,
            num_traces: *mut u32,
            trace_info: *mut mcd_trace_info_st,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_qry_trace_state_f: Result<
        unsafe extern "C" fn(
            core: *const mcd_core_st,
            trace_id: u32,
            state: *mut mcd_trace_state_st,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_set_trace_state_f: Result<
        unsafe extern "C" fn(
            core: *const mcd_core_st,
            trace_id: u32,
            state: *mut mcd_trace_state_st,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
    pub mcd_read_trace_f: Result<
        unsafe extern "C" fn(
            core: *const mcd_core_st,
            trace_id: u32,
            start_index: u64,
            num_frames: *mut u32,
            trace_data_size: u32,
            trace_data: *mut ::std::os::raw::c_void,
        ) -> mcd_return_et,
        ::libloading::Error,
    >,
}
impl DynamicMCDxDAS {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
        where
            P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
        where
            L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let __va_start = __library.get(b"__va_start\0").map(|sym| *sym);
        let __security_init_cookie = __library.get(b"__security_init_cookie\0").map(|sym| *sym);
        let __security_check_cookie = __library.get(b"__security_check_cookie\0").map(|sym| *sym);
        let __report_gsfailure = __library.get(b"__report_gsfailure\0").map(|sym| *sym);
        let _invalid_parameter_noinfo = __library
            .get(b"_invalid_parameter_noinfo\0")
            .map(|sym| *sym);
        let _invalid_parameter_noinfo_noreturn = __library
            .get(b"_invalid_parameter_noinfo_noreturn\0")
            .map(|sym| *sym);
        let _invoke_watson = __library.get(b"_invoke_watson\0").map(|sym| *sym);
        let _calloc_base = __library.get(b"_calloc_base\0").map(|sym| *sym);
        let calloc = __library.get(b"calloc\0").map(|sym| *sym);
        let _callnewh = __library.get(b"_callnewh\0").map(|sym| *sym);
        let _expand = __library.get(b"_expand\0").map(|sym| *sym);
        let _free_base = __library.get(b"_free_base\0").map(|sym| *sym);
        let free = __library.get(b"free\0").map(|sym| *sym);
        let _malloc_base = __library.get(b"_malloc_base\0").map(|sym| *sym);
        let malloc = __library.get(b"malloc\0").map(|sym| *sym);
        let _msize = __library.get(b"_msize\0").map(|sym| *sym);
        let _realloc_base = __library.get(b"_realloc_base\0").map(|sym| *sym);
        let realloc = __library.get(b"realloc\0").map(|sym| *sym);
        let _recalloc = __library.get(b"_recalloc\0").map(|sym| *sym);
        let _aligned_free = __library.get(b"_aligned_free\0").map(|sym| *sym);
        let _aligned_malloc = __library.get(b"_aligned_malloc\0").map(|sym| *sym);
        let _aligned_offset_malloc = __library.get(b"_aligned_offset_malloc\0").map(|sym| *sym);
        let _aligned_msize = __library.get(b"_aligned_msize\0").map(|sym| *sym);
        let _aligned_offset_realloc = __library.get(b"_aligned_offset_realloc\0").map(|sym| *sym);
        let _aligned_offset_recalloc = __library.get(b"_aligned_offset_recalloc\0").map(|sym| *sym);
        let _aligned_realloc = __library.get(b"_aligned_realloc\0").map(|sym| *sym);
        let _aligned_recalloc = __library.get(b"_aligned_recalloc\0").map(|sym| *sym);
        let _errno = __library.get(b"_errno\0").map(|sym| *sym);
        let _set_errno = __library.get(b"_set_errno\0").map(|sym| *sym);
        let _get_errno = __library.get(b"_get_errno\0").map(|sym| *sym);
        let __threadid = __library.get(b"__threadid\0").map(|sym| *sym);
        let __threadhandle = __library.get(b"__threadhandle\0").map(|sym| *sym);
        let bsearch_s = __library.get(b"bsearch_s\0").map(|sym| *sym);
        let qsort_s = __library.get(b"qsort_s\0").map(|sym| *sym);
        let bsearch = __library.get(b"bsearch\0").map(|sym| *sym);
        let qsort = __library.get(b"qsort\0").map(|sym| *sym);
        let _lfind_s = __library.get(b"_lfind_s\0").map(|sym| *sym);
        let _lfind = __library.get(b"_lfind\0").map(|sym| *sym);
        let _lsearch_s = __library.get(b"_lsearch_s\0").map(|sym| *sym);
        let _lsearch = __library.get(b"_lsearch\0").map(|sym| *sym);
        let lfind = __library.get(b"lfind\0").map(|sym| *sym);
        let lsearch = __library.get(b"lsearch\0").map(|sym| *sym);
        let _itow_s = __library.get(b"_itow_s\0").map(|sym| *sym);
        let _itow = __library.get(b"_itow\0").map(|sym| *sym);
        let _ltow_s = __library.get(b"_ltow_s\0").map(|sym| *sym);
        let _ltow = __library.get(b"_ltow\0").map(|sym| *sym);
        let _ultow_s = __library.get(b"_ultow_s\0").map(|sym| *sym);
        let _ultow = __library.get(b"_ultow\0").map(|sym| *sym);
        let wcstod = __library.get(b"wcstod\0").map(|sym| *sym);
        let _wcstod_l = __library.get(b"_wcstod_l\0").map(|sym| *sym);
        let wcstol = __library.get(b"wcstol\0").map(|sym| *sym);
        let _wcstol_l = __library.get(b"_wcstol_l\0").map(|sym| *sym);
        let wcstoll = __library.get(b"wcstoll\0").map(|sym| *sym);
        let _wcstoll_l = __library.get(b"_wcstoll_l\0").map(|sym| *sym);
        let wcstoul = __library.get(b"wcstoul\0").map(|sym| *sym);
        let _wcstoul_l = __library.get(b"_wcstoul_l\0").map(|sym| *sym);
        let wcstoull = __library.get(b"wcstoull\0").map(|sym| *sym);
        let _wcstoull_l = __library.get(b"_wcstoull_l\0").map(|sym| *sym);
        let wcstold = __library.get(b"wcstold\0").map(|sym| *sym);
        let _wcstold_l = __library.get(b"_wcstold_l\0").map(|sym| *sym);
        let wcstof = __library.get(b"wcstof\0").map(|sym| *sym);
        let _wcstof_l = __library.get(b"_wcstof_l\0").map(|sym| *sym);
        let _wtof = __library.get(b"_wtof\0").map(|sym| *sym);
        let _wtof_l = __library.get(b"_wtof_l\0").map(|sym| *sym);
        let _wtoi = __library.get(b"_wtoi\0").map(|sym| *sym);
        let _wtoi_l = __library.get(b"_wtoi_l\0").map(|sym| *sym);
        let _wtol = __library.get(b"_wtol\0").map(|sym| *sym);
        let _wtol_l = __library.get(b"_wtol_l\0").map(|sym| *sym);
        let _wtoll = __library.get(b"_wtoll\0").map(|sym| *sym);
        let _wtoll_l = __library.get(b"_wtoll_l\0").map(|sym| *sym);
        let _i64tow_s = __library.get(b"_i64tow_s\0").map(|sym| *sym);
        let _i64tow = __library.get(b"_i64tow\0").map(|sym| *sym);
        let _ui64tow_s = __library.get(b"_ui64tow_s\0").map(|sym| *sym);
        let _ui64tow = __library.get(b"_ui64tow\0").map(|sym| *sym);
        let _wtoi64 = __library.get(b"_wtoi64\0").map(|sym| *sym);
        let _wtoi64_l = __library.get(b"_wtoi64_l\0").map(|sym| *sym);
        let _wcstoi64 = __library.get(b"_wcstoi64\0").map(|sym| *sym);
        let _wcstoi64_l = __library.get(b"_wcstoi64_l\0").map(|sym| *sym);
        let _wcstoui64 = __library.get(b"_wcstoui64\0").map(|sym| *sym);
        let _wcstoui64_l = __library.get(b"_wcstoui64_l\0").map(|sym| *sym);
        let _wfullpath = __library.get(b"_wfullpath\0").map(|sym| *sym);
        let _wmakepath_s = __library.get(b"_wmakepath_s\0").map(|sym| *sym);
        let _wmakepath = __library.get(b"_wmakepath\0").map(|sym| *sym);
        let _wperror = __library.get(b"_wperror\0").map(|sym| *sym);
        let _wsplitpath = __library.get(b"_wsplitpath\0").map(|sym| *sym);
        let _wsplitpath_s = __library.get(b"_wsplitpath_s\0").map(|sym| *sym);
        let _wdupenv_s = __library.get(b"_wdupenv_s\0").map(|sym| *sym);
        let _wgetenv = __library.get(b"_wgetenv\0").map(|sym| *sym);
        let _wgetenv_s = __library.get(b"_wgetenv_s\0").map(|sym| *sym);
        let _wputenv = __library.get(b"_wputenv\0").map(|sym| *sym);
        let _wputenv_s = __library.get(b"_wputenv_s\0").map(|sym| *sym);
        let _wsearchenv_s = __library.get(b"_wsearchenv_s\0").map(|sym| *sym);
        let _wsearchenv = __library.get(b"_wsearchenv\0").map(|sym| *sym);
        let _wsystem = __library.get(b"_wsystem\0").map(|sym| *sym);
        let _swab = __library.get(b"_swab\0").map(|sym| *sym);
        let exit = __library.get(b"exit\0").map(|sym| *sym);
        let _exit = __library.get(b"_exit\0").map(|sym| *sym);
        let _Exit = __library.get(b"_Exit\0").map(|sym| *sym);
        let quick_exit = __library.get(b"quick_exit\0").map(|sym| *sym);
        let abort = __library.get(b"abort\0").map(|sym| *sym);
        let _set_abort_behavior = __library.get(b"_set_abort_behavior\0").map(|sym| *sym);
        let atexit = __library.get(b"atexit\0").map(|sym| *sym);
        let _onexit = __library.get(b"_onexit\0").map(|sym| *sym);
        let at_quick_exit = __library.get(b"at_quick_exit\0").map(|sym| *sym);
        let _set_purecall_handler = __library.get(b"_set_purecall_handler\0").map(|sym| *sym);
        let _get_purecall_handler = __library.get(b"_get_purecall_handler\0").map(|sym| *sym);
        let _set_invalid_parameter_handler = __library
            .get(b"_set_invalid_parameter_handler\0")
            .map(|sym| *sym);
        let _get_invalid_parameter_handler = __library
            .get(b"_get_invalid_parameter_handler\0")
            .map(|sym| *sym);
        let _set_thread_local_invalid_parameter_handler = __library
            .get(b"_set_thread_local_invalid_parameter_handler\0")
            .map(|sym| *sym);
        let _get_thread_local_invalid_parameter_handler = __library
            .get(b"_get_thread_local_invalid_parameter_handler\0")
            .map(|sym| *sym);
        let _set_error_mode = __library.get(b"_set_error_mode\0").map(|sym| *sym);
        let __doserrno = __library.get(b"__doserrno\0").map(|sym| *sym);
        let _set_doserrno = __library.get(b"_set_doserrno\0").map(|sym| *sym);
        let _get_doserrno = __library.get(b"_get_doserrno\0").map(|sym| *sym);
        let __sys_errlist = __library.get(b"__sys_errlist\0").map(|sym| *sym);
        let __sys_nerr = __library.get(b"__sys_nerr\0").map(|sym| *sym);
        let perror = __library.get(b"perror\0").map(|sym| *sym);
        let __p__pgmptr = __library.get(b"__p__pgmptr\0").map(|sym| *sym);
        let __p__wpgmptr = __library.get(b"__p__wpgmptr\0").map(|sym| *sym);
        let __p__fmode = __library.get(b"__p__fmode\0").map(|sym| *sym);
        let _get_pgmptr = __library.get(b"_get_pgmptr\0").map(|sym| *sym);
        let _get_wpgmptr = __library.get(b"_get_wpgmptr\0").map(|sym| *sym);
        let _set_fmode = __library.get(b"_set_fmode\0").map(|sym| *sym);
        let _get_fmode = __library.get(b"_get_fmode\0").map(|sym| *sym);
        let abs = __library.get(b"abs\0").map(|sym| *sym);
        let labs = __library.get(b"labs\0").map(|sym| *sym);
        let llabs = __library.get(b"llabs\0").map(|sym| *sym);
        let _abs64 = __library.get(b"_abs64\0").map(|sym| *sym);
        let _byteswap_ushort = __library.get(b"_byteswap_ushort\0").map(|sym| *sym);
        let _byteswap_ulong = __library.get(b"_byteswap_ulong\0").map(|sym| *sym);
        let _byteswap_uint64 = __library.get(b"_byteswap_uint64\0").map(|sym| *sym);
        let div = __library.get(b"div\0").map(|sym| *sym);
        let ldiv = __library.get(b"ldiv\0").map(|sym| *sym);
        let lldiv = __library.get(b"lldiv\0").map(|sym| *sym);
        let _rotl = __library.get(b"_rotl\0").map(|sym| *sym);
        let _lrotl = __library.get(b"_lrotl\0").map(|sym| *sym);
        let _rotl64 = __library.get(b"_rotl64\0").map(|sym| *sym);
        let _rotr = __library.get(b"_rotr\0").map(|sym| *sym);
        let _lrotr = __library.get(b"_lrotr\0").map(|sym| *sym);
        let _rotr64 = __library.get(b"_rotr64\0").map(|sym| *sym);
        let srand = __library.get(b"srand\0").map(|sym| *sym);
        let rand = __library.get(b"rand\0").map(|sym| *sym);
        let atof = __library.get(b"atof\0").map(|sym| *sym);
        let atoi = __library.get(b"atoi\0").map(|sym| *sym);
        let atol = __library.get(b"atol\0").map(|sym| *sym);
        let atoll = __library.get(b"atoll\0").map(|sym| *sym);
        let _atoi64 = __library.get(b"_atoi64\0").map(|sym| *sym);
        let _atof_l = __library.get(b"_atof_l\0").map(|sym| *sym);
        let _atoi_l = __library.get(b"_atoi_l\0").map(|sym| *sym);
        let _atol_l = __library.get(b"_atol_l\0").map(|sym| *sym);
        let _atoll_l = __library.get(b"_atoll_l\0").map(|sym| *sym);
        let _atoi64_l = __library.get(b"_atoi64_l\0").map(|sym| *sym);
        let _atoflt = __library.get(b"_atoflt\0").map(|sym| *sym);
        let _atodbl = __library.get(b"_atodbl\0").map(|sym| *sym);
        let _atoldbl = __library.get(b"_atoldbl\0").map(|sym| *sym);
        let _atoflt_l = __library.get(b"_atoflt_l\0").map(|sym| *sym);
        let _atodbl_l = __library.get(b"_atodbl_l\0").map(|sym| *sym);
        let _atoldbl_l = __library.get(b"_atoldbl_l\0").map(|sym| *sym);
        let strtof = __library.get(b"strtof\0").map(|sym| *sym);
        let _strtof_l = __library.get(b"_strtof_l\0").map(|sym| *sym);
        let strtod = __library.get(b"strtod\0").map(|sym| *sym);
        let _strtod_l = __library.get(b"_strtod_l\0").map(|sym| *sym);
        let strtold = __library.get(b"strtold\0").map(|sym| *sym);
        let _strtold_l = __library.get(b"_strtold_l\0").map(|sym| *sym);
        let strtol = __library.get(b"strtol\0").map(|sym| *sym);
        let _strtol_l = __library.get(b"_strtol_l\0").map(|sym| *sym);
        let strtoll = __library.get(b"strtoll\0").map(|sym| *sym);
        let _strtoll_l = __library.get(b"_strtoll_l\0").map(|sym| *sym);
        let strtoul = __library.get(b"strtoul\0").map(|sym| *sym);
        let _strtoul_l = __library.get(b"_strtoul_l\0").map(|sym| *sym);
        let strtoull = __library.get(b"strtoull\0").map(|sym| *sym);
        let _strtoull_l = __library.get(b"_strtoull_l\0").map(|sym| *sym);
        let _strtoi64 = __library.get(b"_strtoi64\0").map(|sym| *sym);
        let _strtoi64_l = __library.get(b"_strtoi64_l\0").map(|sym| *sym);
        let _strtoui64 = __library.get(b"_strtoui64\0").map(|sym| *sym);
        let _strtoui64_l = __library.get(b"_strtoui64_l\0").map(|sym| *sym);
        let _itoa_s = __library.get(b"_itoa_s\0").map(|sym| *sym);
        let _itoa = __library.get(b"_itoa\0").map(|sym| *sym);
        let _ltoa_s = __library.get(b"_ltoa_s\0").map(|sym| *sym);
        let _ltoa = __library.get(b"_ltoa\0").map(|sym| *sym);
        let _ultoa_s = __library.get(b"_ultoa_s\0").map(|sym| *sym);
        let _ultoa = __library.get(b"_ultoa\0").map(|sym| *sym);
        let _i64toa_s = __library.get(b"_i64toa_s\0").map(|sym| *sym);
        let _i64toa = __library.get(b"_i64toa\0").map(|sym| *sym);
        let _ui64toa_s = __library.get(b"_ui64toa_s\0").map(|sym| *sym);
        let _ui64toa = __library.get(b"_ui64toa\0").map(|sym| *sym);
        let _ecvt_s = __library.get(b"_ecvt_s\0").map(|sym| *sym);
        let _ecvt = __library.get(b"_ecvt\0").map(|sym| *sym);
        let _fcvt_s = __library.get(b"_fcvt_s\0").map(|sym| *sym);
        let _fcvt = __library.get(b"_fcvt\0").map(|sym| *sym);
        let _gcvt_s = __library.get(b"_gcvt_s\0").map(|sym| *sym);
        let _gcvt = __library.get(b"_gcvt\0").map(|sym| *sym);
        let ___mb_cur_max_func = __library.get(b"___mb_cur_max_func\0").map(|sym| *sym);
        let ___mb_cur_max_l_func = __library.get(b"___mb_cur_max_l_func\0").map(|sym| *sym);
        let mblen = __library.get(b"mblen\0").map(|sym| *sym);
        let _mblen_l = __library.get(b"_mblen_l\0").map(|sym| *sym);
        let _mbstrlen = __library.get(b"_mbstrlen\0").map(|sym| *sym);
        let _mbstrlen_l = __library.get(b"_mbstrlen_l\0").map(|sym| *sym);
        let _mbstrnlen = __library.get(b"_mbstrnlen\0").map(|sym| *sym);
        let _mbstrnlen_l = __library.get(b"_mbstrnlen_l\0").map(|sym| *sym);
        let mbtowc = __library.get(b"mbtowc\0").map(|sym| *sym);
        let _mbtowc_l = __library.get(b"_mbtowc_l\0").map(|sym| *sym);
        let mbstowcs_s = __library.get(b"mbstowcs_s\0").map(|sym| *sym);
        let mbstowcs = __library.get(b"mbstowcs\0").map(|sym| *sym);
        let _mbstowcs_s_l = __library.get(b"_mbstowcs_s_l\0").map(|sym| *sym);
        let _mbstowcs_l = __library.get(b"_mbstowcs_l\0").map(|sym| *sym);
        let wctomb = __library.get(b"wctomb\0").map(|sym| *sym);
        let _wctomb_l = __library.get(b"_wctomb_l\0").map(|sym| *sym);
        let wctomb_s = __library.get(b"wctomb_s\0").map(|sym| *sym);
        let _wctomb_s_l = __library.get(b"_wctomb_s_l\0").map(|sym| *sym);
        let wcstombs_s = __library.get(b"wcstombs_s\0").map(|sym| *sym);
        let wcstombs = __library.get(b"wcstombs\0").map(|sym| *sym);
        let _wcstombs_s_l = __library.get(b"_wcstombs_s_l\0").map(|sym| *sym);
        let _wcstombs_l = __library.get(b"_wcstombs_l\0").map(|sym| *sym);
        let _fullpath = __library.get(b"_fullpath\0").map(|sym| *sym);
        let _makepath_s = __library.get(b"_makepath_s\0").map(|sym| *sym);
        let _makepath = __library.get(b"_makepath\0").map(|sym| *sym);
        let _splitpath = __library.get(b"_splitpath\0").map(|sym| *sym);
        let _splitpath_s = __library.get(b"_splitpath_s\0").map(|sym| *sym);
        let getenv_s = __library.get(b"getenv_s\0").map(|sym| *sym);
        let __p___argc = __library.get(b"__p___argc\0").map(|sym| *sym);
        let __p___argv = __library.get(b"__p___argv\0").map(|sym| *sym);
        let __p___wargv = __library.get(b"__p___wargv\0").map(|sym| *sym);
        let __p__environ = __library.get(b"__p__environ\0").map(|sym| *sym);
        let __p__wenviron = __library.get(b"__p__wenviron\0").map(|sym| *sym);
        let getenv = __library.get(b"getenv\0").map(|sym| *sym);
        let _dupenv_s = __library.get(b"_dupenv_s\0").map(|sym| *sym);
        let system = __library.get(b"system\0").map(|sym| *sym);
        let _putenv = __library.get(b"_putenv\0").map(|sym| *sym);
        let _putenv_s = __library.get(b"_putenv_s\0").map(|sym| *sym);
        let _searchenv_s = __library.get(b"_searchenv_s\0").map(|sym| *sym);
        let _searchenv = __library.get(b"_searchenv\0").map(|sym| *sym);
        let _seterrormode = __library.get(b"_seterrormode\0").map(|sym| *sym);
        let _beep = __library.get(b"_beep\0").map(|sym| *sym);
        let _sleep = __library.get(b"_sleep\0").map(|sym| *sym);
        let ecvt = __library.get(b"ecvt\0").map(|sym| *sym);
        let fcvt = __library.get(b"fcvt\0").map(|sym| *sym);
        let gcvt = __library.get(b"gcvt\0").map(|sym| *sym);
        let itoa = __library.get(b"itoa\0").map(|sym| *sym);
        let ltoa = __library.get(b"ltoa\0").map(|sym| *sym);
        let swab = __library.get(b"swab\0").map(|sym| *sym);
        let ultoa = __library.get(b"ultoa\0").map(|sym| *sym);
        let putenv = __library.get(b"putenv\0").map(|sym| *sym);
        let onexit = __library.get(b"onexit\0").map(|sym| *sym);
        let mcd_initialize_f = __library.get(b"mcd_initialize_f\0").map(|sym| *sym);
        let mcd_exit_f = __library.get(b"mcd_exit_f\0").map(|sym| *sym);
        let mcd_qry_servers_f = __library.get(b"mcd_qry_servers_f\0").map(|sym| *sym);
        let mcd_open_server_f = __library.get(b"mcd_open_server_f\0").map(|sym| *sym);
        let mcd_close_server_f = __library.get(b"mcd_close_server_f\0").map(|sym| *sym);
        let mcd_set_server_config_f = __library.get(b"mcd_set_server_config_f\0").map(|sym| *sym);
        let mcd_qry_server_config_f = __library.get(b"mcd_qry_server_config_f\0").map(|sym| *sym);
        let mcd_qry_systems_f = __library.get(b"mcd_qry_systems_f\0").map(|sym| *sym);
        let mcd_qry_devices_f = __library.get(b"mcd_qry_devices_f\0").map(|sym| *sym);
        let mcd_qry_cores_f = __library.get(b"mcd_qry_cores_f\0").map(|sym| *sym);
        let mcd_qry_core_modes_f = __library.get(b"mcd_qry_core_modes_f\0").map(|sym| *sym);
        let mcd_open_core_f = __library.get(b"mcd_open_core_f\0").map(|sym| *sym);
        let mcd_close_core_f = __library.get(b"mcd_close_core_f\0").map(|sym| *sym);
        let mcd_qry_error_info_f = __library.get(b"mcd_qry_error_info_f\0").map(|sym| *sym);
        let mcd_qry_device_description_f = __library
            .get(b"mcd_qry_device_description_f\0")
            .map(|sym| *sym);
        let mcd_qry_max_payload_size_f = __library
            .get(b"mcd_qry_max_payload_size_f\0")
            .map(|sym| *sym);
        let mcd_qry_input_handle_f = __library.get(b"mcd_qry_input_handle_f\0").map(|sym| *sym);
        let mcd_qry_mem_spaces_f = __library.get(b"mcd_qry_mem_spaces_f\0").map(|sym| *sym);
        let mcd_qry_mem_blocks_f = __library.get(b"mcd_qry_mem_blocks_f\0").map(|sym| *sym);
        let mcd_qry_active_overlays_f = __library
            .get(b"mcd_qry_active_overlays_f\0")
            .map(|sym| *sym);
        let mcd_qry_reg_groups_f = __library.get(b"mcd_qry_reg_groups_f\0").map(|sym| *sym);
        let mcd_qry_reg_map_f = __library.get(b"mcd_qry_reg_map_f\0").map(|sym| *sym);
        let mcd_qry_reg_compound_f = __library.get(b"mcd_qry_reg_compound_f\0").map(|sym| *sym);
        let mcd_qry_trig_info_f = __library.get(b"mcd_qry_trig_info_f\0").map(|sym| *sym);
        let mcd_qry_ctrigs_f = __library.get(b"mcd_qry_ctrigs_f\0").map(|sym| *sym);
        let mcd_create_trig_f = __library.get(b"mcd_create_trig_f\0").map(|sym| *sym);
        let mcd_qry_trig_f = __library.get(b"mcd_qry_trig_f\0").map(|sym| *sym);
        let mcd_remove_trig_f = __library.get(b"mcd_remove_trig_f\0").map(|sym| *sym);
        let mcd_qry_trig_state_f = __library.get(b"mcd_qry_trig_state_f\0").map(|sym| *sym);
        let mcd_activate_trig_set_f = __library.get(b"mcd_activate_trig_set_f\0").map(|sym| *sym);
        let mcd_remove_trig_set_f = __library.get(b"mcd_remove_trig_set_f\0").map(|sym| *sym);
        let mcd_qry_trig_set_f = __library.get(b"mcd_qry_trig_set_f\0").map(|sym| *sym);
        let mcd_qry_trig_set_state_f = __library.get(b"mcd_qry_trig_set_state_f\0").map(|sym| *sym);
        let mcd_execute_txlist_f = __library.get(b"mcd_execute_txlist_f\0").map(|sym| *sym);
        let mcd_run_f = __library.get(b"mcd_run_f\0").map(|sym| *sym);
        let mcd_stop_f = __library.get(b"mcd_stop_f\0").map(|sym| *sym);
        let mcd_run_until_f = __library.get(b"mcd_run_until_f\0").map(|sym| *sym);
        let mcd_qry_current_time_f = __library.get(b"mcd_qry_current_time_f\0").map(|sym| *sym);
        let mcd_step_f = __library.get(b"mcd_step_f\0").map(|sym| *sym);
        let mcd_set_global_f = __library.get(b"mcd_set_global_f\0").map(|sym| *sym);
        let mcd_qry_state_f = __library.get(b"mcd_qry_state_f\0").map(|sym| *sym);
        let mcd_execute_command_f = __library.get(b"mcd_execute_command_f\0").map(|sym| *sym);
        let mcd_qry_rst_classes_f = __library.get(b"mcd_qry_rst_classes_f\0").map(|sym| *sym);
        let mcd_qry_rst_class_info_f = __library.get(b"mcd_qry_rst_class_info_f\0").map(|sym| *sym);
        let mcd_rst_f = __library.get(b"mcd_rst_f\0").map(|sym| *sym);
        let mcd_chl_open_f = __library.get(b"mcd_chl_open_f\0").map(|sym| *sym);
        let mcd_send_msg_f = __library.get(b"mcd_send_msg_f\0").map(|sym| *sym);
        let mcd_receive_msg_f = __library.get(b"mcd_receive_msg_f\0").map(|sym| *sym);
        let mcd_chl_reset_f = __library.get(b"mcd_chl_reset_f\0").map(|sym| *sym);
        let mcd_chl_close_f = __library.get(b"mcd_chl_close_f\0").map(|sym| *sym);
        let mcd_qry_traces_f = __library.get(b"mcd_qry_traces_f\0").map(|sym| *sym);
        let mcd_qry_trace_state_f = __library.get(b"mcd_qry_trace_state_f\0").map(|sym| *sym);
        let mcd_set_trace_state_f = __library.get(b"mcd_set_trace_state_f\0").map(|sym| *sym);
        let mcd_read_trace_f = __library.get(b"mcd_read_trace_f\0").map(|sym| *sym);
        Ok(DynamicMCDxDAS {
            __library,
            __va_start,
            __security_init_cookie,
            __security_check_cookie,
            __report_gsfailure,
            _invalid_parameter_noinfo,
            _invalid_parameter_noinfo_noreturn,
            _invoke_watson,
            _calloc_base,
            calloc,
            _callnewh,
            _expand,
            _free_base,
            free,
            _malloc_base,
            malloc,
            _msize,
            _realloc_base,
            realloc,
            _recalloc,
            _aligned_free,
            _aligned_malloc,
            _aligned_offset_malloc,
            _aligned_msize,
            _aligned_offset_realloc,
            _aligned_offset_recalloc,
            _aligned_realloc,
            _aligned_recalloc,
            _errno,
            _set_errno,
            _get_errno,
            __threadid,
            __threadhandle,
            bsearch_s,
            qsort_s,
            bsearch,
            qsort,
            _lfind_s,
            _lfind,
            _lsearch_s,
            _lsearch,
            lfind,
            lsearch,
            _itow_s,
            _itow,
            _ltow_s,
            _ltow,
            _ultow_s,
            _ultow,
            wcstod,
            _wcstod_l,
            wcstol,
            _wcstol_l,
            wcstoll,
            _wcstoll_l,
            wcstoul,
            _wcstoul_l,
            wcstoull,
            _wcstoull_l,
            wcstold,
            _wcstold_l,
            wcstof,
            _wcstof_l,
            _wtof,
            _wtof_l,
            _wtoi,
            _wtoi_l,
            _wtol,
            _wtol_l,
            _wtoll,
            _wtoll_l,
            _i64tow_s,
            _i64tow,
            _ui64tow_s,
            _ui64tow,
            _wtoi64,
            _wtoi64_l,
            _wcstoi64,
            _wcstoi64_l,
            _wcstoui64,
            _wcstoui64_l,
            _wfullpath,
            _wmakepath_s,
            _wmakepath,
            _wperror,
            _wsplitpath,
            _wsplitpath_s,
            _wdupenv_s,
            _wgetenv,
            _wgetenv_s,
            _wputenv,
            _wputenv_s,
            _wsearchenv_s,
            _wsearchenv,
            _wsystem,
            _swab,
            exit,
            _exit,
            _Exit,
            quick_exit,
            abort,
            _set_abort_behavior,
            atexit,
            _onexit,
            at_quick_exit,
            _set_purecall_handler,
            _get_purecall_handler,
            _set_invalid_parameter_handler,
            _get_invalid_parameter_handler,
            _set_thread_local_invalid_parameter_handler,
            _get_thread_local_invalid_parameter_handler,
            _set_error_mode,
            __doserrno,
            _set_doserrno,
            _get_doserrno,
            __sys_errlist,
            __sys_nerr,
            perror,
            __p__pgmptr,
            __p__wpgmptr,
            __p__fmode,
            _get_pgmptr,
            _get_wpgmptr,
            _set_fmode,
            _get_fmode,
            abs,
            labs,
            llabs,
            _abs64,
            _byteswap_ushort,
            _byteswap_ulong,
            _byteswap_uint64,
            div,
            ldiv,
            lldiv,
            _rotl,
            _lrotl,
            _rotl64,
            _rotr,
            _lrotr,
            _rotr64,
            srand,
            rand,
            atof,
            atoi,
            atol,
            atoll,
            _atoi64,
            _atof_l,
            _atoi_l,
            _atol_l,
            _atoll_l,
            _atoi64_l,
            _atoflt,
            _atodbl,
            _atoldbl,
            _atoflt_l,
            _atodbl_l,
            _atoldbl_l,
            strtof,
            _strtof_l,
            strtod,
            _strtod_l,
            strtold,
            _strtold_l,
            strtol,
            _strtol_l,
            strtoll,
            _strtoll_l,
            strtoul,
            _strtoul_l,
            strtoull,
            _strtoull_l,
            _strtoi64,
            _strtoi64_l,
            _strtoui64,
            _strtoui64_l,
            _itoa_s,
            _itoa,
            _ltoa_s,
            _ltoa,
            _ultoa_s,
            _ultoa,
            _i64toa_s,
            _i64toa,
            _ui64toa_s,
            _ui64toa,
            _ecvt_s,
            _ecvt,
            _fcvt_s,
            _fcvt,
            _gcvt_s,
            _gcvt,
            ___mb_cur_max_func,
            ___mb_cur_max_l_func,
            mblen,
            _mblen_l,
            _mbstrlen,
            _mbstrlen_l,
            _mbstrnlen,
            _mbstrnlen_l,
            mbtowc,
            _mbtowc_l,
            mbstowcs_s,
            mbstowcs,
            _mbstowcs_s_l,
            _mbstowcs_l,
            wctomb,
            _wctomb_l,
            wctomb_s,
            _wctomb_s_l,
            wcstombs_s,
            wcstombs,
            _wcstombs_s_l,
            _wcstombs_l,
            _fullpath,
            _makepath_s,
            _makepath,
            _splitpath,
            _splitpath_s,
            getenv_s,
            __p___argc,
            __p___argv,
            __p___wargv,
            __p__environ,
            __p__wenviron,
            getenv,
            _dupenv_s,
            system,
            _putenv,
            _putenv_s,
            _searchenv_s,
            _searchenv,
            _seterrormode,
            _beep,
            _sleep,
            ecvt,
            fcvt,
            gcvt,
            itoa,
            ltoa,
            swab,
            ultoa,
            putenv,
            onexit,
            mcd_initialize_f,
            mcd_exit_f,
            mcd_qry_servers_f,
            mcd_open_server_f,
            mcd_close_server_f,
            mcd_set_server_config_f,
            mcd_qry_server_config_f,
            mcd_qry_systems_f,
            mcd_qry_devices_f,
            mcd_qry_cores_f,
            mcd_qry_core_modes_f,
            mcd_open_core_f,
            mcd_close_core_f,
            mcd_qry_error_info_f,
            mcd_qry_device_description_f,
            mcd_qry_max_payload_size_f,
            mcd_qry_input_handle_f,
            mcd_qry_mem_spaces_f,
            mcd_qry_mem_blocks_f,
            mcd_qry_active_overlays_f,
            mcd_qry_reg_groups_f,
            mcd_qry_reg_map_f,
            mcd_qry_reg_compound_f,
            mcd_qry_trig_info_f,
            mcd_qry_ctrigs_f,
            mcd_create_trig_f,
            mcd_qry_trig_f,
            mcd_remove_trig_f,
            mcd_qry_trig_state_f,
            mcd_activate_trig_set_f,
            mcd_remove_trig_set_f,
            mcd_qry_trig_set_f,
            mcd_qry_trig_set_state_f,
            mcd_execute_txlist_f,
            mcd_run_f,
            mcd_stop_f,
            mcd_run_until_f,
            mcd_qry_current_time_f,
            mcd_step_f,
            mcd_set_global_f,
            mcd_qry_state_f,
            mcd_execute_command_f,
            mcd_qry_rst_classes_f,
            mcd_qry_rst_class_info_f,
            mcd_rst_f,
            mcd_chl_open_f,
            mcd_send_msg_f,
            mcd_receive_msg_f,
            mcd_chl_reset_f,
            mcd_chl_close_f,
            mcd_qry_traces_f,
            mcd_qry_trace_state_f,
            mcd_set_trace_state_f,
            mcd_read_trace_f,
        })
    }
    pub unsafe fn __security_init_cookie(&self) {
        (self
            .__security_init_cookie
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn __security_check_cookie(&self, _StackCookie: usize) {
        (self
            .__security_check_cookie
            .as_ref()
            .expect("Expected function, got error."))(_StackCookie)
    }
    pub unsafe fn __report_gsfailure(&self, _StackCookie: usize) -> ! {
        (self
            .__report_gsfailure
            .as_ref()
            .expect("Expected function, got error."))(_StackCookie)
    }
    pub unsafe fn _invalid_parameter_noinfo(&self) {
        (self
            ._invalid_parameter_noinfo
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn _invalid_parameter_noinfo_noreturn(&self) -> ! {
        (self
            ._invalid_parameter_noinfo_noreturn
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn _invoke_watson(
        &self,
        arg1: *const wchar_t,
        arg2: *const wchar_t,
        arg3: *const wchar_t,
        arg4: ::std::os::raw::c_uint,
        arg5: usize,
    ) -> ! {
        (self
            ._invoke_watson
            .as_ref()
            .expect("Expected function, got error."))(arg1, arg2, arg3, arg4, arg5)
    }
    pub unsafe fn _calloc_base(&self, _Count: usize, _Size: usize) -> *mut ::std::os::raw::c_void {
        (self
            ._calloc_base
            .as_ref()
            .expect("Expected function, got error."))(_Count, _Size)
    }
    pub unsafe fn calloc(
        &self,
        _Count: ::std::os::raw::c_ulonglong,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void {
        (self.calloc.as_ref().expect("Expected function, got error."))(_Count, _Size)
    }
    pub unsafe fn _callnewh(&self, _Size: usize) -> ::std::os::raw::c_int {
        (self
            ._callnewh
            .as_ref()
            .expect("Expected function, got error."))(_Size)
    }
    pub unsafe fn _expand(
        &self,
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void {
        (self
            ._expand
            .as_ref()
            .expect("Expected function, got error."))(_Block, _Size)
    }
    pub unsafe fn _free_base(&self, _Block: *mut ::std::os::raw::c_void) {
        (self
            ._free_base
            .as_ref()
            .expect("Expected function, got error."))(_Block)
    }
    pub unsafe fn free(&self, _Block: *mut ::std::os::raw::c_void) {
        (self.free.as_ref().expect("Expected function, got error."))(_Block)
    }
    pub unsafe fn _malloc_base(&self, _Size: usize) -> *mut ::std::os::raw::c_void {
        (self
            ._malloc_base
            .as_ref()
            .expect("Expected function, got error."))(_Size)
    }
    pub unsafe fn malloc(&self, _Size: ::std::os::raw::c_ulonglong) -> *mut ::std::os::raw::c_void {
        (self.malloc.as_ref().expect("Expected function, got error."))(_Size)
    }
    pub unsafe fn _msize(&self, _Block: *mut ::std::os::raw::c_void) -> usize {
        (self._msize.as_ref().expect("Expected function, got error."))(_Block)
    }
    pub unsafe fn _realloc_base(
        &self,
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void {
        (self
            ._realloc_base
            .as_ref()
            .expect("Expected function, got error."))(_Block, _Size)
    }
    pub unsafe fn realloc(
        &self,
        _Block: *mut ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void {
        (self
            .realloc
            .as_ref()
            .expect("Expected function, got error."))(_Block, _Size)
    }
    pub unsafe fn _recalloc(
        &self,
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void {
        (self
            ._recalloc
            .as_ref()
            .expect("Expected function, got error."))(_Block, _Count, _Size)
    }
    pub unsafe fn _aligned_free(&self, _Block: *mut ::std::os::raw::c_void) {
        (self
            ._aligned_free
            .as_ref()
            .expect("Expected function, got error."))(_Block)
    }
    pub unsafe fn _aligned_malloc(
        &self,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void {
        (self
            ._aligned_malloc
            .as_ref()
            .expect("Expected function, got error."))(_Size, _Alignment)
    }
    pub unsafe fn _aligned_offset_malloc(
        &self,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void {
        (self
            ._aligned_offset_malloc
            .as_ref()
            .expect("Expected function, got error."))(_Size, _Alignment, _Offset)
    }
    pub unsafe fn _aligned_msize(
        &self,
        _Block: *mut ::std::os::raw::c_void,
        _Alignment: usize,
        _Offset: usize,
    ) -> usize {
        (self
            ._aligned_msize
            .as_ref()
            .expect("Expected function, got error."))(_Block, _Alignment, _Offset)
    }
    pub unsafe fn _aligned_offset_realloc(
        &self,
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void {
        (self
            ._aligned_offset_realloc
            .as_ref()
            .expect("Expected function, got error."))(_Block, _Size, _Alignment, _Offset)
    }
    pub unsafe fn _aligned_offset_recalloc(
        &self,
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void {
        (self
            ._aligned_offset_recalloc
            .as_ref()
            .expect("Expected function, got error."))(
            _Block, _Count, _Size, _Alignment, _Offset
        )
    }
    pub unsafe fn _aligned_realloc(
        &self,
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void {
        (self
            ._aligned_realloc
            .as_ref()
            .expect("Expected function, got error."))(_Block, _Size, _Alignment)
    }
    pub unsafe fn _aligned_recalloc(
        &self,
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void {
        (self
            ._aligned_recalloc
            .as_ref()
            .expect("Expected function, got error."))(_Block, _Count, _Size, _Alignment)
    }
    pub unsafe fn _errno(&self) -> *mut ::std::os::raw::c_int {
        (self._errno.as_ref().expect("Expected function, got error."))()
    }
    pub unsafe fn _set_errno(&self, _Value: ::std::os::raw::c_int) -> errno_t {
        (self
            ._set_errno
            .as_ref()
            .expect("Expected function, got error."))(_Value)
    }
    pub unsafe fn _get_errno(&self, _Value: *mut ::std::os::raw::c_int) -> errno_t {
        (self
            ._get_errno
            .as_ref()
            .expect("Expected function, got error."))(_Value)
    }
    pub unsafe fn __threadid(&self) -> ::std::os::raw::c_ulong {
        (self
            .__threadid
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn __threadhandle(&self) -> usize {
        (self
            .__threadhandle
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn bsearch_s(
        &self,
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _PtFuncCompare: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void {
        (self
            .bsearch_s
            .as_ref()
            .expect("Expected function, got error."))(
            _Key,
            _Base,
            _NumOfElements,
            _SizeOfElements,
            _PtFuncCompare,
            _Context,
        )
    }
    pub unsafe fn qsort_s(
        &self,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _PtFuncCompare: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        _Context: *mut ::std::os::raw::c_void,
    ) {
        (self
            .qsort_s
            .as_ref()
            .expect("Expected function, got error."))(
            _Base,
            _NumOfElements,
            _SizeOfElements,
            _PtFuncCompare,
            _Context,
        )
    }
    pub unsafe fn bsearch(
        &self,
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _PtFuncCompare: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void {
        (self
            .bsearch
            .as_ref()
            .expect("Expected function, got error."))(
            _Key,
            _Base,
            _NumOfElements,
            _SizeOfElements,
            _PtFuncCompare,
        )
    }
    pub unsafe fn qsort(
        &self,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _PtFuncCompare: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) {
        (self.qsort.as_ref().expect("Expected function, got error."))(
            _Base,
            _NumOfElements,
            _SizeOfElements,
            _PtFuncCompare,
        )
    }
    pub unsafe fn _lfind_s(
        &self,
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _PtFuncCompare: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void {
        (self
            ._lfind_s
            .as_ref()
            .expect("Expected function, got error."))(
            _Key,
            _Base,
            _NumOfElements,
            _SizeOfElements,
            _PtFuncCompare,
            _Context,
        )
    }
    pub unsafe fn _lfind(
        &self,
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _PtFuncCompare: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void {
        (self._lfind.as_ref().expect("Expected function, got error."))(
            _Key,
            _Base,
            _NumOfElements,
            _SizeOfElements,
            _PtFuncCompare,
        )
    }
    pub unsafe fn _lsearch_s(
        &self,
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _PtFuncCompare: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void {
        (self
            ._lsearch_s
            .as_ref()
            .expect("Expected function, got error."))(
            _Key,
            _Base,
            _NumOfElements,
            _SizeOfElements,
            _PtFuncCompare,
            _Context,
        )
    }
    pub unsafe fn _lsearch(
        &self,
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _PtFuncCompare: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void {
        (self
            ._lsearch
            .as_ref()
            .expect("Expected function, got error."))(
            _Key,
            _Base,
            _NumOfElements,
            _SizeOfElements,
            _PtFuncCompare,
        )
    }
    pub unsafe fn lfind(
        &self,
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _PtFuncCompare: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void {
        (self.lfind.as_ref().expect("Expected function, got error."))(
            _Key,
            _Base,
            _NumOfElements,
            _SizeOfElements,
            _PtFuncCompare,
        )
    }
    pub unsafe fn lsearch(
        &self,
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _PtFuncCompare: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void {
        (self
            .lsearch
            .as_ref()
            .expect("Expected function, got error."))(
            _Key,
            _Base,
            _NumOfElements,
            _SizeOfElements,
            _PtFuncCompare,
        )
    }
    pub unsafe fn _itow_s(
        &self,
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t {
        (self
            ._itow_s
            .as_ref()
            .expect("Expected function, got error."))(_Value, _Buffer, _BufferCount, _Radix)
    }
    pub unsafe fn _itow(
        &self,
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t {
        (self._itow.as_ref().expect("Expected function, got error."))(_Value, _Buffer, _Radix)
    }
    pub unsafe fn _ltow_s(
        &self,
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t {
        (self
            ._ltow_s
            .as_ref()
            .expect("Expected function, got error."))(_Value, _Buffer, _BufferCount, _Radix)
    }
    pub unsafe fn _ltow(
        &self,
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t {
        (self._ltow.as_ref().expect("Expected function, got error."))(_Value, _Buffer, _Radix)
    }
    pub unsafe fn _ultow_s(
        &self,
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t {
        (self
            ._ultow_s
            .as_ref()
            .expect("Expected function, got error."))(_Value, _Buffer, _BufferCount, _Radix)
    }
    pub unsafe fn _ultow(
        &self,
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t {
        (self._ultow.as_ref().expect("Expected function, got error."))(_Value, _Buffer, _Radix)
    }
    pub unsafe fn wcstod(&self, _String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64 {
        (self.wcstod.as_ref().expect("Expected function, got error."))(_String, _EndPtr)
    }
    pub unsafe fn _wcstod_l(
        &self,
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64 {
        (self
            ._wcstod_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Locale)
    }
    pub unsafe fn wcstol(
        &self,
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long {
        (self.wcstol.as_ref().expect("Expected function, got error."))(_String, _EndPtr, _Radix)
    }
    pub unsafe fn _wcstol_l(
        &self,
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long {
        (self
            ._wcstol_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Radix, _Locale)
    }
    pub unsafe fn wcstoll(
        &self,
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong {
        (self
            .wcstoll
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Radix)
    }
    pub unsafe fn _wcstoll_l(
        &self,
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong {
        (self
            ._wcstoll_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Radix, _Locale)
    }
    pub unsafe fn wcstoul(
        &self,
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong {
        (self
            .wcstoul
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Radix)
    }
    pub unsafe fn _wcstoul_l(
        &self,
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong {
        (self
            ._wcstoul_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Radix, _Locale)
    }
    pub unsafe fn wcstoull(
        &self,
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong {
        (self
            .wcstoull
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Radix)
    }
    pub unsafe fn _wcstoull_l(
        &self,
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong {
        (self
            ._wcstoull_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Radix, _Locale)
    }
    pub unsafe fn wcstold(&self, _String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64 {
        (self
            .wcstold
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr)
    }
    pub unsafe fn _wcstold_l(
        &self,
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64 {
        (self
            ._wcstold_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Locale)
    }
    pub unsafe fn wcstof(&self, _String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f32 {
        (self.wcstof.as_ref().expect("Expected function, got error."))(_String, _EndPtr)
    }
    pub unsafe fn _wcstof_l(
        &self,
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f32 {
        (self
            ._wcstof_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Locale)
    }
    pub unsafe fn _wtof(&self, _String: *const wchar_t) -> f64 {
        (self._wtof.as_ref().expect("Expected function, got error."))(_String)
    }
    pub unsafe fn _wtof_l(&self, _String: *const wchar_t, _Locale: _locale_t) -> f64 {
        (self
            ._wtof_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _Locale)
    }
    pub unsafe fn _wtoi(&self, _String: *const wchar_t) -> ::std::os::raw::c_int {
        (self._wtoi.as_ref().expect("Expected function, got error."))(_String)
    }
    pub unsafe fn _wtoi_l(
        &self,
        _String: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int {
        (self
            ._wtoi_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _Locale)
    }
    pub unsafe fn _wtol(&self, _String: *const wchar_t) -> ::std::os::raw::c_long {
        (self._wtol.as_ref().expect("Expected function, got error."))(_String)
    }
    pub unsafe fn _wtol_l(
        &self,
        _String: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long {
        (self
            ._wtol_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _Locale)
    }
    pub unsafe fn _wtoll(&self, _String: *const wchar_t) -> ::std::os::raw::c_longlong {
        (self._wtoll.as_ref().expect("Expected function, got error."))(_String)
    }
    pub unsafe fn _wtoll_l(
        &self,
        _String: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong {
        (self
            ._wtoll_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _Locale)
    }
    pub unsafe fn _i64tow_s(
        &self,
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t {
        (self
            ._i64tow_s
            .as_ref()
            .expect("Expected function, got error."))(_Value, _Buffer, _BufferCount, _Radix)
    }
    pub unsafe fn _i64tow(
        &self,
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t {
        (self
            ._i64tow
            .as_ref()
            .expect("Expected function, got error."))(_Value, _Buffer, _Radix)
    }
    pub unsafe fn _ui64tow_s(
        &self,
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t {
        (self
            ._ui64tow_s
            .as_ref()
            .expect("Expected function, got error."))(_Value, _Buffer, _BufferCount, _Radix)
    }
    pub unsafe fn _ui64tow(
        &self,
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t {
        (self
            ._ui64tow
            .as_ref()
            .expect("Expected function, got error."))(_Value, _Buffer, _Radix)
    }
    pub unsafe fn _wtoi64(&self, _String: *const wchar_t) -> ::std::os::raw::c_longlong {
        (self
            ._wtoi64
            .as_ref()
            .expect("Expected function, got error."))(_String)
    }
    pub unsafe fn _wtoi64_l(
        &self,
        _String: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong {
        (self
            ._wtoi64_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _Locale)
    }
    pub unsafe fn _wcstoi64(
        &self,
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong {
        (self
            ._wcstoi64
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Radix)
    }
    pub unsafe fn _wcstoi64_l(
        &self,
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong {
        (self
            ._wcstoi64_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Radix, _Locale)
    }
    pub unsafe fn _wcstoui64(
        &self,
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong {
        (self
            ._wcstoui64
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Radix)
    }
    pub unsafe fn _wcstoui64_l(
        &self,
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong {
        (self
            ._wcstoui64_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Radix, _Locale)
    }
    pub unsafe fn _wfullpath(
        &self,
        _Buffer: *mut wchar_t,
        _Path: *const wchar_t,
        _BufferCount: usize,
    ) -> *mut wchar_t {
        (self
            ._wfullpath
            .as_ref()
            .expect("Expected function, got error."))(_Buffer, _Path, _BufferCount)
    }
    pub unsafe fn _wmakepath_s(
        &self,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    ) -> errno_t {
        (self
            ._wmakepath_s
            .as_ref()
            .expect("Expected function, got error."))(
            _Buffer,
            _BufferCount,
            _Drive,
            _Dir,
            _Filename,
            _Ext,
        )
    }
    pub unsafe fn _wmakepath(
        &self,
        _Buffer: *mut wchar_t,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    ) {
        (self
            ._wmakepath
            .as_ref()
            .expect("Expected function, got error."))(_Buffer, _Drive, _Dir, _Filename, _Ext)
    }
    pub unsafe fn _wperror(&self, _ErrMsg: *const wchar_t) {
        (self
            ._wperror
            .as_ref()
            .expect("Expected function, got error."))(_ErrMsg)
    }
    pub unsafe fn _wsplitpath(
        &self,
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _Dir: *mut wchar_t,
        _Filename: *mut wchar_t,
        _Ext: *mut wchar_t,
    ) {
        (self
            ._wsplitpath
            .as_ref()
            .expect("Expected function, got error."))(
            _FullPath, _Drive, _Dir, _Filename, _Ext
        )
    }
    pub unsafe fn _wsplitpath_s(
        &self,
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _DriveCount: usize,
        _Dir: *mut wchar_t,
        _DirCount: usize,
        _Filename: *mut wchar_t,
        _FilenameCount: usize,
        _Ext: *mut wchar_t,
        _ExtCount: usize,
    ) -> errno_t {
        (self
            ._wsplitpath_s
            .as_ref()
            .expect("Expected function, got error."))(
            _FullPath,
            _Drive,
            _DriveCount,
            _Dir,
            _DirCount,
            _Filename,
            _FilenameCount,
            _Ext,
            _ExtCount,
        )
    }
    pub unsafe fn _wdupenv_s(
        &self,
        _Buffer: *mut *mut wchar_t,
        _BufferCount: *mut usize,
        _VarName: *const wchar_t,
    ) -> errno_t {
        (self
            ._wdupenv_s
            .as_ref()
            .expect("Expected function, got error."))(_Buffer, _BufferCount, _VarName)
    }
    pub unsafe fn _wgetenv(&self, _VarName: *const wchar_t) -> *mut wchar_t {
        (self
            ._wgetenv
            .as_ref()
            .expect("Expected function, got error."))(_VarName)
    }
    pub unsafe fn _wgetenv_s(
        &self,
        _RequiredCount: *mut usize,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _VarName: *const wchar_t,
    ) -> errno_t {
        (self
            ._wgetenv_s
            .as_ref()
            .expect("Expected function, got error."))(
            _RequiredCount,
            _Buffer,
            _BufferCount,
            _VarName,
        )
    }
    pub unsafe fn _wputenv(&self, _EnvString: *const wchar_t) -> ::std::os::raw::c_int {
        (self
            ._wputenv
            .as_ref()
            .expect("Expected function, got error."))(_EnvString)
    }
    pub unsafe fn _wputenv_s(&self, _Name: *const wchar_t, _Value: *const wchar_t) -> errno_t {
        (self
            ._wputenv_s
            .as_ref()
            .expect("Expected function, got error."))(_Name, _Value)
    }
    pub unsafe fn _wsearchenv_s(
        &self,
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
    ) -> errno_t {
        (self
            ._wsearchenv_s
            .as_ref()
            .expect("Expected function, got error."))(
            _Filename, _VarName, _Buffer, _BufferCount
        )
    }
    pub unsafe fn _wsearchenv(
        &self,
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _ResultPath: *mut wchar_t,
    ) {
        (self
            ._wsearchenv
            .as_ref()
            .expect("Expected function, got error."))(_Filename, _VarName, _ResultPath)
    }
    pub unsafe fn _wsystem(&self, _Command: *const wchar_t) -> ::std::os::raw::c_int {
        (self
            ._wsystem
            .as_ref()
            .expect("Expected function, got error."))(_Command)
    }
    pub unsafe fn _swab(
        &self,
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    ) {
        (self._swab.as_ref().expect("Expected function, got error."))(_Buf1, _Buf2, _SizeInBytes)
    }
    pub unsafe fn exit(&self, _Code: ::std::os::raw::c_int) -> ! {
        (self.exit.as_ref().expect("Expected function, got error."))(_Code)
    }
    pub unsafe fn _exit(&self, _Code: ::std::os::raw::c_int) -> ! {
        (self._exit.as_ref().expect("Expected function, got error."))(_Code)
    }
    pub unsafe fn _Exit(&self, _Code: ::std::os::raw::c_int) -> ! {
        (self._Exit.as_ref().expect("Expected function, got error."))(_Code)
    }
    pub unsafe fn quick_exit(&self, _Code: ::std::os::raw::c_int) -> ! {
        (self
            .quick_exit
            .as_ref()
            .expect("Expected function, got error."))(_Code)
    }
    pub unsafe fn abort(&self) -> ! {
        (self.abort.as_ref().expect("Expected function, got error."))()
    }
    pub unsafe fn _set_abort_behavior(
        &self,
        _Flags: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint {
        (self
            ._set_abort_behavior
            .as_ref()
            .expect("Expected function, got error."))(_Flags, _Mask)
    }
    pub unsafe fn atexit(
        &self,
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int {
        (self.atexit.as_ref().expect("Expected function, got error."))(arg1)
    }
    pub unsafe fn _onexit(&self, _Func: _onexit_t) -> _onexit_t {
        (self
            ._onexit
            .as_ref()
            .expect("Expected function, got error."))(_Func)
    }
    pub unsafe fn at_quick_exit(
        &self,
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int {
        (self
            .at_quick_exit
            .as_ref()
            .expect("Expected function, got error."))(arg1)
    }
    pub unsafe fn _set_purecall_handler(&self, _Handler: _purecall_handler) -> _purecall_handler {
        (self
            ._set_purecall_handler
            .as_ref()
            .expect("Expected function, got error."))(_Handler)
    }
    pub unsafe fn _get_purecall_handler(&self) -> _purecall_handler {
        (self
            ._get_purecall_handler
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn _set_invalid_parameter_handler(
        &self,
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler {
        (self
            ._set_invalid_parameter_handler
            .as_ref()
            .expect("Expected function, got error."))(_Handler)
    }
    pub unsafe fn _get_invalid_parameter_handler(&self) -> _invalid_parameter_handler {
        (self
            ._get_invalid_parameter_handler
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn _set_thread_local_invalid_parameter_handler(
        &self,
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler {
        (self
            ._set_thread_local_invalid_parameter_handler
            .as_ref()
            .expect("Expected function, got error."))(_Handler)
    }
    pub unsafe fn _get_thread_local_invalid_parameter_handler(&self) -> _invalid_parameter_handler {
        (self
            ._get_thread_local_invalid_parameter_handler
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn _set_error_mode(&self, _Mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        (self
            ._set_error_mode
            .as_ref()
            .expect("Expected function, got error."))(_Mode)
    }
    pub unsafe fn __doserrno(&self) -> *mut ::std::os::raw::c_ulong {
        (self
            .__doserrno
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn _set_doserrno(&self, _Value: ::std::os::raw::c_ulong) -> errno_t {
        (self
            ._set_doserrno
            .as_ref()
            .expect("Expected function, got error."))(_Value)
    }
    pub unsafe fn _get_doserrno(&self, _Value: *mut ::std::os::raw::c_ulong) -> errno_t {
        (self
            ._get_doserrno
            .as_ref()
            .expect("Expected function, got error."))(_Value)
    }
    pub unsafe fn __sys_errlist(&self) -> *mut *mut ::std::os::raw::c_char {
        (self
            .__sys_errlist
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn __sys_nerr(&self) -> *mut ::std::os::raw::c_int {
        (self
            .__sys_nerr
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn perror(&self, _ErrMsg: *const ::std::os::raw::c_char) {
        (self.perror.as_ref().expect("Expected function, got error."))(_ErrMsg)
    }
    pub unsafe fn __p__pgmptr(&self) -> *mut *mut ::std::os::raw::c_char {
        (self
            .__p__pgmptr
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn __p__wpgmptr(&self) -> *mut *mut wchar_t {
        (self
            .__p__wpgmptr
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn __p__fmode(&self) -> *mut ::std::os::raw::c_int {
        (self
            .__p__fmode
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn _get_pgmptr(&self, _Value: *mut *mut ::std::os::raw::c_char) -> errno_t {
        (self
            ._get_pgmptr
            .as_ref()
            .expect("Expected function, got error."))(_Value)
    }
    pub unsafe fn _get_wpgmptr(&self, _Value: *mut *mut wchar_t) -> errno_t {
        (self
            ._get_wpgmptr
            .as_ref()
            .expect("Expected function, got error."))(_Value)
    }
    pub unsafe fn _set_fmode(&self, _Mode: ::std::os::raw::c_int) -> errno_t {
        (self
            ._set_fmode
            .as_ref()
            .expect("Expected function, got error."))(_Mode)
    }
    pub unsafe fn _get_fmode(&self, _PMode: *mut ::std::os::raw::c_int) -> errno_t {
        (self
            ._get_fmode
            .as_ref()
            .expect("Expected function, got error."))(_PMode)
    }
    pub unsafe fn abs(&self, _Number: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        (self.abs.as_ref().expect("Expected function, got error."))(_Number)
    }
    pub unsafe fn labs(&self, _Number: ::std::os::raw::c_long) -> ::std::os::raw::c_long {
        (self.labs.as_ref().expect("Expected function, got error."))(_Number)
    }
    pub unsafe fn llabs(&self, _Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong {
        (self.llabs.as_ref().expect("Expected function, got error."))(_Number)
    }
    pub unsafe fn _abs64(&self, _Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong {
        (self._abs64.as_ref().expect("Expected function, got error."))(_Number)
    }
    pub unsafe fn _byteswap_ushort(
        &self,
        _Number: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_ushort {
        (self
            ._byteswap_ushort
            .as_ref()
            .expect("Expected function, got error."))(_Number)
    }
    pub unsafe fn _byteswap_ulong(
        &self,
        _Number: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong {
        (self
            ._byteswap_ulong
            .as_ref()
            .expect("Expected function, got error."))(_Number)
    }
    pub unsafe fn _byteswap_uint64(
        &self,
        _Number: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_ulonglong {
        (self
            ._byteswap_uint64
            .as_ref()
            .expect("Expected function, got error."))(_Number)
    }
    pub unsafe fn div(
        &self,
        _Numerator: ::std::os::raw::c_int,
        _Denominator: ::std::os::raw::c_int,
    ) -> div_t {
        (self.div.as_ref().expect("Expected function, got error."))(_Numerator, _Denominator)
    }
    pub unsafe fn ldiv(
        &self,
        _Numerator: ::std::os::raw::c_long,
        _Denominator: ::std::os::raw::c_long,
    ) -> ldiv_t {
        (self.ldiv.as_ref().expect("Expected function, got error."))(_Numerator, _Denominator)
    }
    pub unsafe fn lldiv(
        &self,
        _Numerator: ::std::os::raw::c_longlong,
        _Denominator: ::std::os::raw::c_longlong,
    ) -> lldiv_t {
        (self.lldiv.as_ref().expect("Expected function, got error."))(_Numerator, _Denominator)
    }
    pub unsafe fn _rotl(
        &self,
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint {
        (self._rotl.as_ref().expect("Expected function, got error."))(_Value, _Shift)
    }
    pub unsafe fn _lrotl(
        &self,
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong {
        (self._lrotl.as_ref().expect("Expected function, got error."))(_Value, _Shift)
    }
    pub unsafe fn _rotl64(
        &self,
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong {
        (self
            ._rotl64
            .as_ref()
            .expect("Expected function, got error."))(_Value, _Shift)
    }
    pub unsafe fn _rotr(
        &self,
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint {
        (self._rotr.as_ref().expect("Expected function, got error."))(_Value, _Shift)
    }
    pub unsafe fn _lrotr(
        &self,
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong {
        (self._lrotr.as_ref().expect("Expected function, got error."))(_Value, _Shift)
    }
    pub unsafe fn _rotr64(
        &self,
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong {
        (self
            ._rotr64
            .as_ref()
            .expect("Expected function, got error."))(_Value, _Shift)
    }
    pub unsafe fn srand(&self, _Seed: ::std::os::raw::c_uint) {
        (self.srand.as_ref().expect("Expected function, got error."))(_Seed)
    }
    pub unsafe fn rand(&self) -> ::std::os::raw::c_int {
        (self.rand.as_ref().expect("Expected function, got error."))()
    }
    pub unsafe fn atof(&self, _String: *const ::std::os::raw::c_char) -> f64 {
        (self.atof.as_ref().expect("Expected function, got error."))(_String)
    }
    pub unsafe fn atoi(&self, _String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
        (self.atoi.as_ref().expect("Expected function, got error."))(_String)
    }
    pub unsafe fn atol(&self, _String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long {
        (self.atol.as_ref().expect("Expected function, got error."))(_String)
    }
    pub unsafe fn atoll(
        &self,
        _String: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong {
        (self.atoll.as_ref().expect("Expected function, got error."))(_String)
    }
    pub unsafe fn _atoi64(
        &self,
        _String: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong {
        (self
            ._atoi64
            .as_ref()
            .expect("Expected function, got error."))(_String)
    }
    pub unsafe fn _atof_l(
        &self,
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64 {
        (self
            ._atof_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _Locale)
    }
    pub unsafe fn _atoi_l(
        &self,
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int {
        (self
            ._atoi_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _Locale)
    }
    pub unsafe fn _atol_l(
        &self,
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long {
        (self
            ._atol_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _Locale)
    }
    pub unsafe fn _atoll_l(
        &self,
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong {
        (self
            ._atoll_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _Locale)
    }
    pub unsafe fn _atoi64_l(
        &self,
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong {
        (self
            ._atoi64_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _Locale)
    }
    pub unsafe fn _atoflt(
        &self,
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self
            ._atoflt
            .as_ref()
            .expect("Expected function, got error."))(_Result, _String)
    }
    pub unsafe fn _atodbl(
        &self,
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self
            ._atodbl
            .as_ref()
            .expect("Expected function, got error."))(_Result, _String)
    }
    pub unsafe fn _atoldbl(
        &self,
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self
            ._atoldbl
            .as_ref()
            .expect("Expected function, got error."))(_Result, _String)
    }
    pub unsafe fn _atoflt_l(
        &self,
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int {
        (self
            ._atoflt_l
            .as_ref()
            .expect("Expected function, got error."))(_Result, _String, _Locale)
    }
    pub unsafe fn _atodbl_l(
        &self,
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int {
        (self
            ._atodbl_l
            .as_ref()
            .expect("Expected function, got error."))(_Result, _String, _Locale)
    }
    pub unsafe fn _atoldbl_l(
        &self,
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int {
        (self
            ._atoldbl_l
            .as_ref()
            .expect("Expected function, got error."))(_Result, _String, _Locale)
    }
    pub unsafe fn strtof(
        &self,
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f32 {
        (self.strtof.as_ref().expect("Expected function, got error."))(_String, _EndPtr)
    }
    pub unsafe fn _strtof_l(
        &self,
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f32 {
        (self
            ._strtof_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Locale)
    }
    pub unsafe fn strtod(
        &self,
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64 {
        (self.strtod.as_ref().expect("Expected function, got error."))(_String, _EndPtr)
    }
    pub unsafe fn _strtod_l(
        &self,
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64 {
        (self
            ._strtod_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Locale)
    }
    pub unsafe fn strtold(
        &self,
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64 {
        (self
            .strtold
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr)
    }
    pub unsafe fn _strtold_l(
        &self,
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64 {
        (self
            ._strtold_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Locale)
    }
    pub unsafe fn strtol(
        &self,
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long {
        (self.strtol.as_ref().expect("Expected function, got error."))(_String, _EndPtr, _Radix)
    }
    pub unsafe fn _strtol_l(
        &self,
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long {
        (self
            ._strtol_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Radix, _Locale)
    }
    pub unsafe fn strtoll(
        &self,
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong {
        (self
            .strtoll
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Radix)
    }
    pub unsafe fn _strtoll_l(
        &self,
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong {
        (self
            ._strtoll_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Radix, _Locale)
    }
    pub unsafe fn strtoul(
        &self,
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong {
        (self
            .strtoul
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Radix)
    }
    pub unsafe fn _strtoul_l(
        &self,
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong {
        (self
            ._strtoul_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Radix, _Locale)
    }
    pub unsafe fn strtoull(
        &self,
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong {
        (self
            .strtoull
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Radix)
    }
    pub unsafe fn _strtoull_l(
        &self,
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong {
        (self
            ._strtoull_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Radix, _Locale)
    }
    pub unsafe fn _strtoi64(
        &self,
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong {
        (self
            ._strtoi64
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Radix)
    }
    pub unsafe fn _strtoi64_l(
        &self,
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong {
        (self
            ._strtoi64_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Radix, _Locale)
    }
    pub unsafe fn _strtoui64(
        &self,
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong {
        (self
            ._strtoui64
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Radix)
    }
    pub unsafe fn _strtoui64_l(
        &self,
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong {
        (self
            ._strtoui64_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _EndPtr, _Radix, _Locale)
    }
    pub unsafe fn _itoa_s(
        &self,
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t {
        (self
            ._itoa_s
            .as_ref()
            .expect("Expected function, got error."))(_Value, _Buffer, _BufferCount, _Radix)
    }
    pub unsafe fn _itoa(
        &self,
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char {
        (self._itoa.as_ref().expect("Expected function, got error."))(_Value, _Buffer, _Radix)
    }
    pub unsafe fn _ltoa_s(
        &self,
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t {
        (self
            ._ltoa_s
            .as_ref()
            .expect("Expected function, got error."))(_Value, _Buffer, _BufferCount, _Radix)
    }
    pub unsafe fn _ltoa(
        &self,
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char {
        (self._ltoa.as_ref().expect("Expected function, got error."))(_Value, _Buffer, _Radix)
    }
    pub unsafe fn _ultoa_s(
        &self,
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t {
        (self
            ._ultoa_s
            .as_ref()
            .expect("Expected function, got error."))(_Value, _Buffer, _BufferCount, _Radix)
    }
    pub unsafe fn _ultoa(
        &self,
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char {
        (self._ultoa.as_ref().expect("Expected function, got error."))(_Value, _Buffer, _Radix)
    }
    pub unsafe fn _i64toa_s(
        &self,
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t {
        (self
            ._i64toa_s
            .as_ref()
            .expect("Expected function, got error."))(_Value, _Buffer, _BufferCount, _Radix)
    }
    pub unsafe fn _i64toa(
        &self,
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char {
        (self
            ._i64toa
            .as_ref()
            .expect("Expected function, got error."))(_Value, _Buffer, _Radix)
    }
    pub unsafe fn _ui64toa_s(
        &self,
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t {
        (self
            ._ui64toa_s
            .as_ref()
            .expect("Expected function, got error."))(_Value, _Buffer, _BufferCount, _Radix)
    }
    pub unsafe fn _ui64toa(
        &self,
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char {
        (self
            ._ui64toa
            .as_ref()
            .expect("Expected function, got error."))(_Value, _Buffer, _Radix)
    }
    pub unsafe fn _ecvt_s(
        &self,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t {
        (self
            ._ecvt_s
            .as_ref()
            .expect("Expected function, got error."))(
            _Buffer,
            _BufferCount,
            _Value,
            _DigitCount,
            _PtDec,
            _PtSign,
        )
    }
    pub unsafe fn _ecvt(
        &self,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char {
        (self._ecvt.as_ref().expect("Expected function, got error."))(
            _Value,
            _DigitCount,
            _PtDec,
            _PtSign,
        )
    }
    pub unsafe fn _fcvt_s(
        &self,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t {
        (self
            ._fcvt_s
            .as_ref()
            .expect("Expected function, got error."))(
            _Buffer,
            _BufferCount,
            _Value,
            _FractionalDigitCount,
            _PtDec,
            _PtSign,
        )
    }
    pub unsafe fn _fcvt(
        &self,
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char {
        (self._fcvt.as_ref().expect("Expected function, got error."))(
            _Value,
            _FractionalDigitCount,
            _PtDec,
            _PtSign,
        )
    }
    pub unsafe fn _gcvt_s(
        &self,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
    ) -> errno_t {
        (self
            ._gcvt_s
            .as_ref()
            .expect("Expected function, got error."))(
            _Buffer, _BufferCount, _Value, _DigitCount
        )
    }
    pub unsafe fn _gcvt(
        &self,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char {
        (self._gcvt.as_ref().expect("Expected function, got error."))(_Value, _DigitCount, _Buffer)
    }
    pub unsafe fn ___mb_cur_max_func(&self) -> ::std::os::raw::c_int {
        (self
            .___mb_cur_max_func
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn ___mb_cur_max_l_func(&self, arg1: _locale_t) -> ::std::os::raw::c_int {
        (self
            .___mb_cur_max_l_func
            .as_ref()
            .expect("Expected function, got error."))(arg1)
    }
    pub unsafe fn mblen(
        &self,
        _Ch: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int {
        (self.mblen.as_ref().expect("Expected function, got error."))(_Ch, _MaxCount)
    }
    pub unsafe fn _mblen_l(
        &self,
        _Ch: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int {
        (self
            ._mblen_l
            .as_ref()
            .expect("Expected function, got error."))(_Ch, _MaxCount, _Locale)
    }
    pub unsafe fn _mbstrlen(&self, _String: *const ::std::os::raw::c_char) -> usize {
        (self
            ._mbstrlen
            .as_ref()
            .expect("Expected function, got error."))(_String)
    }
    pub unsafe fn _mbstrlen_l(
        &self,
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> usize {
        (self
            ._mbstrlen_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _Locale)
    }
    pub unsafe fn _mbstrnlen(
        &self,
        _String: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> usize {
        (self
            ._mbstrnlen
            .as_ref()
            .expect("Expected function, got error."))(_String, _MaxCount)
    }
    pub unsafe fn _mbstrnlen_l(
        &self,
        _String: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize {
        (self
            ._mbstrnlen_l
            .as_ref()
            .expect("Expected function, got error."))(_String, _MaxCount, _Locale)
    }
    pub unsafe fn mbtowc(
        &self,
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
    ) -> ::std::os::raw::c_int {
        (self.mbtowc.as_ref().expect("Expected function, got error."))(
            _DstCh,
            _SrcCh,
            _SrcSizeInBytes,
        )
    }
    pub unsafe fn _mbtowc_l(
        &self,
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int {
        (self
            ._mbtowc_l
            .as_ref()
            .expect("Expected function, got error."))(
            _DstCh, _SrcCh, _SrcSizeInBytes, _Locale
        )
    }
    pub unsafe fn mbstowcs_s(
        &self,
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> errno_t {
        (self
            .mbstowcs_s
            .as_ref()
            .expect("Expected function, got error."))(
            _PtNumOfCharConverted,
            _DstBuf,
            _SizeInWords,
            _SrcBuf,
            _MaxCount,
        )
    }
    pub unsafe fn mbstowcs(
        &self,
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> usize {
        (self
            .mbstowcs
            .as_ref()
            .expect("Expected function, got error."))(_Dest, _Source, _MaxCount)
    }
    pub unsafe fn _mbstowcs_s_l(
        &self,
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t {
        (self
            ._mbstowcs_s_l
            .as_ref()
            .expect("Expected function, got error."))(
            _PtNumOfCharConverted,
            _DstBuf,
            _SizeInWords,
            _SrcBuf,
            _MaxCount,
            _Locale,
        )
    }
    pub unsafe fn _mbstowcs_l(
        &self,
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize {
        (self
            ._mbstowcs_l
            .as_ref()
            .expect("Expected function, got error."))(_Dest, _Source, _MaxCount, _Locale)
    }
    pub unsafe fn wctomb(
        &self,
        _MbCh: *mut ::std::os::raw::c_char,
        _WCh: wchar_t,
    ) -> ::std::os::raw::c_int {
        (self.wctomb.as_ref().expect("Expected function, got error."))(_MbCh, _WCh)
    }
    pub unsafe fn _wctomb_l(
        &self,
        _MbCh: *mut ::std::os::raw::c_char,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int {
        (self
            ._wctomb_l
            .as_ref()
            .expect("Expected function, got error."))(_MbCh, _WCh, _Locale)
    }
    pub unsafe fn wctomb_s(
        &self,
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _WCh: wchar_t,
    ) -> errno_t {
        (self
            .wctomb_s
            .as_ref()
            .expect("Expected function, got error."))(
            _SizeConverted, _MbCh, _SizeInBytes, _WCh
        )
    }
    pub unsafe fn _wctomb_s_l(
        &self,
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> errno_t {
        (self
            ._wctomb_s_l
            .as_ref()
            .expect("Expected function, got error."))(
            _SizeConverted,
            _MbCh,
            _SizeInBytes,
            _WCh,
            _Locale,
        )
    }
    pub unsafe fn wcstombs_s(
        &self,
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
    ) -> errno_t {
        (self
            .wcstombs_s
            .as_ref()
            .expect("Expected function, got error."))(
            _PtNumOfCharConverted,
            _Dst,
            _DstSizeInBytes,
            _Src,
            _MaxCountInBytes,
        )
    }
    pub unsafe fn wcstombs(
        &self,
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
    ) -> usize {
        (self
            .wcstombs
            .as_ref()
            .expect("Expected function, got error."))(_Dest, _Source, _MaxCount)
    }
    pub unsafe fn _wcstombs_s_l(
        &self,
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
        _Locale: _locale_t,
    ) -> errno_t {
        (self
            ._wcstombs_s_l
            .as_ref()
            .expect("Expected function, got error."))(
            _PtNumOfCharConverted,
            _Dst,
            _DstSizeInBytes,
            _Src,
            _MaxCountInBytes,
            _Locale,
        )
    }
    pub unsafe fn _wcstombs_l(
        &self,
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize {
        (self
            ._wcstombs_l
            .as_ref()
            .expect("Expected function, got error."))(_Dest, _Source, _MaxCount, _Locale)
    }
    pub unsafe fn _fullpath(
        &self,
        _Buffer: *mut ::std::os::raw::c_char,
        _Path: *const ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> *mut ::std::os::raw::c_char {
        (self
            ._fullpath
            .as_ref()
            .expect("Expected function, got error."))(_Buffer, _Path, _BufferCount)
    }
    pub unsafe fn _makepath_s(
        &self,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    ) -> errno_t {
        (self
            ._makepath_s
            .as_ref()
            .expect("Expected function, got error."))(
            _Buffer,
            _BufferCount,
            _Drive,
            _Dir,
            _Filename,
            _Ext,
        )
    }
    pub unsafe fn _makepath(
        &self,
        _Buffer: *mut ::std::os::raw::c_char,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    ) {
        (self
            ._makepath
            .as_ref()
            .expect("Expected function, got error."))(_Buffer, _Drive, _Dir, _Filename, _Ext)
    }
    pub unsafe fn _splitpath(
        &self,
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _Dir: *mut ::std::os::raw::c_char,
        _Filename: *mut ::std::os::raw::c_char,
        _Ext: *mut ::std::os::raw::c_char,
    ) {
        (self
            ._splitpath
            .as_ref()
            .expect("Expected function, got error."))(
            _FullPath, _Drive, _Dir, _Filename, _Ext
        )
    }
    pub unsafe fn _splitpath_s(
        &self,
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _DriveCount: usize,
        _Dir: *mut ::std::os::raw::c_char,
        _DirCount: usize,
        _Filename: *mut ::std::os::raw::c_char,
        _FilenameCount: usize,
        _Ext: *mut ::std::os::raw::c_char,
        _ExtCount: usize,
    ) -> errno_t {
        (self
            ._splitpath_s
            .as_ref()
            .expect("Expected function, got error."))(
            _FullPath,
            _Drive,
            _DriveCount,
            _Dir,
            _DirCount,
            _Filename,
            _FilenameCount,
            _Ext,
            _ExtCount,
        )
    }
    pub unsafe fn getenv_s(
        &self,
        _RequiredCount: *mut usize,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: rsize_t,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t {
        (self
            .getenv_s
            .as_ref()
            .expect("Expected function, got error."))(
            _RequiredCount,
            _Buffer,
            _BufferCount,
            _VarName,
        )
    }
    pub unsafe fn __p___argc(&self) -> *mut ::std::os::raw::c_int {
        (self
            .__p___argc
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn __p___argv(&self) -> *mut *mut *mut ::std::os::raw::c_char {
        (self
            .__p___argv
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn __p___wargv(&self) -> *mut *mut *mut wchar_t {
        (self
            .__p___wargv
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn __p__environ(&self) -> *mut *mut *mut ::std::os::raw::c_char {
        (self
            .__p__environ
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn __p__wenviron(&self) -> *mut *mut *mut wchar_t {
        (self
            .__p__wenviron
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn getenv(
        &self,
        _VarName: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char {
        (self.getenv.as_ref().expect("Expected function, got error."))(_VarName)
    }
    pub unsafe fn _dupenv_s(
        &self,
        _Buffer: *mut *mut ::std::os::raw::c_char,
        _BufferCount: *mut usize,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t {
        (self
            ._dupenv_s
            .as_ref()
            .expect("Expected function, got error."))(_Buffer, _BufferCount, _VarName)
    }
    pub unsafe fn system(&self, _Command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
        (self.system.as_ref().expect("Expected function, got error."))(_Command)
    }
    pub unsafe fn _putenv(
        &self,
        _EnvString: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self
            ._putenv
            .as_ref()
            .expect("Expected function, got error."))(_EnvString)
    }
    pub unsafe fn _putenv_s(
        &self,
        _Name: *const ::std::os::raw::c_char,
        _Value: *const ::std::os::raw::c_char,
    ) -> errno_t {
        (self
            ._putenv_s
            .as_ref()
            .expect("Expected function, got error."))(_Name, _Value)
    }
    pub unsafe fn _searchenv_s(
        &self,
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> errno_t {
        (self
            ._searchenv_s
            .as_ref()
            .expect("Expected function, got error."))(
            _Filename, _VarName, _Buffer, _BufferCount
        )
    }
    pub unsafe fn _searchenv(
        &self,
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
    ) {
        (self
            ._searchenv
            .as_ref()
            .expect("Expected function, got error."))(_Filename, _VarName, _Buffer)
    }
    pub unsafe fn _seterrormode(&self, _Mode: ::std::os::raw::c_int) {
        (self
            ._seterrormode
            .as_ref()
            .expect("Expected function, got error."))(_Mode)
    }
    pub unsafe fn _beep(
        &self,
        _Frequency: ::std::os::raw::c_uint,
        _Duration: ::std::os::raw::c_uint,
    ) {
        (self._beep.as_ref().expect("Expected function, got error."))(_Frequency, _Duration)
    }
    pub unsafe fn _sleep(&self, _Duration: ::std::os::raw::c_ulong) {
        (self._sleep.as_ref().expect("Expected function, got error."))(_Duration)
    }
    pub unsafe fn ecvt(
        &self,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char {
        (self.ecvt.as_ref().expect("Expected function, got error."))(
            _Value,
            _DigitCount,
            _PtDec,
            _PtSign,
        )
    }
    pub unsafe fn fcvt(
        &self,
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char {
        (self.fcvt.as_ref().expect("Expected function, got error."))(
            _Value,
            _FractionalDigitCount,
            _PtDec,
            _PtSign,
        )
    }
    pub unsafe fn gcvt(
        &self,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char {
        (self.gcvt.as_ref().expect("Expected function, got error."))(_Value, _DigitCount, _DstBuf)
    }
    pub unsafe fn itoa(
        &self,
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char {
        (self.itoa.as_ref().expect("Expected function, got error."))(_Value, _Buffer, _Radix)
    }
    pub unsafe fn ltoa(
        &self,
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char {
        (self.ltoa.as_ref().expect("Expected function, got error."))(_Value, _Buffer, _Radix)
    }
    pub unsafe fn swab(
        &self,
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    ) {
        (self.swab.as_ref().expect("Expected function, got error."))(_Buf1, _Buf2, _SizeInBytes)
    }
    pub unsafe fn ultoa(
        &self,
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char {
        (self.ultoa.as_ref().expect("Expected function, got error."))(_Value, _Buffer, _Radix)
    }
    pub unsafe fn putenv(
        &self,
        _EnvString: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self.putenv.as_ref().expect("Expected function, got error."))(_EnvString)
    }
    pub unsafe fn onexit(&self, _Func: _onexit_t) -> _onexit_t {
        (self.onexit.as_ref().expect("Expected function, got error."))(_Func)
    }
    /// \brief Function initializing the interaction between a tool-side implementation and target-side implementation.
    ///
    ///This function returns the version and vendor information for a particular
    ///implementation of the MCD API in order to initialize the interaction between
    ///a tool and a target-side implementation.
    ///
    ///\param version_req      [in]   : MCD API version as requested by an upper layer.
    ///\param impl_info        [out]  : Information about the implementation of the MCD
    ///API implementation.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE     if successful.\n
    ///\c MCD_ERR_GENERAL  if target implementation is incompatible.
    pub unsafe fn mcd_initialize_f(
        &self,
        version_req: *const mcd_api_version_st,
        impl_info: *mut mcd_impl_version_info_st,
    ) -> mcd_return_et {
        (self
            .mcd_initialize_f
            .as_ref()
            .expect("Expected function, got error."))(version_req, impl_info)
    }
    /// \brief Function cleaning up all core and server connections from a tool.
    ///
    ///This function allows to perform some cleanup functionality for all core
    ///connections to a particular debugger before closing the connections.
    pub unsafe fn mcd_exit_f(&self) {
        (self
            .mcd_exit_f
            .as_ref()
            .expect("Expected function, got error."))()
    }
    /// \brief Function returning a list of available servers.
    ///
    ///This function returns a list of available (running or installed) servers.
    ///
    ///\param host        [in]  : String containing the host name.
    ///\param running     [in]  : Selects between running and installed servers.
    ///\param start_index [in]  : Start index of the queried servers. This refers to
    ///an internal list of the target side implementation.
    ///\param num_servers [in]  : The number of queried servers starting from the
    ///defined \c start_index. If it is set to '0', no
    ///server descriptions are returned but the number of
    ///all available servers.
    ///\param num_servers [out] : The number of returned servers. In case the input
    ///value of \c num_servers is '0', this is the number
    ///of all available servers.
    ///\param server_info [out] : Server information. This is an array allocated by
    ///the calling function.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE        if successful.\n
    ///\c MCD_ERR_CONNECTION  if query failed.
    pub unsafe fn mcd_qry_servers_f(
        &self,
        host: *const mcd_char_t,
        running: mcd_bool_t,
        start_index: u32,
        num_servers: *mut u32,
        server_info: *mut mcd_server_info_st,
    ) -> mcd_return_et {
        (self
            .mcd_qry_servers_f
            .as_ref()
            .expect("Expected function, got error."))(
            host,
            running,
            start_index,
            num_servers,
            server_info,
        )
    }
    /// \brief Function opening the connection to a server on a host computer.
    ///
    ///This function opens the connection to a server on a host computer and updates
    ///the internal core information data base. It contains the information about
    ///all cores of devices which are simulated on the host computer or which are
    ///accessible on real silicon through a specific tool access hardware to the
    ///host. This data base can then be queried at system, device and core level.
    ///
    ///For real hardware devices, a server connection needs to be opened for each
    ///access hardware. This allows individual control of the access parameters.
    ///
    ///\param config_string [in]: Allows the configuration of the server connection by a
    ///character string. Delimiters are blanks, tabs and line breaks. Value
    ///strings are always enclosed with "double quotes". Bool values can be
    ///"TRUE" or "FALSE" (both in small letters).
    ///
    ///Pre-defined \a config_string string parameters:
    ///
    ///- McdHostName= \c \<string\>       : Optional host name. Default value is \c "localhost".
    ///- McdServerName= \c "<string>"     : Name of the server to connect to.
    ///- McdSystemInstance= \c "<string>" : Name of the simulation system instance this server
    ///is associated with.
    ///- McdServerKey= \c <string>        : Static key for this specific server.
    ///- McdExitIfLastClient \c <bool>    : If \ref mcd_close_server_f() is called for the last
    ///client connection, the server will terminate.
    ///
    ///Additional pre-defined string parameters for real hardware:
    ///
    ///- McdAccHw= \c <string>            : Restricts this server to connect to devices via a
    ///specific access hardware as determined by the string.
    ///- McdAccHw.Frequency=<unsigned>    : Decimal (32 bit) value setting the frequency of the
    ///physical I/F (e.g. according to IEEE 1149.1)
    ///- McdAccHw.PostRstDelay=<unsigned> : Delay [microseconds] after reset before first
    ///interaction with the device is allowed.
    ///- McdAccHw.Device="<string>"       : Description of connected device.
    ///- McdAccHw.DeviceId=<unsigned>     : Device ID (e.g. IEEE 1149.1 ID) of connected device.
    ///- McdAccHw.AutoDetect=<bool>       : If set to "TRUE" the access HW detects the device
    ///(DeviceId and Device will be ignored).
    ///- McdAccHw.Address="<string>"      : Optional (e.g. TCP/IP address of access hardware).
    ///- McdAccHw.Port=<unsigned>         : Optional (e.g. TCP/IP port number of access hardware).
    ///
    ///Interactive Server Connection Setup
    ///
    ///If a server(s) is running, \ref mcd_open_server_f() can be called with an empty or NULL pointer
    ///\c config_string. Then it connects to the first possible simulation system or, for real hardware,
    ///access hardware path. A second call (while the first server is still open) will open the second
    ///possible simulation system or access hardware path and so on.
    ///In order to restrict the potential list of connections to a server, "McdServerName"
    ///(and "McdServerKey") can be optionally provided with \c config_string.
    ///
    ///\ref mcd_qry_server_config_f() returns the complete configuration string for a server/device connection.
    ///This allows storing this configuration to avoid an interactive server connection setup for the next
    ///debug session. This is in particular useful for Real HW multi device systems in order to connect the
    ///devices step by step.
    ///
    ///Server and System Keys
    ///
    ///A server can optionally require a key for access (\c config_string parameter "McdServerKey").
    ///This allows for example to prevent an unauthorized access to a test stand which might cause damage.
    ///A system key additionally allows to dynamically claim a server or to prevent several users from
    ///unintentionally accessing the same system at the same time through a specific set of servers.
    ///
    ///A key can be a password string or a sequence of decimal or hexadecimal numbers separated by whitespaces.
    ///
    ///\param system_key      [in]  : A server is claimed by this key when being opened.
    ///\param config_string   [in]  : String to configure the server or the access hardware device.
    ///\param server          [out] : Pointer to the server connection instance. In contrast to the
    ///MCD API's usual calling scheme, the target has to allocate the
    ///object the pointer refers to).
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE        if successful.\n
    ///\c MCD_ERR_CONNECTION  if server connection failed.
    pub unsafe fn mcd_open_server_f(
        &self,
        system_key: *const mcd_char_t,
        config_string: *const mcd_char_t,
        server: *mut *mut mcd_server_st,
    ) -> mcd_return_et {
        (self
            .mcd_open_server_f
            .as_ref()
            .expect("Expected function, got error."))(system_key, config_string, server)
    }
    /// \brief Function closing the connection to a debug server on a host computer.
    ///
    ///This function closes the connection to an opened debug server on a host computer.
    ///
    ///\param server            [in] : Pointer to the server connection instance of the
    ///opened server.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE        if successful.\n
    ///\c MCD_ERR_CONNECTION  if closing the server connection failed.
    pub unsafe fn mcd_close_server_f(&self, server: *const mcd_server_st) -> mcd_return_et {
        (self
            .mcd_close_server_f
            .as_ref()
            .expect("Expected function, got error."))(server)
    }
    /// \brief Function changing the configuration of an open debug server.
    ///
    ///This function allows to change the configuration of an open server.
    ///Note that McdHostName, McdServerName and McdSystemInstance can't be changed with this function.
    ///When the \c config_string contains such parameter which can't be changed or parameters which can't
    ///be changed to the requested value (e.g. new McdAccHw.Frequency not supporte by the Access HW), these
    ///parameters will be ignored or e.g. the closest possible value will be chosen by the implementation.
    ///This behavior allows to use the same config strings/files for \ref mcd_set_server_config_f() as for
    ///\ref mcd_open_server_f(). The tool should always read back the actual config parameter values with
    ///\ref mcd_qry_server_config_f().
    ///
    ///\param server            [in] : Pointer to the server connection instance of the
    ///opened server.
    ///\param config_string     [in] : String to configure the server or access hardware
    ///device.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE        if successful.\n
    ///\c MCD_ERR_CONNECTION  if configuration of the server or access hardware device failed.
    pub unsafe fn mcd_set_server_config_f(
        &self,
        server: *const mcd_server_st,
        config_string: *const mcd_char_t,
    ) -> mcd_return_et {
        (self
            .mcd_set_server_config_f
            .as_ref()
            .expect("Expected function, got error."))(server, config_string)
    }
    /// \brief Function retrieving the configuration string of a debug server.
    ///
    ///This function retrieves the configuration string of an opened
    ///debug server.
    ///
    ///The string can be used to retrieve the configuration of a server
    ///for the following cases:
    ///- Server has been opened without setting "McdServerName" via \c config_string.
    ///- Server has been configured with a server specific proprietary tool.
    ///
    ///Calling \ref mcd_qry_server_config_f() with \c max_len being a NULL pointer returns
    ///the required string length for \c config_string. The returned length includes the
    ///terminating zero. This retrieved configuration can be stored by an MCD based tool
    ///in order to configure the server connection of the next session.
    ///
    ///\param server            [in]   : Pointer to the server connection instance.
    ///\param max_len           [in]   : Maximum length of \c config_string (as allocated
    ///by the calling function).
    ///\param max_len           [out]  : Actual length required by the returned configuration
    ///string.
    ///\param config_string     [out]  : String describing the configuration of the server or
    ///the access hardware device.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE              if successful.\n
    ///\c MCD_ERR_CONNECTION        if server connection could not be accessed.\n
    ///\c MCD_ERR_RESULT_TOO_LONG   if requested configuration string is longer than \c max_len.
    pub unsafe fn mcd_qry_server_config_f(
        &self,
        server: *const mcd_server_st,
        max_len: *mut u32,
        config_string: *mut mcd_char_t,
    ) -> mcd_return_et {
        (self
            .mcd_qry_server_config_f
            .as_ref()
            .expect("Expected function, got error."))(server, max_len, config_string)
    }
    /// \brief Function querying the core connection information of a specified number of systems.
    ///
    ///This function queries for the core connection information of a specified number
    ///of systems. The returned \c core_con_info data are distinguished for different
    ///systems only by the name of the system. If \c num_systems is set to '0', the
    ///function call returns the number of all available systems.
    ///
    ///\param start_index     [in]  : Start index of the queried systems. This refers to an
    ///internal list of the target side implementation.
    ///\param num_systems     [in]  : The number of queried systems starting from the defined
    ///\c start_index. If it is set to '0', no core connection
    ///information is returned but the number of available systems.
    ///\param num_systems     [out] : The number of systems the core connection info was returned
    ///for. In case the input value of \c num_systems is '0', this
    ///is the number of all available systems.
    ///\param system_con_info [out] : Core connection information of the requested systems. This
    ///is an array allocated by the calling function.
    ///
    ///Only the following information of \c system_con_info shall be set by the target:
    ///- \c system_key
    ///- \c system
    ///- \c system_instance
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE     if successful.\n
    ///\c MCD_ERR_PARAM    if \c system_index is equal or larger than the number of available systems.\n
    ///\c MCD_ERR_GENERAL  on any other error.
    pub unsafe fn mcd_qry_systems_f(
        &self,
        start_index: u32,
        num_systems: *mut u32,
        system_con_info: *mut mcd_core_con_info_st,
    ) -> mcd_return_et {
        (self
            .mcd_qry_systems_f
            .as_ref()
            .expect("Expected function, got error."))(
            start_index, num_systems, system_con_info
        )
    }
    /// \brief Function querying the core connection information of a specified number of devices of a system.
    ///
    ///This function queries for the core connection information of a specified number of devices of a
    ///particular system. If \c num_devices is set to '0', the function call returns the number of
    ///all available devices for the system.
    ///
    ///\param system_con_info  [in]  : Core connection information of the system the devices
    ///are queried from.
    ///\param start_index      [in]  : Start index of the requested devices. This refers to
    ///an internal list of the target side implementation.
    ///\param num_devices      [in]  : The number of queried devices (e.g. simulated on or
    ///connected to this host computer) starting from the
    ///defined \c start_index. If it is set to '0', no core
    ///connection information is returned but the number of
    ///all available devices.
    ///\param num_devices      [out] : The number of devices the core connection information
    ///was returned for. In case the input value of \c num_devices
    ///is '0', this is the number of all available devices for
    ///the selected system.
    ///\param device_con_info  [out] : Core connection information of the requested devices.
    ///This is an array allocated by the calling function.
    ///
    ///Only the \c system and \c system_instance information of \c system_con_info are
    ///used for system selection.
    ///
    ///Only the following information of \c device_con_info shall be set by the target:
    ///- \c host
    ///- \c server_port
    ///- \c system_key
    ///- \c device_key       (zero length string if no device key)
    ///- \c system
    ///- \c system_instance  (zero length string for Real HW)
    ///- \c acc_hw           (for Real HW)
    ///- \c device_type
    ///- \c device
    ///- \c device_id
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE       if successful.\n
    ///\c MCD_ERR_PARAM      if \c start_index is equal or larger than the number of available devices.\n
    ///\c MCD_ERR_GENERAL    on any other error.
    pub unsafe fn mcd_qry_devices_f(
        &self,
        system_con_info: *const mcd_core_con_info_st,
        start_index: u32,
        num_devices: *mut u32,
        device_con_info: *mut mcd_core_con_info_st,
    ) -> mcd_return_et {
        (self
            .mcd_qry_devices_f
            .as_ref()
            .expect("Expected function, got error."))(
            system_con_info,
            start_index,
            num_devices,
            device_con_info,
        )
    }
    /// \brief Function querying the core connection information of a specified number of cores of a system/device.
    ///
    ///This function queries the core connection information of a specified number of cores of a system/device.
    ///
    ///\param connection_info  [in]  : Core connection information of the system or device the cores
    ///are queried from.
    ///\param start_index      [in]  : Start index of the requested cores. This refers to an internal
    ///list of the target side implementation.
    ///\param num_cores        [in]  : The number of queried cores starting from the defined \c start_index.
    ///If it is set to '0', no core connection information is returned but
    ///the number of all available cores.
    ///\param num_cores        [out] : The number of cores the core connection information is returned for.
    ///In case the input value of \c num_cores is '0', this is the number of
    ///all available cores for the selected system or device.
    ///\param core_con_info    [out] : Core connection information of the requested cores. This is an array
    ///allocated by the calling function.
    ///
    ///Only the \c system and \c system_instance information of \c connection_info are used for
    ///system selection.
    ///
    ///For selecting a specific device, the following information of \c connection_info is used:
    ///- \c host
    ///- \c server_port
    ///- \c system_key
    ///- \c device_key       (zero length string if no device key)
    ///- \c system
    ///- \c system_instance  (zero length string for Real HW)
    ///- \c acc_hw           (for Real HW)
    ///- \c device_type
    ///- \c device
    ///- \c device_id
    ///
    ///If \c device and \c acc_hw are given for Real HW, only the cores of this specific device
    ///will be returned.
    ///
    ///The output parameter \c core_con_info shall contain the complete \ref mcd_core_con_info_st
    ///information except from \c device_key.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE       if successful.\n
    ///\c MCD_ERR_PARAM      if \c start_index is equal or larger than the number of available cores.\n
    ///\c MCD_ERR_GENERAL    on any other error.
    pub unsafe fn mcd_qry_cores_f(
        &self,
        connection_info: *const mcd_core_con_info_st,
        start_index: u32,
        num_cores: *mut u32,
        core_con_info: *mut mcd_core_con_info_st,
    ) -> mcd_return_et {
        (self
            .mcd_qry_cores_f
            .as_ref()
            .expect("Expected function, got error."))(
            connection_info,
            start_index,
            num_cores,
            core_con_info,
        )
    }
    /// \brief Function querying the available modes of a core.
    ///
    ///This function queries the available modes of a specific core.
    ///
    ///\param core             [in]  : A reference to the core the calling function addresses.
    ///\param start_index      [in]  : Start index of the requested modes. This refers to an
    ///internal list of the target side implementation.
    ///\param num_modes        [in]  : The number of queried core modes starting from the defined
    ///\c start_index. If it is set to '0', no core modes are
    ///returned but the number of all available core modes.
    ///\param num_modes        [out] : The number of returned core modes. In case the input value
    ///of \c num_modes is '0', this is the number of all available
    ///core modes for the selected core.
    ///\param core_mode_info   [out] : Core mode information of the requested core. This is an
    ///array allocated by the calling function.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE       if successful.\n
    ///\c MCD_ERR_PARAM      if \c start_index is equal or larger than the number of available core modes.\n
    ///\c MCD_ERR_GENERAL    on any other error.
    pub unsafe fn mcd_qry_core_modes_f(
        &self,
        core: *const mcd_core_st,
        start_index: u32,
        num_modes: *mut u32,
        core_mode_info: *mut mcd_core_mode_info_st,
    ) -> mcd_return_et {
        (self
            .mcd_qry_core_modes_f
            .as_ref()
            .expect("Expected function, got error."))(
            core, start_index, num_modes, core_mode_info
        )
    }
    /// \brief Function opening a core connection.
    ///
    ///This function opens a specific core connection.
    ///
    ///\param core_con_info  [in]  : Unambigious core information (e.g. from \ref mcd_qry_cores_f()).
    ///\param core           [out] : Pointer to the requested core connection instance (In contrast to
    ///the API's usual scheme, the target has to allocate the object the
    ///pointer refers to).
    ///
    ///Note that \c device_key needs to be set in \c core_con_info in case of opening a locked device.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE           if successful.\n
    ///\c MCD_ERR_PARAM          if \c core_con_info is ambigious.\n
    ///\c MCD_ERR_DEVICE_LOCKED  if the requested device is locked.\n
    ///\c MCD_ERR_CONNECTION     if opening the core connection failed.
    pub unsafe fn mcd_open_core_f(
        &self,
        core_con_info: *const mcd_core_con_info_st,
        core: *mut *mut mcd_core_st,
    ) -> mcd_return_et {
        (self
            .mcd_open_core_f
            .as_ref()
            .expect("Expected function, got error."))(core_con_info, core)
    }
    /// \brief Function closing a core connection.
    ///
    ///This function closes a specific core connection.
    ///
    ///\param core   [in] : Pointer to the core connection instance of the core to close.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE          if successful.\n
    ///\c MCD_ERR_CONNECTION    if closing the core connection failed.
    pub unsafe fn mcd_close_core_f(&self, core: *const mcd_core_st) -> mcd_return_et {
        (self
            .mcd_close_core_f
            .as_ref()
            .expect("Expected function, got error."))(core)
    }
    /// \brief Function allowing the access to detailed error and/or event information after an API call.
    ///
    ///This function allows the user to access detailed error and/or event information after an API call.
    ///
    ///Almost all MCD API functions return a value of type \c mcd_return_et. This is an enumeration type
    ///informing the calling function how to react on the API function call's results. If an error occurred,
    ///the calling function has to call this function in order to obtain details about the error and/or
    ///event which occurred during the previous call and in order to gain further details on it.
    ///
    ///\param core       [in]  : A reference to the core the calling function addresses. This parameter
    ///can be NULL if the error occured at a function without a parameter of
    ///type \ref mcd_core_st.
    ///\param error_info [out] : Pointer to a structure containing the detailed error/event information.
    pub unsafe fn mcd_qry_error_info_f(
        &self,
        core: *const mcd_core_st,
        error_info: *mut mcd_error_info_st,
    ) {
        (self
            .mcd_qry_error_info_f
            .as_ref()
            .expect("Expected function, got error."))(core, error_info)
    }
    /// \brief Function retrieving the file information of an IP-XACT description of the addressed component.
    ///
    ///This functions can be used to request the URL where an IP-XACT
    ///description describing a system can be aquired. The most common for
    ///is to use a URL starting with "file://..." refering to a local
    ///file where the desciption is stored in the local filesystem. This
    ///is also the only mandatory URI scheme ("protocol") which must be
    ///supported in every tool.  Other possible options are URLs starting
    ///with "http://..." or "ftp://...". URLs might either point to the
    ///MCD server itself, but could also point to locations on other
    ///servers.
    ///
    ///\param core        [in]   : A reference to the core the calling function addresses.
    ///\param url         [out]  : A pointer to the string containing the URL pointing to the IP-XACT description
    ///is returned through this parameter. Space for the URL must be reserved by the
    ///caller. The string returned must be null terminated except if it is too large to
    ///fit the buffer. If called with a null pointer then the required buffer size will
    ///be returned in the url_length parameter.
    ///\param url_length  [in]   : Pointing to the size of the buffer allocated by the caller.
    ///\param url_length  [out]  : Pointing to the size of the URL returned excluding the terminating '\\0' character.
    ///When called with url=0 returns the size of the buffer required including the
    ///terminating '\\0' character.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE      if successful.\n
    ///\c MCD_ERR_GENERAL   if URL could not be provided.
    pub unsafe fn mcd_qry_device_description_f(
        &self,
        core: *const mcd_core_st,
        url: *mut mcd_char_t,
        url_length: *mut u32,
    ) -> mcd_return_et {
        (self
            .mcd_qry_device_description_f
            .as_ref()
            .expect("Expected function, got error."))(core, url, url_length)
    }
    /// \brief Function querying the maximum payload size for a transaction list.
    ///
    ///Different systems will support a different maximum in transaction list payload sizes.
    ///The payload is the net number of bytes that are read or written. This function queries
    ///the maximum payload size for a transaction list.
    ///Since a tool needs to be able to deal with smaller payload sizes, the only reason to use
    ///larger payloads is an improved performance. In order to achieve this performance, it is
    ///recommended that \c max_payload is equal to the payload allowing the optimum performance.
    ///\c max_payload then should be obeyed by the sent transaction lists.
    ///
    ///\param core        [in]  : A reference to the core the calling function addresses.
    ///\param max_payload [out] : Maximum (and optimum) supported payload size for a
    ///transaction list.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE     if successful.\n
    ///\c MCD_ERR_GENERAL  on any other error.
    pub unsafe fn mcd_qry_max_payload_size_f(
        &self,
        core: *const mcd_core_st,
        max_payload: *mut u32,
    ) -> mcd_return_et {
        (self
            .mcd_qry_max_payload_size_f
            .as_ref()
            .expect("Expected function, got error."))(core, max_payload)
    }
    /// \brief Function querying the input handle for the connection.
    ///
    ///Fast and efficient reaction on target system events with a single threaded application
    ///requires that the application can wait for user input or asychronous activity from the target.
    ///Obtaining the handle used for the communication to the target (usually a socket) allows
    ///the application to wait for activity there without frequent polling. If the communication is
    ///not done by sockets then there may be no such handle.
    ///
    ///\param core         [in]  : A reference to the core the calling function addresses.
    ///\param input_handle [out] : Input handle or -1 if handle not defined.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE     if successful.\n
    ///\c MCD_ERR_GENERAL  on any other error.
    pub unsafe fn mcd_qry_input_handle_f(
        &self,
        core: *const mcd_core_st,
        input_handle: *mut u32,
    ) -> mcd_return_et {
        (self
            .mcd_qry_input_handle_f
            .as_ref()
            .expect("Expected function, got error."))(core, input_handle)
    }
    ///  \brief Function querying the available memory spaces for a particular component.
    ///
    ///There can be various memory spaces visible to a core depending on its architecture.
    ///For Harvard architectures these can be "program" and "data", for DSP
    ///architecture these can be "P"/"X"/"Y", etc. This function queries all memory spaces
    ///available for a particular target core.
    ///
    ///\param core           [in]  : A reference to the core the calling function addresses.
    ///\param start_index    [in]  : Start index of the requested memory spaces. This refers
    ///to an internal list of the target side implementation.
    ///\param num_mem_spaces [in]  : Number of memory spaces, information is requested of. If
    ///it is set to '0', no memory space information is returned
    ///but the number of all available memory spaces for the
    ///selected core.
    ///\param num_mem_spaces [out] : The number of returned memory spaces. In case the input
    ///value of \c num_mem_spaces is '0', this is the number of
    ///all available memory spaces for the selected core.
    ///\param mem_spaces     [out] : Memory space information. This is an array allocated by
    ///the calling function.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE              if successful.\n
    ///\c MCD_ERR_NO_MEM_SPACES     if no memory spaces are defined for this core.
    pub unsafe fn mcd_qry_mem_spaces_f(
        &self,
        core: *const mcd_core_st,
        start_index: u32,
        num_mem_spaces: *mut u32,
        mem_spaces: *mut mcd_memspace_st,
    ) -> mcd_return_et {
        (self
            .mcd_qry_mem_spaces_f
            .as_ref()
            .expect("Expected function, got error."))(
            core, start_index, num_mem_spaces, mem_spaces
        )
    }
    ///  \brief Function querying the available memory blocks of a specified memory space.
    ///
    ///There can be various memory blocks within a particular memory space of a core. The
    ///memory blocks define the layout of the memory space. Memory blocks can be hierarchical
    ///in nature, and this query function returns information about all available memory
    ///blocks in the memory space. Memory blocks with the same parent must not overlap.
    ///This call returns existing memory blocks only. If a target side implementation supports
    ///memory block descriptions, the calling function may assume that memory which does not
    ///belong to any memory block is not addressable.
    ///
    ///\param core           [in]  : A reference to the core the calling function addresses.
    ///\param mem_space_id   [in]  : The ID of the memory space the calling function queries
    ///the memory block information from.
    ///\param start_index    [in]  : Start index of the requested memory blocks. This refers
    ///to an internal list of the target side implementation.
    ///\param num_mem_blocks [in]  : Number of memory blocks, information is requested of. If
    ///it is set to '0', no memory block information is returned
    ///but the number of all available memory blocks for the
    ///selected memory.
    ///\param num_mem_blocks [out] : Number of returned memory blocks. In case the input value
    ///of \c num_mem_blocks is '0', this is the number of all
    ///available memory blocks for the selected memory space.
    ///\param mem_blocks     [out] : Memory block information. This is an array allocated by
    ///the calling function.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE              if successful.\n
    ///\c MCD_ERR_NO_MEM_BLOCKS     if no memory blocks are defined for this memory space.
    pub unsafe fn mcd_qry_mem_blocks_f(
        &self,
        core: *const mcd_core_st,
        mem_space_id: u32,
        start_index: u32,
        num_mem_blocks: *mut u32,
        mem_blocks: *mut mcd_memblock_st,
    ) -> mcd_return_et {
        (self
            .mcd_qry_mem_blocks_f
            .as_ref()
            .expect("Expected function, got error."))(
            core,
            mem_space_id,
            start_index,
            num_mem_blocks,
            mem_blocks,
        )
    }
    ///  \brief Function querying the active (swapped-in) overlays at the current time.
    ///
    ///This function is called when the caller wants to retrieve the list of active
    ///memory overlays. This is typically done when a breakpoint is hit.
    ///
    ///\param core                [in]  : A reference to the core the calling function addresses.
    ///\param start_index         [in]  : Start index of the requested active memory overlays. This
    ///refers to an internal list of the target side implementation.
    ///\param num_active_overlays [in]  : Number of active memory overlays, information is requested of.
    ///If it is set to '0', no active memory overlay information is
    ///returned but the number of all available active memory overlays
    ///for the selected core.
    ///\param num_active_overlays [out] : Number of returned active memory overlays. In case the input
    ///value of \c num_active_overlays is '0', this is the number of
    ///all available active memory overlays for the selected core.
    ///\param active_overlays     [out] : Active memory overlay information. This is an array allocated
    ///by the calling function.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE         if successful.\n
    ///\c MCD_ERR_OVERLAYS     if retrieving active memory overlay information failed.
    pub unsafe fn mcd_qry_active_overlays_f(
        &self,
        core: *const mcd_core_st,
        start_index: u32,
        num_active_overlays: *mut u32,
        active_overlays: *mut u32,
    ) -> mcd_return_et {
        (self
            .mcd_qry_active_overlays_f
            .as_ref()
            .expect("Expected function, got error."))(
            core,
            start_index,
            num_active_overlays,
            active_overlays,
        )
    }
    ///  \brief Function querying the register groups defined for a particular component.
    ///
    ///
    ///
    ///There can be various register groups defined for a core depending on its
    ///architecture. This function queries information about these register groups.
    ///
    ///The parameter \c num_reg_groups is used as an input/output parameter.
    ///As input parameter it is set to the desired number of register groups. As
    ///output parameter it set to the actual number of register groups information
    ///is returned for in \c reg_groups.
    ///If the target does not define any register groups, it is assumed that a
    ///virtual register group with ID 0 exists which contains all registers of the
    ///corresponding component. Then the information about this default 'virtual'
    ///register group has to be sent back as only register group information.
    ///
    ///\param core           [in]  : A reference to the core the calling function addresses.
    ///\param start_index    [in]  : Start index of the requested register groups. This refers
    ///to an internal list of the target side implementation.
    ///\param num_reg_groups [in]  : Number of register groups, information is requested of. If
    ///it is set to '0', no register groups information is
    ///returned but the number of all available register groups
    ///for the selected core.
    ///\param num_reg_groups [out] : Number of returned register groups. In case the input
    ///value of \c num_reg_groups is '0', this is the number of
    ///all available register groups for the selected core.
    ///\param reg_groups     [out] : Register group information. This is an array allocated
    ///by the calling function.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE              if successful.\n
    ///\c MCD_ERR_NO_REG_GROUPS     if no register groups are defined for this core.
    pub unsafe fn mcd_qry_reg_groups_f(
        &self,
        core: *const mcd_core_st,
        start_index: u32,
        num_reg_groups: *mut u32,
        reg_groups: *mut mcd_register_group_st,
    ) -> mcd_return_et {
        (self
            .mcd_qry_reg_groups_f
            .as_ref()
            .expect("Expected function, got error."))(
            core, start_index, num_reg_groups, reg_groups
        )
    }
    ///  \brief Function querying the register information of a particular register group.
    ///
    ///There can be various register groups defined for a core depending on its architecture.
    ///Within each register group there can be many registers. This function allows the user
    ///to query information about the registers contained within a register group. Information
    ///all registers which have to be exposed to the debug environment have to be returned as
    ///a result of such a query.
    ///
    ///\param core          [in]  : A reference to the core the calling function addresses.
    ///\param reg_group_id  [in]  : ID of the register group detailed register information
    ///is requested for.
    ///\param start_index   [in]  : Start index of the requested registers. This refers to
    ///an internal list of the target side implementation.
    ///\param num_regs      [in]  : Number of registers, information is requested of. If it
    ///is set to '0', no register information is returned but
    ///the number of all available registers within for the
    ///selected register group.
    ///\param num_regs      [out] : Number of returned registers. In case the input value
    ///of \c num_regs is '0', this is the number of all
    ///available register for the selected register group.
    ///\param reg_info      [out] : Register information. This is an array allocated by the
    ///calling function.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE             if successful.\n
    ///\c MCD_ERR_REG_GROUP_ID     if no register group with this ID is available for this core.
    pub unsafe fn mcd_qry_reg_map_f(
        &self,
        core: *const mcd_core_st,
        reg_group_id: u32,
        start_index: u32,
        num_regs: *mut u32,
        reg_info: *mut mcd_register_info_st,
    ) -> mcd_return_et {
        (self
            .mcd_qry_reg_map_f
            .as_ref()
            .expect("Expected function, got error."))(
            core,
            reg_group_id,
            start_index,
            num_regs,
            reg_info,
        )
    }
    ///  \brief Function querying the component registers of a compound register.
    ///
    ///Registers within a target component may be composed of several simple registers.
    ///These are by definition called "compound registers". This function allows a user
    ///to query information about the registers contained within a particular compound
    ///register.
    ///
    ///\param core            [in]  : A reference to the core the calling function addresses.
    ///\param compound_reg_id [in]  : ID of the compound register component register IDs are
    ///queried for.
    ///\param start_index     [in]  : Start index of the requested component registers. This
    ///refers to an internal list of the target side implementation.
    ///\param num_reg_ids     [in]  : Number of component registers the ID is requested of.
    ///If it is set to '0', no component register IDs are returned
    ///but the number of all available component register for
    ///the selected compound register.
    ///\param num_reg_ids     [out] : Number of returned component registers. In case the input
    ///value of \c num_reg_ids is '0', this is the number of all
    ///available component registers for the selected compound
    ///register.
    ///\param reg_id_array    [out] : Component register IDs. This is an array allocated by the
    ///calling function.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE                  if successful.\n
    ///\c MCD_ERR_REG_NOT_COMPOUND      if no compound register with this ID is available for this core.
    pub unsafe fn mcd_qry_reg_compound_f(
        &self,
        core: *const mcd_core_st,
        compound_reg_id: u32,
        start_index: u32,
        num_reg_ids: *mut u32,
        reg_id_array: *mut u32,
    ) -> mcd_return_et {
        (self
            .mcd_qry_reg_compound_f
            .as_ref()
            .expect("Expected function, got error."))(
            core,
            compound_reg_id,
            start_index,
            num_reg_ids,
            reg_id_array,
        )
    }
    /// \brief Function querying information about trigger capabilities.
    ///
    ///This function queries information about trigger capabilities implemented
    ///in a target.
    ///
    ///\param core       [in]   : A reference to the core the calling function addresses.
    ///\param trig_info  [out]  : Information about supported triggers.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE        if successful.\n
    ///\c MCD_ERR_GENERAL     if trigger capabilities could not be retrieved.
    pub unsafe fn mcd_qry_trig_info_f(
        &self,
        core: *const mcd_core_st,
        trig_info: *mut mcd_trig_info_st,
    ) -> mcd_return_et {
        (self
            .mcd_qry_trig_info_f
            .as_ref()
            .expect("Expected function, got error."))(core, trig_info)
    }
    /// \brief Function querying information about custom triggers.
    ///
    ///This function queries information about custom triggers of a component
    ///as well as the number of available custom triggers.
    ///
    ///\param core        [in]  : A reference to the core the calling function addresses.
    ///\param start_index [in]  : Start index of the requested custom triggers. This refers
    ///to an internal list of the target side implementation.
    ///\param num_ctrigs  [in]  : Number of custom triggers, information is requested of.
    ///If it is set to '0', no custom trigger information is
    ///returned but the number of all available custom triggers
    ///for the selected core.
    ///\param num_ctrigs  [out] : Number of returned custom triggers. In case the input value
    ///of \c num_ctrigs is '0', this is the number of all available
    ///custom triggers for the selected core.
    ///\param ctrig_info  [out] : Custom trigger information. This is an array allocated by the
    ///calling function.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE     if successful.\n
    ///\c MCD_ERR_PARAM    if custom trigger ID does not exist.
    pub unsafe fn mcd_qry_ctrigs_f(
        &self,
        core: *const mcd_core_st,
        start_index: u32,
        num_ctrigs: *mut u32,
        ctrig_info: *mut mcd_ctrig_info_st,
    ) -> mcd_return_et {
        (self
            .mcd_qry_ctrigs_f
            .as_ref()
            .expect("Expected function, got error."))(
            core, start_index, num_ctrigs, ctrig_info
        )
    }
    /// \brief Function allowing the creation of a new trigger.
    ///
    ///This function allows a user to create a new trigger. If the exact trigger cannot be
    ///created, an approximate trigger is created instead and the \c modified member of the
    ///trigger structure is set.
    ///
    ///The void pointer \c trig usually points to a standard trigger structure like
    ///\c mcd_trig_simple_core_st or \ref mcd_trig_complex_core_st.
    ///
    ///\param core        [in]  : A reference to the core the calling function addresses.
    ///\param trig        [in]  : Pointer to the structure containing information about
    ///the trigger object to be created.
    ///\param trig        [out] : Members of the structure may be modified by the function.
    ///In this case the \c modified member of the trigger structure
    ///as well as the modified members are set.
    ///\param trig_id     [out] : Unique ID for the newly created trigger returned by the API
    ///implementation. A value of '0' indicates that the breakpoint
    ///is set, but cannot be identified by an ID. Removing such
    ///breakpoints is only possible by calling \ref mcd_remove_trig_set_f().
    ///
    ///\return Return code (\ref mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE          if successful.\n
    ///\c MCD_ERR_TRIG_CREATE   if trigger could not be created.
    pub unsafe fn mcd_create_trig_f(
        &self,
        core: *const mcd_core_st,
        trig: *mut ::std::os::raw::c_void,
        trig_id: *mut u32,
    ) -> mcd_return_et {
        (self
            .mcd_create_trig_f
            .as_ref()
            .expect("Expected function, got error."))(core, trig, trig_id)
    }
    /// \brief Function querying the contents of a trigger.
    ///
    ///This function allows the user to query the contents of a trigger.
    ///The \c max_trig_size parameter is set to the maximum size of
    ///the trigger structure the user expects in bytes.
    ///
    ///The void pointer \c trig usually points to a standard trigger
    ///structure like \ref mcd_trig_simple_core_st or \ref mcd_trig_complex_core_st.
    ///
    ///\param core          [in]  : A reference to the core the calling function addresses.
    ///\param trig_id       [in]  : ID of the trigger the user queries.
    ///\param max_trig_size [in]  : Maximum size of the structure in bytes as expected by
    ///the calling function.
    ///\param trig          [out] : Pointer to the structure receiving the information about
    ///the trigger object. The structure is allocated by the
    ///calling function.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE              if successful.\n
    ///\c MCD_ERR_RESULT_TOO_LONG   if requested trigger is larger than \c max_trig_size.\n
    ///\c MCD_ERR_TRIG_ACCESS       if trigger could not be returned for any other reason.
    pub unsafe fn mcd_qry_trig_f(
        &self,
        core: *const mcd_core_st,
        trig_id: u32,
        max_trig_size: u32,
        trig: *mut ::std::os::raw::c_void,
    ) -> mcd_return_et {
        (self
            .mcd_qry_trig_f
            .as_ref()
            .expect("Expected function, got error."))(core, trig_id, max_trig_size, trig)
    }
    /// \brief Function allowing a user to delete a particular trigger from a trigger set.
    ///
    ///This function allows the user to delete a particular trigger from a trigger set.
    ///
    ///\param core        [in] : A reference to the core the calling function addresses.
    ///\param trig_id     [in] : ID of the trigger the user wants to delete.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE              if successful.\n
    ///\c MCD_ERR_TRIG_ACCESS       if trigger could not be accessed for deletion.
    pub unsafe fn mcd_remove_trig_f(
        &self,
        core: *const mcd_core_st,
        trig_id: u32,
    ) -> mcd_return_et {
        (self
            .mcd_remove_trig_f
            .as_ref()
            .expect("Expected function, got error."))(core, trig_id)
    }
    /// \brief Function allowing a user to query the trigger states from the target.
    ///
    ///This function allows a user to query the status of a single trigger.
    ///Note that \ref mcd_qry_trig_set_state_f() needs to be called before to sample the trigger state.
    ///
    ///\param core        [in]  : A reference to the core the calling function addresses.
    ///\param trig_id     [in]  : ID of the trigger, the tool queries the state for.
    ///\param trig_state  [out] : Queried Trigger state. The structure is allocated by
    ///the calling function.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE              if successful.\n
    ///\c MCD_ERR_TRIG_ACCESS       if trigger could not be accessed.
    pub unsafe fn mcd_qry_trig_state_f(
        &self,
        core: *const mcd_core_st,
        trig_id: u32,
        trig_state: *mut mcd_trig_state_st,
    ) -> mcd_return_et {
        (self
            .mcd_qry_trig_state_f
            .as_ref()
            .expect("Expected function, got error."))(core, trig_id, trig_state)
    }
    /// \brief Function allowing a user to activat a trigger set on the target.
    ///
    ///This function downloads the current trigger set to the hardware in order to activate
    ///it. If the trigger set is unchanged since the last call of this function, it will just
    ///arm the triggers again.
    ///
    ///This function is only needed to activate triggers on the fly (while the target is running)
    ///and in a consistent way - if supported by the target.
    ///
    ///\param core       [in]  : A reference to the core the calling function addresses.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE              if successful.\n
    ///\c MCD_ERR_TRIG_ACCESS       if trigger set could not be activated.
    pub unsafe fn mcd_activate_trig_set_f(&self, core: *const mcd_core_st) -> mcd_return_et {
        (self
            .mcd_activate_trig_set_f
            .as_ref()
            .expect("Expected function, got error."))(core)
    }
    /// \brief Function allowing a user to delete a trigger set.
    ///
    ///This function allows a user to delete a trigger set for a particular core.
    ///
    ///\param core           [in]  : A reference to the core the calling function addresses.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE              if successful.\n
    ///\c MCD_ERR_TRIG_ACCESS       if trigger set could not be removed.
    pub unsafe fn mcd_remove_trig_set_f(&self, core: *const mcd_core_st) -> mcd_return_et {
        (self
            .mcd_remove_trig_set_f
            .as_ref()
            .expect("Expected function, got error."))(core)
    }
    /// \brief Function querying the contents of a trigger set.
    ///
    ///This function queries information about the current state of the trigger set of a target core.
    ///
    ///\param core             [in]     : A reference to the core the calling function addresses.
    ///\param start_index      [in]     : Start index of the requested triggers. This refers to an
    ///internal list of the target side implementation.
    ///\param num_trigs        [in]     : The number of queried triggers starting from the defined
    ///\c start_index. If it is set to '0', no triggers are
    ///returned but the number of all available triggers of the
    ///trigger set.
    ///\param num_trigs        [out]    : The number of returned triggers. In case the input value
    ///of \c num_trigs is '0', this is the number of all available
    ///triggers of this core's trigger set.
    ///\param trig_ids         [out]    : List of trigger IDs set in the target. This is an array
    ///allocated by the calling function.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE              if successful.\n
    ///\c MCD_ERR_TRIG_ACCESS       if trigger set could not be queried.
    pub unsafe fn mcd_qry_trig_set_f(
        &self,
        core: *const mcd_core_st,
        start_index: u32,
        num_trigs: *mut u32,
        trig_ids: *mut u32,
    ) -> mcd_return_et {
        (self
            .mcd_qry_trig_set_f
            .as_ref()
            .expect("Expected function, got error."))(core, start_index, num_trigs, trig_ids)
    }
    /// \brief Function querying the state of a trigger set.
    ///
    ///This function queries information about the current state of the trigger set of a target core.
    ///It will consistently sample the state of all triggers in the set.
    ///This is in particular necessary for Real HW targets.
    ///The individual triggers can then be queried with \ref mcd_qry_trig_state_f().
    ///
    ///\param core        [in]  : A reference to the core the calling function addresses.
    ///\param trig_state  [out] : Information about the current state of the trigger set.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE              if successful.\n
    ///\c MCD_ERR_TRIG_ACCESS       if state of the trigger set could not be queried.
    pub unsafe fn mcd_qry_trig_set_state_f(
        &self,
        core: *const mcd_core_st,
        trig_state: *mut mcd_trig_set_state_st,
    ) -> mcd_return_et {
        (self
            .mcd_qry_trig_set_state_f
            .as_ref()
            .expect("Expected function, got error."))(core, trig_state)
    }
    /// \brief Function executing a transaction list on the target.
    ///
    ///This function sends a transaction list to the target for execution and retrieves
    ///the result. It is blocking, so it is the responsiblity of the tool to make sure
    ///that the execution time will be reasonable by creating a transaction list with
    ///an appropriate payload size.
    ///
    ///Note that multiple tools can issue transaction lists requests to the same core at
    ///the same time.
    ///
    ///In case of an error, the execution of the transaction list is immediately aborted.
    ///
    ///\param core      [in]  : A reference to the core the calling function addresses.
    ///\param txlist    [in]  : A pointer to the transaction list for execution.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE           if successful.\n
    ///\c MCD_ERR_TXLIST_READ    if execution of the transaction list aborted due to a specific read access.\n
    ///\c MCD_ERR_TXLIST_WRITE   if execution of the transaction list aborted due to a specific write access.\n
    ///\c MCD_ERR_TXLIST_TX      if execution of the transaction list aborted due to any other reason.
    pub unsafe fn mcd_execute_txlist_f(
        &self,
        core: *const mcd_core_st,
        txlist: *mut mcd_txlist_st,
    ) -> mcd_return_et {
        (self
            .mcd_execute_txlist_f
            .as_ref()
            .expect("Expected function, got error."))(core, txlist)
    }
    /// \brief Function starting execution on a particular core.
    ///
    ///This function causes the corresponding target core to begin execution.
    ///
    ///\param core           [in]  : A reference to the core the calling function addresses.
    ///\param global         [in]  : Set to "TRUE" if all cores of a system shall start
    ///execution. Otherwise, starting execution of selected
    ///core only.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE      if successful.\n
    ///\c MCD_ERR_GENERAL   if starting execution failed.
    pub unsafe fn mcd_run_f(&self, core: *const mcd_core_st, global: mcd_bool_t) -> mcd_return_et {
        (self
            .mcd_run_f
            .as_ref()
            .expect("Expected function, got error."))(core, global)
    }
    /// \brief Function stopping execution on a particular core.
    ///
    ///This function causes the corresponding target core to stop execution.
    ///
    ///\param core           [in]  : A reference to the core the calling function addresses.
    ///\param global         [in]  : Set to "TRUE" if all cores of a system shall start
    ///execution. Otherwise, starting execution of selected
    ///core only.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE      if successful.\n
    ///\c MCD_ERR_GENERAL   if stopping execution failed.
    pub unsafe fn mcd_stop_f(&self, core: *const mcd_core_st, global: mcd_bool_t) -> mcd_return_et {
        (self
            .mcd_stop_f
            .as_ref()
            .expect("Expected function, got error."))(core, global)
    }
    /// \brief Function running a particular core until a defined time.
    ///
    ///This function causes the corresponding target core to run for a defined
    ///time before it stops. If \c absolute_time is "FALSE", \c run_until_time
    ///is the value of the system timer that is associated with this core. This
    ///means it starts again from '0' for certain reset types, and it needs
    ///to be scaled depending on the crystal and PLL settings in order to determine
    ///a time value.
    ///If \c absolute_time is "TRUE", \c run_until_time is an absolute time
    ///in seconds. Usually, a simulation model can only support this case.
    ///
    ///\param core           [in]  : A reference to the core the calling function addresses.
    ///\param global         [in]  : Set to "TRUE" if all cores of a system shall start
    ///execution. Otherwise, starting execution of selected
    ///core only.
    ///\param absolute_time  [in]  : Boolean value indicating whether the time parameter
    ///is absolute or not.
    ///\param run_until_time [in]  : The number of time units (picoseconds) until which the
    ///target core shall run.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE      if successful.\n
    ///\c MCD_ERR_GENERAL   if execution failed.
    pub unsafe fn mcd_run_until_f(
        &self,
        core: *const mcd_core_st,
        global: mcd_bool_t,
        absolute_time: mcd_bool_t,
        run_until_time: u64,
    ) -> mcd_return_et {
        (self
            .mcd_run_until_f
            .as_ref()
            .expect("Expected function, got error."))(
            core, global, absolute_time, run_until_time
        )
    }
    /// \brief Function querying the current time of execution from the target system.
    ///
    ///This function returns the current execution time of the target.
    ///
    ///\param core           [in]   : A reference to the core the calling function addresses.
    ///\param current_time   [out]  : The current number of time units (picoseconds) the target
    ///system has been running.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE      if successful.\n
    ///\c MCD_ERR_GENERAL   if querying for the time failed.
    pub unsafe fn mcd_qry_current_time_f(
        &self,
        core: *const mcd_core_st,
        current_time: *mut u64,
    ) -> mcd_return_et {
        (self
            .mcd_qry_current_time_f
            .as_ref()
            .expect("Expected function, got error."))(core, current_time)
    }
    /// \brief Function stepping a target core based on the particular step type.
    ///
    ///This function causes the corresponding target core to step based on the provided
    ///step type.
    ///
    ///Note that the function is blocking. It is the responsibility of the tool to call
    ///it with a reasonable number of steps.
    ///
    ///\param core        [in]  : A reference to the core the calling function addresses.
    ///\param global      [in]  : Set to "TRUE" if all cores of a system shall start
    ///execution. Otherwise, starting execution of selected
    ///core only.
    ///\param step_type   [in]  : The unit, the stepping of the target core is based on.
    ///\param n_steps     [in]  : The number of steps, the target core is stepped for.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE      if successful.\n
    ///\c MCD_ERR_GENERAL   if stepping the target core failed.
    pub unsafe fn mcd_step_f(
        &self,
        core: *const mcd_core_st,
        global: mcd_bool_t,
        step_type: mcd_core_step_type_et,
        n_steps: u32,
    ) -> mcd_return_et {
        (self
            .mcd_step_f
            .as_ref()
            .expect("Expected function, got error."))(core, global, step_type, n_steps)
    }
    /// \brief Function enabling/disabling global stop and run activities on this core
    ///
    ///This function enables or disables the effect of a global run and stop on this core.
    ///The default state is target specific.
    ///
    ///\param core        [in]  : A reference to the core the calling function addresses.
    ///\param enable      [in]  : Set to "TRUE" if this core should perform global run or
    ///stop activities.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE      if successful.\n
    ///\c MCD_ERR_GENERAL   if enabling/disabling the global effect of execution functions failed.
    pub unsafe fn mcd_set_global_f(
        &self,
        core: *const mcd_core_st,
        enable: mcd_bool_t,
    ) -> mcd_return_et {
        (self
            .mcd_set_global_f
            .as_ref()
            .expect("Expected function, got error."))(core, enable)
    }
    /// \brief Function querying the execution state of a target core.
    ///
    ///This function queries the current execution state of a particular target core.
    ///
    ///\param core         [in]  : A reference to the core the calling function addresses.
    ///\param state        [out] : The current execution state of the target core.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE      if successful.\n
    ///\c MCD_ERR_GENERAL   if querying the execution state failed.
    pub unsafe fn mcd_qry_state_f(
        &self,
        core: *const mcd_core_st,
        state: *mut mcd_core_state_st,
    ) -> mcd_return_et {
        (self
            .mcd_qry_state_f
            .as_ref()
            .expect("Expected function, got error."))(core, state)
    }
    /// \brief Function executing a command on the target platform.
    ///
    ///This function sends a command to the target platform and retrieves the
    ///result in the form of a string.
    ///
    ///\param core               [in]  : A reference to the core the calling function addresses.
    ///\param command_string     [in]  : The command string. This is implementation specific.
    ///\param result_string_size [in]  : The maximum size of the result string.
    ///\param result_string      [out] : The result string allocated by the calling function.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE      if successful.\n
    ///\c MCD_ERR_GENERAL   if executing the command failed.
    pub unsafe fn mcd_execute_command_f(
        &self,
        core: *const mcd_core_st,
        command_string: *const mcd_char_t,
        result_string_size: u32,
        result_string: *mut mcd_char_t,
    ) -> mcd_return_et {
        (self
            .mcd_execute_command_f
            .as_ref()
            .expect("Expected function, got error."))(
            core,
            command_string,
            result_string_size,
            result_string,
        )
    }
    /// \brief Function querying information about reset classes supported by the target system.
    ///
    ///This function queries all available reset classes of the target system. Each bit
    ///of \c rst_class_vector represents an available reset class.
    ///
    ///It is recommended that the strongest reset (e.g. power-on reset) is of class '0'.
    ///
    ///\param core             [in]  : A reference to the core the calling function addresses.
    ///\param rst_class_vector [out] : A 32 bit vector that defines the available reset classes.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE      if successful.\n
    ///\c MCD_ERR_GENERAL   if querying the reset classes failed.
    pub unsafe fn mcd_qry_rst_classes_f(
        &self,
        core: *const mcd_core_st,
        rst_class_vector: *mut u32,
    ) -> mcd_return_et {
        (self
            .mcd_qry_rst_classes_f
            .as_ref()
            .expect("Expected function, got error."))(core, rst_class_vector)
    }
    /// \brief Function querying information about a particular reset class supported by the target system
    ///
    ///This function queries more detailed information about a particular reset class
    ///of the target system.
    ///
    ///\param core             [in]  : A reference to the core the calling function addresses.
    ///\param rst_class        [in]  : Reset class ID which refers to a bit in the 32-bit reset
    ///class vector as obtained by \ref mcd_qry_rst_classes_f().
    ///\param rst_info         [out] : Reference to an object of type \ref mcd_rst_info_st
    ///containing detailed information about this reset class.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE      if successful.\n
    ///\c MCD_ERR_PARAM     if reset class does not exist.\n
    ///\c MCD_ERR_GENERAL   if any other error occurred.
    pub unsafe fn mcd_qry_rst_class_info_f(
        &self,
        core: *const mcd_core_st,
        rst_class: u8,
        rst_info: *mut mcd_rst_info_st,
    ) -> mcd_return_et {
        (self
            .mcd_qry_rst_class_info_f
            .as_ref()
            .expect("Expected function, got error."))(core, rst_class, rst_info)
    }
    /// \brief Function triggering one or more reset signals in parallel on the target system.
    ///
    ///This function triggers one or more reset signals in parallel on the target system.
    ///
    ///\param core             [in]  : A reference to the core the calling function addresses.
    ///\param rst_class_vector [in]  : Reset vector specifying the resets which shall be issued.
    ///\param rst_and_halt     [in]  : Optionally halting the core if the reset changes the core
    ///state.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE      if successful.\n
    ///\c MCD_ERR_PARAM     if one or several reset classes do not exist.\n
    ///\c MCD_ERR_GENERAL   if any other error occurred.
    pub unsafe fn mcd_rst_f(
        &self,
        core: *const mcd_core_st,
        rst_class_vector: u32,
        rst_and_halt: mcd_bool_t,
    ) -> mcd_return_et {
        (self
            .mcd_rst_f
            .as_ref()
            .expect("Expected function, got error."))(core, rst_class_vector, rst_and_halt)
    }
    /// \brief Function opening a communication channel between the host tool and the target.
    ///
    ///This function opens a defined communication channel between a host side tool and a target.
    ///The addressed target is identified by a core reference.
    ///This function call allows to establish a communication channel between the host side tool
    ///and any hierarchical level of the targeted system (i.e. at system level, at device level
    ///or at core level). For this reason, this function call accepts core structures which have
    ///their member \c instance set to a null pointer for levels higher than core level. The target
    ///implementation actually needs to determine the targeted hierarchical level based on the member
    ///\c core_con_info of the core structure.
    ///The established channel is described by \c channel. Only a single debugger may be attached
    ///to a communication channel at a time.
    ///
    ///\param core            [in]  : A reference to the targeted system, device or core. Here,
    ///member \c instance is allowed to be a null pointer for
    ///levels higher than core level.
    ///\param channel         [in]  : Requested channel setup.
    ///\param channel         [out] : Accepted and at least for \c chl_id modified channel setup.
    ///Note that \c max_msg_len and \c prio can be changed as well if
    ///the requested values are not possible.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE                      if successful.\n
    ///\c MCD_ERR_CHL_TYPE_NOT_SUPPORTED    if unsupported channel type was requested.\n
    ///\c MCD_ERR_CHL_TARGET_NOT_SUPPORTED  if addressed target does not support communication channels.\n
    ///\c MCD_ERR_CHL_SETUP                 if channel setup is invalid or contains unsupported attributes.
    pub unsafe fn mcd_chl_open_f(
        &self,
        core: *const mcd_core_st,
        channel: *mut mcd_chl_st,
    ) -> mcd_return_et {
        (self
            .mcd_chl_open_f
            .as_ref()
            .expect("Expected function, got error."))(core, channel)
    }
    /// \brief Function send a message using a specified communication channel.
    ///
    ///This function sends a message using a defined communication channel between the host
    ///and the target.
    ///
    ///\param core            [in]   : A reference to the targeted system, device or core. Here,
    ///member \c instance is allowed to be a null pointer for
    ///levels higher than core level.
    ///\param channel          [in]  : Description of the addressed communication channel.
    ///\param msg_len          [in]  : The number of bytes sent with this message.
    ///\param msg              [in]  : Message buffer.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE                if successful.\n
    ///\c MCD_ERR_CHL_MESSAGE_FAILED  if sending the message failed.
    pub unsafe fn mcd_send_msg_f(
        &self,
        core: *const mcd_core_st,
        channel: *const mcd_chl_st,
        msg_len: u32,
        msg: *const u8,
    ) -> mcd_return_et {
        (self
            .mcd_send_msg_f
            .as_ref()
            .expect("Expected function, got error."))(core, channel, msg_len, msg)
    }
    /// \brief Function receiving a message using a specified communication channel.
    ///
    ///This function receives a message using a defined communication channel between the host
    ///and the target.
    ///
    ///\param core            [in]  : A reference to the targeted system, device or core. Here,
    ///for member \c instance is allowed to be a null pointer for
    ///levels higher than core level.
    ///\param channel         [in]  : Description of the addressed communication channel.
    ///\param timeout         [in]  : Number of time units (milliseconds) until function call times out.
    ///\param msg_len         [in]  : Maximum number of bytes that can be fetched with this call.
    ///\param msg_len         [out] : Number of bytes that have been actually fetched with this call.
    ///\param msg             [out] : Message buffer.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE                if successful.\n
    ///\c MCD_ERR_CHL_MESSAGE_FAILED  if receiving of the message failed.
    pub unsafe fn mcd_receive_msg_f(
        &self,
        core: *const mcd_core_st,
        channel: *const mcd_chl_st,
        timeout: u32,
        msg_len: *mut u32,
        msg: *mut u8,
    ) -> mcd_return_et {
        (self
            .mcd_receive_msg_f
            .as_ref()
            .expect("Expected function, got error."))(core, channel, timeout, msg_len, msg)
    }
    /// \brief Function resetting a specified communication channel.
    ///
    ///This function resets a communication channel between the host and the target.
    ///This allows the communication to be setup again e.g. if the communication hangs.
    ///
    ///\param core            [in] : A reference to the targeted system, device or core.
    ///Here, member \c instance is allowed to be a null
    ///pointer for levels higher than core level.
    ///\param channel         [in] : Description of the addressed communication channel.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE       if successful.\n
    ///\c MCD_ERR_GENERAL    if resetting the communication channel failed.
    pub unsafe fn mcd_chl_reset_f(
        &self,
        core: *const mcd_core_st,
        channel: *const mcd_chl_st,
    ) -> mcd_return_et {
        (self
            .mcd_chl_reset_f
            .as_ref()
            .expect("Expected function, got error."))(core, channel)
    }
    /// \brief Function closing a specified communication channel.
    ///
    ///This function closes a communication channel between the host and the target.
    ///
    ///\param core            [in] : A reference to the targeted system, device or core.
    ///Here, member \c instance is allowed to be a null
    ///pointer for levels higher than core level.
    ///\param channel         [in] : Description of the addressed communication channel.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE       if successful.\n
    ///\c MCD_ERR_GENERAL    if closing the communication channel failed.
    pub unsafe fn mcd_chl_close_f(
        &self,
        core: *const mcd_core_st,
        channel: *const mcd_chl_st,
    ) -> mcd_return_et {
        (self
            .mcd_chl_close_f
            .as_ref()
            .expect("Expected function, got error."))(core, channel)
    }
    /// \brief Function querying information about available traces for a core.
    ///
    ///\param core             [in]  : A reference to the core of which the traces are requested.
    ///\param start_index      [in]  : Start index of the requested traces. This refers to an
    ///internal list of the target side implementation.
    ///\param num_traces       [in]  : The number of queried traces starting from the defined
    ///\c start_index. If it is set to '0', no traces are returned
    ///but the number of all available traces.
    ///\param num_traces       [out] : The number of returned traces. In case the input value of
    ///\c num_traces is '0', this is the number of all available
    ///traces for the selected core.
    ///\param trace_info       [out] : Trace information of the requested traces. This is an array
    ///allocated by the calling function.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE       if successful.\n
    ///\c MCD_ERR_PARAM      if \c trace_index is equal or larger than the number of traces.\n
    ///\c MCD_ERR_GENERAL    on any other error.
    pub unsafe fn mcd_qry_traces_f(
        &self,
        core: *const mcd_core_st,
        start_index: u32,
        num_traces: *mut u32,
        trace_info: *mut mcd_trace_info_st,
    ) -> mcd_return_et {
        (self
            .mcd_qry_traces_f
            .as_ref()
            .expect("Expected function, got error."))(
            core, start_index, num_traces, trace_info
        )
    }
    /// \brief Function querying the status of a trace.
    ///
    ///This function queries the current status of a particular trace source.
    ///
    ///\param core             [in]  : A reference to the core to which the trace belongs.
    ///\param trace_id         [in]  : ID to which this trace refers to.
    ///\param state            [out] : The current state of the trace.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE       if successful.\n
    ///\c MCD_ERR_PARAM      if \c trace_id is not a valid trace ID.\n
    ///\c MCD_ERR_GENERAL    on any other error.
    pub unsafe fn mcd_qry_trace_state_f(
        &self,
        core: *const mcd_core_st,
        trace_id: u32,
        state: *mut mcd_trace_state_st,
    ) -> mcd_return_et {
        (self
            .mcd_qry_trace_state_f
            .as_ref()
            .expect("Expected function, got error."))(core, trace_id, state)
    }
    /// \brief Function setting the state and mode of a trace.
    ///
    ///This function sets the state and mode of a particular trace source.
    ///
    ///\param core         [in]  : A reference to the core to which the trace belongs.
    ///\param trace_id     [in]  : ID of the trace which is referenced.
    ///\param state        [in]  : The trace settings to be applied.
    ///\param state        [out] : Returns the current state of the trace. Member
    ///\c modified is set if a member has changed.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE       if successful.\n
    ///\c MCD_ERR_PARAM      if \c trace_id is not a valid trace ID.\n
    ///\c MCD_ERR_GENERAL    on any other error.
    pub unsafe fn mcd_set_trace_state_f(
        &self,
        core: *const mcd_core_st,
        trace_id: u32,
        state: *mut mcd_trace_state_st,
    ) -> mcd_return_et {
        (self
            .mcd_set_trace_state_f
            .as_ref()
            .expect("Expected function, got error."))(core, trace_id, state)
    }
    /// \brief Function reading trace data from a trace.
    ///
    ///This function reads trace data from a particular trace source.
    ///
    ///\param core             [in]     : A reference to the core to which the trace belongs.
    ///\param trace_id         [in]     : ID of the trace which is referenced.
    ///\param start_index      [in]     : Start index of frame to read (0 = oldest frame).
    ///This refers to an internal list of the target
    ///implementation which stores the trace frames.
    ///\param num_frames       [in]     : The number of queried trace frames starting from
    ///the defined \c start_index. If it is set to '0',
    ///no trace data is returned but the number of all
    ///currently available trace frames.
    ///\param num_frames       [out]    : The number of read trace frames. In case the input
    ///value of \c num_frames is '0', this is the number
    ///of all currently available trace frames.
    ///\param trace_data_size  [in]     : Size of one trace data frame in bytes (for type checking).
    ///\param trace_data       [out]    : Array of trace data structures filled by this function.
    ///The format depends on the trace source. Standard formats
    ///are \ref mcd_trace_data_core_st, \ref mcd_trace_data_event_st
    ///and \ref mcd_trace_data_stat_st.
    ///
    ///\return Return code (\c mcd_return_et).
    ///
    ///\par Allowed error codes:
    ///\c MCD_ERR_NONE       if successful.\n
    ///\c MCD_ERR_PARAM      if \c trace_id is not a valid trace ID, or if start_index is larger
    ///than the number of available trace frames.\n
    ///\c MCD_ERR_GENERAL    on any other error.
    pub unsafe fn mcd_read_trace_f(
        &self,
        core: *const mcd_core_st,
        trace_id: u32,
        start_index: u64,
        num_frames: *mut u32,
        trace_data_size: u32,
        trace_data: *mut ::std::os::raw::c_void,
    ) -> mcd_return_et {
        (self
            .mcd_read_trace_f
            .as_ref()
            .expect("Expected function, got error."))(
            core,
            trace_id,
            start_index,
            num_frames,
            trace_data_size,
            trace_data,
        )
    }
}
