use std::{
    fs::File,
    io::Write,
    process::{Child, Command},
};

use anyhow::Context;
use tempfile::TempDir;

/// Models an upload of a binary with Memtool
pub struct MemtoolUpload {
    spawned: Child,
    _temporary_files: TempDir,
}

impl MemtoolUpload {
    /// Upload a binary to the default device in Memtool
    ///
    /// It generates a configuration file and uses Memtool's batch functionality to
    /// instruct the program to flash all available sections to the device.
    ///
    /// For the created operation to succeed successfully, a DAS instance must
    /// be already spawned, the device to be flashed is selected based on the given
    /// UDAS port.
    ///
    /// Note that the binary must not contain unflashable sections.
    pub fn start(ihex: String, halt_memtool: bool, udas_port: usize) -> anyhow::Result<Self> {
        let temporary_files = TempDir::new().unwrap();

        let input_hex_path = temporary_files.path().join("input.hex");
        let mut input_hex = File::create(&input_hex_path)?;
        input_hex.write_all(ihex.as_bytes()).unwrap();
        input_hex.flush().unwrap();

        let temporary_memtool_config_path = temporary_files.path().join("temp_config.cfg");
        let mut temporary_memtool_config = File::create(&temporary_memtool_config_path)?;
        write_cfg(&mut temporary_memtool_config, udas_port).unwrap();
        temporary_memtool_config.flush().unwrap();

        let mtb = if !halt_memtool {
            format!("connect\nopen_file {}\nselect_all_sections\nadd_selected_sections\nprogram\ndisconnect\nexit", input_hex_path.display())
        } else {
            format!(
                "connect\nopen_file {}\n",
                temporary_files.path().join("input.hex").display()
            )
        };

        let batch_file_path = temporary_files.path().join("batch.mtb");
        let mut batch_file = File::create(&batch_file_path)?;
        batch_file.write_all(mtb.as_bytes()).unwrap();
        batch_file.flush().unwrap();

        let mut process = Command::new(env!("MEMTOOL_PATH")); // MEMTOOL_PATH is checked in the build.rs

        let process = process
            .arg("-c")
            .arg(temporary_memtool_config_path.display().to_string())
            .arg(batch_file_path.display().to_string());
        let spawned = process
            .spawn()
            .with_context(|| "Could not start memtool to flash device")?;
        log::info!("Spawned Infineon Memtool to flash hex file");

        Ok(MemtoolUpload {
            spawned,
            _temporary_files: temporary_files,
        })
    }

    /// Wait on the process to finish
    ///
    /// This can take a second, but if the tool fails execution it will hang here.
    /// This can happen when the flash layout is broken or when another debugger
    /// is already attached. The problem can only really be debugged with the GUI
    /// or solved by implementing reading the logs from Memtool.
    pub fn wait(&mut self) {
        let output = self
            .spawned
            .wait()
            .expect("Memtool did not exit with success");
        assert!(output.success());
        log::info!("Infineon Memtool terminated successfully");
    }
}

/// Write a Memtool configuration file to output
///
/// The configuration file is templated based on the default configuration in Memtool
/// from the TC37xA family, but the DAS port can be selected freely.
fn write_cfg<W: Write>(target: &mut W, udas_port: usize) -> Result<(), std::io::Error> {
    write!(
        target,
        "[Main]
Signature=UDE_TARGINFO_2.0
MCUs=Controller0
Description=Autogenerated configuration for board {udas_port}
Description1=Init TLF35584 C-Step on connect
Description2=switch off FLASH error traps
Architecture=TriCore Aurix2G
Vendor=Starter Kits (DAS)
Board=

[Controller0]
Family=TriCore
Type=TC37xA
Enabled=1
IntClock=100000
ExtClock=20000

[Controller0.Core0]
Protocol=TC2_JTAG
Enabled=1

[Controller0.Core0.LoadedAddOn]
UDEMemtool=1

[Controller0.Core0.Tc2CoreTargIntf]
PortType=DAS
CommDevSel=
MaxJtagClk=5000
DasTryStartSrv=1
DasSrvPath=servers\\udas\\udas.exe
ConnOption=Reset
DiswdtOnReset=1
ExecInitCmds=1
TargetPort=Default
CheckJtagId=0
ScanJTAG=0
Ocds1ViaPod=0
EtksArbiterMode=None
RefreshJtag=0
RefreshHarr=0
ReenableOcds=1
ReduceJtagClock=0
UseDap=0
DapMode=2PIN
SetDebugEnableAb1DisablePin=0
ResetWaitTime=500
ResetMode=Default
OpenDrainReset=0
SetPllOnReset=0x0
SetPllOnReset2=0x0
ExecOnConnectCmds=0
ExecOnExtRstCmds=0
FailOnResetMalfunction=0
ResetPulseLen=10
AddResetDelay=0
ExecEmemInitOnReset=0x0
UnlockInterface=0
BootPasswd0=0x0
BootPasswd1=0x0
BootPasswd2=0x0
BootPasswd3=0x0
BootPasswd4=0x0
BootPasswd5=0x0
BootPasswd6=0x0
BootPasswd7=0x0
PasswordFile=
HandleBmiHeader=0
SetAutOkOnConnect=0
DontUseWdtSusp=0
MaxTry=1
UseDflashAccessFilter=1
UseTranslateAddr=1
DownloadToAllRams=0
HaltAfterReset=0
TargetAppHandshakeMode=None
TargetAppHandshakeTimeout=100
TargetAppHandshakeParameter0=0x0
TargetAppHandshakeParameter1=0x0
TargetAppHandshakeParameter2=0x0
TargetAppHandshakeParameter3=0x0
SimioAddr=g_JtagSimioAccess
UseStmForPtm=1
ExecOnStartCmds=0
ExecOnHaltCmds=0
UseTriggerToBreak=1
UseTL2OnHalt=1
UseOstateStable=1
AllowJtagResetWhileRunning=1
MaxAccRetry=1
AccRetryDelay=10
DebugResetOnDisconnect=0
ReadPmcsrWhileRunning=0
IvIcacheOnHalt=1
IvPlbOnHalt=1
SuspendSlaveCores=0
FilterMemAcc=1
DasDllPath=das_api.dll
DasHost=
DasStopSrv=1
DasResetHelperBreakAddr=main
DasResetMode=2
DasRemoveLogFile=0
DasForwardSerNum=0
DasSrvSel=-1
DasPortType=0
DasPortSel={udas_port}
DasCmdTimeout=1000
DasWaitAfterConnect=0
InitCore0RamOnConnect=0
IgnoreFailedHaltAfterResetOnConnect=0
TrySystemResetAfterFailedHardwareReset=0
RunStabilityTestOnConnect=0
RunStabilityTestCycles=10
IgnoreFailedEnableOcdsOnConnect=0
UseLbistAwareConnect=0
TC4InitCore0Ram=0
EnableAutomaticCsrmStart=0
EnableAutomaticCsrmRunControl=0
DetectResetWhileHalted=1
HaltAfterHardwareReset=0
ExecOnHaltCmdsWhileHaltedPeriod=0
PtmRefClock=0
DasDisconnectSrv=0
DasApiLogging=0

[Controller0.Core0.Tc2CoreTargIntf.InitScript]
; Init TLF35584 C-Step on connect
SET 0xF0036034  0x11100002
SET 0xF0001E00  0x8
SET 0xF0001E10  0x20003C04
SET 0xF0001E04  0x1
SET 0xF0001E14  0x14000000
SET 0xF0001E24  0x501
SET 0xF0001E48  0x00020000
SET 0xF003AF10  0x98000000
SET 0xF003AF14  0x10980000
SET 0xF003AF40  0x30330333
SET 0xF003AE10  0x10980000
SET 0xF003AE40  0x33333033
WAIT 5
SET 0xF0001E54  0xFFF
SET 0xF0001E60  0x17A10001
SET 0xF0001E54 0x200
WAIT 5
SET 0xF0001E10  0x21003C04
SET 0xF0001E64 0x8756
WAIT 5
SET 0xF0001E54 0x200
WAIT 5
SET 0xF0001E54 0x400
SET 0xF0001E64 0x87DE
WAIT 5
SET 0xF0001E54 0x200
WAIT 5
SET 0xF0001E54 0x400
SET 0xF0001E64 0x86AD
WAIT 5
SET 0xF0001E54 0x200
WAIT 5
SET 0xF0001E54 0x400
SET 0xF0001E64 0x8625
WAIT 5
SET 0xF0001E54 0x200
WAIT 5
SET 0xF0001E54 0x400
SET 0xF0001E64 0x8D27
WAIT 5
SET 0xF0001E54 0x200
WAIT 5
SET 0xF0001E54 0x400
SET 0xF0001E64 0x8A01
WAIT 5
SET 0xF0001E54 0x200
WAIT 5
SET 0xF0001E54 0x400
SET 0xF0001E64 0x87BE
WAIT 5
SET 0xF0001E54 0x200
WAIT 5
SET 0xF0001E54 0x400
SET 0xF0001E64 0x8668
WAIT 5
SET 0xF0001E54 0x200
WAIT 5
SET 0xF0001E54 0x400
SET 0xF0001E64 0x877D
WAIT 5
SET 0xF0001E54 0x200
WAIT 5
SET 0xF0001E54 0x400
SET 0xF0001E64 0x8795
WAIT 5
SET 0xF0001E54 0x200
WAIT 5
SET 0xF0001E54 0x400
WAIT 5

; switch off FLASH error traps
set 0xF8801104 0x10000
set 0xF8821104 0x10000
set 0xF8841104 0x10000
set 0xF8040048 0xC0000000

[Controller0.Core0.Tc2CoreTargIntf.OnStartScript]

[Controller0.Core0.Tc2CoreTargIntf.OnHaltScript]

[Controller0.Core0.Tc2CoreTargIntf.Suspend]
STM0=1
STM1=1
STM2=1

[Controller0.PFLASH]
Enabled=1
EnableMemtoolByDefault=1

[Controller0.DF_EEPROM]
Enabled=1
EnableMemtoolByDefault=1

[Controller0.DF_UCBS]
Enabled=1
EnableMemtoolByDefault=1


[Controller0.Core0.Tc2CoreTargIntf.OnConnectScript]"
    )
}
